<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring笔记]]></title>
    <url>%2F2018%2F12%2F01%2FSpring-notes%2F</url>
    <content type="text"><![CDATA[Spring笔记IOC简化Java开发采取以下四种策略,降低Java开发的复杂性 基于POJO的轻量级和最小侵入性编程 通过依赖注入(DI)和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板式代码 依赖注入 Sprin通过应用上下文(Application Context)装载bean的定义并把它们组装起来.Spring应用上下文全权负责对象的创建和组装.Spring自带多种应用上下文的实现,他们之间的主要区别仅仅在于如何加载配置 两种方式配置bean 通过xml配置, 通过java配置 应用切面 DI能够让相互协作的软件组件保持松耦合,而面向切面编程(AOP)允许你把遍布应用各处的功能分离出来形成可重用的组件. Beanbean的创建方式 调用默认无参构造函数创建(常用) 使用静态工厂中的方法创建对象 使用实例工厂中的方法创建 bean的作用范围通过配置bean的scope属性来调整作用范围,属性取值有 属性值 描述 singleton 单例的(默认值) prototype 多例的(当我们让spring接管struts2的action创建时,action必须配置此值) request 作用范围是一次请求,和当前请求的转发 session 作用范围是一次会话 globalsession 作用范围是一次全局会话 bean的生命周期单例:随着容器的创建而创建,销毁而销毁 多例:每次使用时创建对象,只要对象在使用中就一直存在,被垃圾回收器回收销毁 在config类中装配bean带有@Bean注解的方法可以采用任何必要的java功能来产生bean实例. 引用创建bean的方法来装配bean 1234@Beanpublic CDPlayer cdPlayer()&#123; return new CDPlayer(aDisc()); // aDisc()也是位于其他任何位置的一个创建bean的方法&#125; 1234@Beanpublic CompactDisc aDisc()&#123; return new ADisc();&#125; 使用Setter方法注入 123456@Beanpublic CDPlayer cdPlayer(CompactDisc aDisc)&#123; CDPlayer cdPlayer = new CDPlayer(); cdPlayer.setCompactDisc(aDisc); return cdPlayer;&#125; 依赖注入注入方式 使用构造函数注入 使用set方法注入(推荐,不改变类结构) 使用注解注入 注入的数据类型 基本类型和String类型 其他bean类型(必须在spring的配置文件中出现过的bean) 复杂类型(集合类型) 基于注解的IoC 用于创建bean对象 @Component: 作用:相当于配置了一个bean标签 位置:出现在类上面 属性:value.含义是指定bean的id,默认值:当前类的短名,首字母小写 @Controller,@Service,@Repository这三个注解是基于@Component的拓展,并且具有特定功能.分别用于表现层,业务层和持久层 @Bean 作用:把方法的返回值注入容器中 位置:出现在方法上 属性:name-用于指定bean的id,默认值是方法的名称,首字母小写 用于注入数据 @AutoWired: 作用:自动按照类型注入,只要有唯一的类型匹配就能注入成功.如果注入的beasn在容器中不唯一,就把变量名作为bena的id,在容器中查找,找到后也能注入成功.还不成功则报错 @Qualifier 作用:在自动按照类型注入的基础上,再按照bean的id注入.在给类成员注入数据时,不能独立使用.但是在给方法的形参注入数据时,可以独立使用. 属性:value-用于指定bean的id @Resource 作用:直接按照bean的id注入 属性:name-用于指定bean的id @Value 作用:用于注入基本类型和String类型数据.可以借助SpEL表达式读取properties文件中的配置 属性:value-用于指定要注入的数据 用于改变作用范围 @Scope 作用:用于改变bean的作用范围 属性:value-用于指定范围的取值 新增注解 @ComponentScan 作用:告知Spring哪些packages的用注解标识的类会被spring自动扫描并且装入bean容器 位置:最好单独写在一个config类上 属性:value,basePackages-用于指定扫描的包,是String集合 @Configuration 作用:把当前类看做为Spring的配置类 类上的注解@Configuration是最新的用注解配置spring,也就是说这是个配置文件,和原来xml配置是等效的,只不过现在用java代码进行配置了,加上一个@Configuration注解就行了.不需要繁琐的xml配置了，这样基于注解的配置，可读性也大大增高了。 @Import 作用:导入其他配置类 属性:value-指定需要导入的配置类,值类型为字节码(.class)的集合 这样就可以使用其他配置类中的bean,而不需要去将一个配置类创建为bean. @PropertiesSource 作用:将properties配置文件中的值存储到Spring的Environment中,Environment接口提供方法去读取配置文件中的值,参数是properties文件中定义的key值.或使用${xxx..xxx}来获取值 属性:value-值为properties的路径String集合 Srping整合junit 拷贝Spring提供的整合jar包:spring-test-4.2.4.RELEASE.jar 使用junit提供的一个注解,把原有的main函数替换掉,换成Spring提供的@RunWith,要替换的类:SpringJunit4ClassRunner 即@RunWith(SpringJunit4ClassRunner.class) 使用注解告知Spring,配置文件或者注解所在的位置:@ContextConfiguration 即@ContextConfiguration(classes={配置类字节码}) 如果不整合junit,在单元测试时无法使用在方法之外的变量 AOP术语 连接点(Join point) 连接点是程序执行过程中能够应用通知的所有点. 通知(Advice) 通知是指拦截到切点之后要做的事情就是通知,包含了需要用于多个应用对象的横切行为. 切点(Pointcut) 切点定义了通知被应用的具体位置.切点定义了那些连接点会得到通知. 切面(Aspect) 切面是通知和切点的结合.通知和切点共同定义了切面的全部内容–它是什么,在何时和在何处完成其功能. 引入(Introduction) 引入允许我们向现有的类添加新方法或属性. 织入(Weaving) 织入是把切面应用到目标对象并创建新的代理对象的过程.切面在指定的连接点被织入到目标对象中.在目标对象的生命周期里有多个点可以进行织入. aop配置步骤切点表达式关键字:execution(表达式) 表达式写法: 访问修饰符+返回值+包名.包名...类名.方法名(参数列表) 访问修饰符可以省略 返回值可以使用通配符*,表示任意返回值 包名可以使用通配符,但是有几个包就需要几个* 参数类别可以使用具体类型来表示参数类型,也可以使用通配符表示任意参数: 基本类型直接写类型名称:int 应用类型必须是包名.类名:java.lang.Integer 全匹配方式: public void com.vnaso..test.testMethod() 包名后面’..’: 表示当前包及子包 方法参数(..): 表示任何参数类型 全通配方式: * *.*.*(...) xml 把通知类交给spring管理 &lt;bean id=&quot;xxx&quot; class=&quot;aaa.bbb.xxx&quot;/&gt; 导入aop名称控件,并且使用aop:config开始aop的配置 &lt;aop:config&gt;…&lt;/aop:config&gt; 使用aop:aspect配置切面,id属性用于给切面提供一个唯一表示,ref属性用于应用通知Bean的id &lt;aop:aspect id=&quot;abcde&quot; ref=&quot;xxx&quot;&gt;….&lt;/aop:aspect&gt; 配置通知的类型,指定增强的方法何时执行.method属性用于指定增强的方法名称,pointcut属性用于指定切点表达式 &lt;aop:before method=&quot;sadfa&quot; pointcut=&quot;pt&quot;/&gt; 定义切入点表达式,需要定义在通知之前 &lt;aop:pointcut expression=&quot;execution(* com.vnaso..test.testMethod(..))&quot; id = &quot;pt&quot;/&gt; java注解 定义切面:@Aspect,位于类名上. 为切面创建Bean 定义通知:@Before,@After,@AfterReturning,@AfterThrowing,@Around.位于方法上. 定义切点:@Pointcut(切点表达式) 位于要织入的方法上 位于一个空方法上,让方法名()等同于切点表达式. 注意:不能漏掉切点的方法的括号 1234567@Pointcut("execution(* com.vnaso..test.testMethod(..))")private void pt()&#123;&#125;@Before("pt()")public void beforeMethod()&#123; // do something ...&#125; 启动自动代理功能:@EnableAspectJAutoProxy,建议写在配置类上 通知类型 前置通知(Before):在目标方法被调用之前调用通知功能 后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么 返回通知(After-returning):在目标方法成功执行之后调用通知 异常通知(After-throwing):在目标方法抛出异常后调用通知 环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为 执行顺序: 1234567891011try&#123; try&#123; //@Before method.invoke(..); &#125;finally&#123; //@After &#125; //@AfterReturning&#125;catch()&#123; //@AfterThrowing&#125; 注意:被调用的方法才能作为切点,而作为junit测试单元的方法运行时不会有通知 声明式事务APIPlatformTransactionManager此接口是spring的事务管理器,它提供了我们常用的操作事务的方法 接口方法 获取事务状态信息 TransactionStatus getTrasaction(TrasactionDefinition definition) 提交事务 coid commit(TransactionStatus status) 回滚事务 void rollback(TransactionStatus status) 实现类 DataSourceTransactionManager HibernateTransactionManager HibernateX.HibernateTransactionManager X指的是Hibernate的版本 JpaTransactionManager JdoTransactionManager JtaTransactionManager TransactionDefinition它是事务的定义信息对象 方法 获取事务对象名称 String getName() 获取事务隔离级 int getIsolationLevel() ISOLATION_DEFAULT 默认级别，归属下面某一种 ISOLATION_READ_UNCOMMITTED 可以读取未提交数据 ISOLATION_READ-COMMITTED 只能读取已提交数据，解决脏读问题(Oracle默认级别) ISOLATION_REPEATABLE_READ 是否读取其他事务提交修改后的数据,解决不可重复读问题(MySQL默认级别) ISOLATION_SERIALIZABLE 是否读取其他事务提交后的数据,解决幻影读问题 获取事务传播行为 int getPropagationBehavior() REQUIRED 如果当前没有事务,就新建一个事务,如果已经存在一个事务中,加入到这个事务中.(默认值) SUPPORTS 支持当前事务.如果当前没有事务,就以非事务方式执行(没有事务) MANDATORY 使用当前事务,如果当前没有事务,就抛出异常 REQUERS_NEW 新建事务,如果当前在事务中,把当前事务挂起 NOT_SUPPORTED 以非事务方式执行操作,如果当前存在事务,就把当前事务挂起 NEVER 以非事务方式运行,如果当前存在事务,抛出异常 NESTED 如果当前存在事务,则在嵌套事务内执行.如果当前没有事务,则执行REQUIRED类似的操作 获取事务超时时间 int getTimeout() 默认值是-1,没有超时限制.如果有,以秒为单位设置 获取事务是否只读 boolean isReadOnly() TransactionStatus此接口提供的是事务具体的运行状态.描述了某个时间点上事务对象的状态信息 方法 刷新事务 void flush() 获取是否存在存储点 boolean hasSavepoint() 获取事务是否完成 boolean isCompleted() 获取事务是否为新的事务 boolean isNewTransaction() 获取事务是否回滚 boolean isRollbackOnly() 设置事务回滚 void setRollbackOnly() xml配置 配置事务管理器 123&lt;bean id = "transactionManager" class="..."&gt; &lt;property name="dataSource" ref="..."/&gt;&lt;/bean&gt; 配置事务的通知 123456789&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!-- 配置事务的属性 --&gt; &lt;tx:attributes&gt; &lt;!-- 可以使用通配符 --&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORT" read-only="true"/&gt; &lt;tx:method name="..."/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice &lt;tx:method&gt;标签属性 isolation:配置事务的隔离级别 propagation:配置事务的传播行为 timeout:指定事务的超时时间 read-only:配置是否只读事务,默认false(读写) rollback-for:用于指定一个异常,执行产生该异常时,事务回滚.产生其他异常时,不会滚.没有默认值,任何异常都回滚 no-rollback-for:用于指定一个异常,当执行产生该异常时,事务不回滚.产生其他异常时,事务回滚.没有默认值,任何异常都回滚 配置aop:切点表达式,通知和切入点表达式的关联 123456&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression="execution(* com.vnaso.test..testMethod(..))" id="pt1"/&gt; &lt;!-- 配置事务通知和切入点表达式的关联 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt;&lt;/aop:config&gt; java配置 配置事务管理器 新建事务管理的配置类,并编写TransactionManager及其所需要的DataSource的bean 配置spring开启注解事务的支持 一般情况下该注解写在spring的配置类上,需使用@Import导入其他配置类. 使用注解@EnableTransactionManagement开启事务的支持 在需要事务的地方使用@Transactional注解,一般位于@Service下 @Transational(propagation=Propagation.REQUIRED,readOnly=false,...) 接口:表示该接口的所有实现类都有事务 类上:表示该类中所有方法都有事务 方法上:表示该方法有事务 就近原则 知识点 Spring表达式语言装配 SpEL AOP:通知包含了需要用于多个应用对象的横切行为;连接点是程序执行过程中能够应用通知的所有点;切点定义了通知被阴影的具体位置(在哪些连接点).引入允许我们向现有的类添加新的方法和属性. POJO:Plain Old Java Object,是一个简单的、正规Java对象,它包含业务逻辑处理或持久化逻辑等,但不是JavaBean、EntityBean等,不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口 JavaBean:是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。 实用技巧善用properties,降低维护成本,减弱依赖使用方法: 定义一个ResourceBundle对象 private static ResourceBundle bundle = ResourceBundle.getBundle(PROPERTIES_FULL_PATH); PROPERTIES_FULL_PATH为properties全类名路径 使用getXxx(key)根据key读取对应类型的值 优化选项: 使用一个Map容器来存储,用于没有线程安全问题环境下(单例) 1234567891011121314151617private static Map&lt;String,Object&gt; beans = new HashMap&lt;String,Object&gt;();// 使用静态代码,初始化mapstatic&#123; // 读取配置文件中所有的配置 Enumeration&lt;String&gt; keys = bundle.getKeys(); // 遍历keys while(keys.hasMoreElements)&#123; // 取出一个key String key = key.nextElement(); // 根据key获取beanPath String beanPath = bundle.getString(key); // 根据beanPath反射创建类对象 Object value = Class.forName(beanPath).newInstance(); // 把key和value存入map中 beans.put(key,value); &#125;&#125; 动态代理作用:不改变源码的基础上,对已有的方法增强.(是AOP思想的实现技术) 基于接口的动态代理要求:被代理类至少实现一个接口 提供者:JDK官方 涉及的类:Proxy 创建代理对象的方法:newProxyInstance(ClassLoader,Class[],InvocationHandler) 参数的含义: ClassLoader:类加载器,和被代理对象使用相同的类加载器. Class[]:字节码数组,被代理类实现的接口.(要求代理对象和被代理对象具有相同的行为) InvocationHandler:它是一个接口,就是用于提供增强的代码.一般传入一个该接口的实现类,也可以传入一个匿名内部类.含义就是:如何代理.此处的代码只能是谁用谁提供. 使用的是策略模式 123456789101112IActor proxyActor = Proxy.newProxyInstance(actor.getClass().getClassLoader(),actor.getClass().getInterfaces(),new InvocationHandler()&#123; @Override public Object invoke(Object proxy,Method method,Object[] args)throws Throwable&#123; // 执行被代理对象的任何方法都会经过该方法,该方法有拦截的功能 // 方法的参数 // Object proxy: 代理对象的应用,不一定每次都会有 // Method method: 当前执行的方法 // Object[] args: 当前执行方法所需的参数 // 返回值: 当前执行方法的返回值,Object 也可以接受返回类型void. void也是Object子类 // TODO 要添加的增强的代码 &#125;&#125;); 基于子类的动态代理要求:被代理类不能是最终类,不能被final修饰 提供者:第三方CGLib.需导jar包 涉及的类:Enhancer 创建代理对象的方法:create(Class,Callback) 参数的含义: Class:被代理对象的字节码 Callback:如何代理.它和InvocationHandler的作用是一样的,它也是一个接口,我们一般使用该接口的子类MethodInterceptor.在使用时也是创建该接口的匿名内部类 12345678910Actor actor = (Actor)Enhance.create(actor.getClass(),new MethhodInterceptor()&#123; @Override public Object intercept(Object proxy,Method method,Object[] args,MethodProxy methodProxy)throws Throwable&#123; // 执行被代理对象的任何方法,都会经过该方法.它和基于接口动态代理的invoke方法作用是一样的 // 方法的参数 // 前面三个和invoke方法的参数含义和作用都是一样的 // MethodProxy methodProxy: 当前执行方法的代理对象,一般不用 // TODO 增强的代码 &#125;&#125;);]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
</search>
