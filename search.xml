<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaEE]]></title>
    <url>%2F2019%2F03%2F13%2FJavaLearning%2FJavaNote%2FJavaEE%2F</url>
    <content type="text"><![CDATA[1. Servlet 在 Java Web 程序中, Servlet 主要负责接收用户请求 HttpServletRequest , 在 doGet() , doPost() 中做相应的处理, 并将回应 HttpServletResponse 返回给用户. Servlet 可以设置初始化参数, 供 Servlet 内部使用. 一个 Servlet 类中只会有有一个实例, 在它初始化时调用 init() 方法, 销毁时掉哦用 destroy() 方法. Servlet 需要在 web.xml 中配置. 一个 Servlet 可以设置多个 URL 访问. Servlet 非线程安全, 多线程并发的读写会导致数据不同步的问题. 解决的办法是尽量不要定义 name 属性, 而是把 name 变量分别定义在 doGet() 和 doPost() 方法中. 注意: 多线程的并发读写 Servlet 类属性会导致数据不同步. 但是如果只是并发地读取属性而不写入, 则不存在数据不同步的问题. 因此 Servlet 里的只读属性最好定义为 final 类型 1. Servlet 和 CGI 区别CGI 的不足: 需要为每个请求启动一个 CGI 程序的系统进程. 如果请求频繁, 会带来很大开销. 需要为每个请求加载和运行一个 CGI 程序, 带来很大开销. 需要重复编写处理网络协议的代码以及编码, 这些工作都是非常耗时的. Servlet 的优点: 只需要启动一个操作系统进程以及加载一个 JVM , 大大降低了系统的开销. 如果多个请求需要做同样处理的时候, 这时只需要加载一个类, 大大降低了开销. 所有动态加载的类可以实现对网络协议以及请求解码的共享, 大大降低了工作量 Servlet 能直接和 Web 服务器交互, 而普通的 CGI 程序不能. Servlet 还能在各个程序之间共享数据, 使数据库连接池之类的功能很容易实现 一个基于 Java Web 的应用通常包含一个或多个 Servlet 类. Servlet 不能够自行创建并执行, 它是在 Servlet 容器中运行的, 容器将用户的请求传递给 Servlet 程序并将 Servlet 的响应回传给用户. 2. Servlet 接口中的方法及生命周期Servlet 接口中定义了 5 个方法, 其中前三个方法与 Servlet 生命周期相关: void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destroy() java.lang.String getServletInfo() ServletConfig getServletConfig() 生命周期Web 容器加载 Servlet 并将其实例化后, Servlet 生命周期开始. 容器运行其 init() 方法进行 Servlet 的初始化. 请求到达时调用 Servlet 的 service() 方法, service() 方法根据需要调用与请求对应的 doGet() 或 doPost() 方法. 当服务器关闭或项目被卸载时, 服务器会将 Servlet 实例销毁. 此时会调用 Servlet 的 destroy() 方法. init 和 destroy 方法只会执行一次, service 方法会在客户端每次请求 Servlet 时执行. Servlet 中有时会用到一些需要初始化与销毁的资源. 因此可以把初始化资源的代码放入 inti 方法中, 销毁资源的代码放入 destroy 中. 3. 转发(Forward)和重定向的区别(Redirect)的区别转发是服务器行为, 重定向是客户端行为 转发(Forward) 通过 RequestDispatcher 对象的 forward (HttpServletRequest request, HttpServletResponse response) 方法实现的. RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher() 方法获得. 如: request.getRequestDispatcher(&quot;login_sucess.jsp&quot;).forward(request, response); 重定向(Redirect) 利用服务器返回的状态码实现的. 客户端浏览器请求服务器时, 服务器返回一个状态码. 服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码. 如果服务器返回 301 或者 302 , 则浏览器会到新的网址重新请求该资源 从地址栏显示说 forward 是服务器请求资源, 服务器直接访问目标地址的 URL , 把那个 URL 的响应内容读取过来, 然后把这些内容再发给浏览器. 浏览器端不知道服务器发送的内容来自哪里, 所以地址栏还是原来的地址 redirect 是服务端根据逻辑, 发送一个状态码, 告诉浏览器重新去请求哪个地址. 所以地址栏显示的是新的 URL 从数据共享说 forward: 转发的页面和转发到的页面可以共享 request 中的数据 redirect: 不能共享数据 从运用方面说 forward: 一般用于用户登录的时候, 根据角色转发到相应的模块 redirect: 一般用于用户注销登录返回主页面和跳转到其他页面等 从效率说 forward: 高 redirect: 低 4. 实现会话跟踪使用Cookie向客户端发送 Cookie Cookie c = new Cookie("name","value"); // 创建Cookiec.setMaxAge(60*60*24); // 设置最大时效，此处设置的最大时效为一天response.addCookie(c); // 把Cookie放入到HTTP响应中 从客户端读取 Cookie String name ="name"; Cookie[]cookies =request.getCookies(); if(cookies !=null)&#123; for(int i= 0;i&lt;cookies.length;i++)&#123; Cookie cookie =cookies[i]; if(name.equals(cookis.getName())) //something is here. //you can get the value cookie.getValue(); &#125; &#125; 优点: 数据可以持久保存, 不需要服务器资源. 基于文本的 key-value 缺点: 大小受限制, 用户可以禁用 Cookie 功能. 保存在本地, 有安全风险 URL 重写在 URL 中添加用户会话的信息作为请求的参数, 或者将唯一的会话 ID 添加到 URL 结尾以标识一个会话. 优点: 在 Cookie 被禁用时依然可以使用 缺点: 必须对网站的 URL 进行编码, 所有页面必须动态生成. 不能用预先记录下来的 URL 进行访问. 隐藏的表单&lt;input type = "hidden" name = "session" value = "..." /&gt; 优点: Cookie 被禁用时可以使用 缺点: 所有页面必须是表单提交之后的结果 HttpSession最强大功能最多的会话跟踪技术. 当一个用户访问某个网站时会自动创建 HttpSession 分配一个 JSESSIONID. 每个用户可以访问他自己的 HttpSession . 可以通过 HttpServletRequest 对象的 getSession() 方法获得 HttpSession , 通过 HttpSession 对象的 getAttribute() 方法, 同时传入 key 就可以获取保存在 HttpSession 中的对象. HttpSession 保存在服务器的内存中, 因此不要将过大的对象存放在里面. 虽然目前的 Servlet 容器可以在内存即将满时将 HttpSession 中的对象移动到其他存储设备中, 但也会影响性能. 添加到 HttpSession 中的值可以是任意 Java 对象. 这个对象最好实现了 Serializable 接口, 这样 Servlet 容器在必要的时候可以将其序列化到文件中, 否则在序列化时就会出现异常. 使用 和Cookie搭配使用 第一次创建 Session 的时候, 服务端会在 HTTP 协议中告诉客户端需要在 Cookie 里记录一个 Session ID . 以后在每次 HTTP 请求时, 客户端都会发送 Cookie 信息到服务端, Cookie 中就携带着 Session ID 来帮助服务端辨识当前请求的用户身份. 如果客户端禁用了 Cookie 功能, 就会使用下面的方式. 和URL重写技术搭配使用 在每次 HTTP 交互, URL 后面附带加上一个如 sid=xxxx 这样的参数, 服务端根据此来识别用户 Cookie 和 Session 的主要区别在于: Cookie 保存在客户端, Session 保存在服务端 5. Get 和 Post 请求区别 Get Post 用来请求从服务器上获得的资源. 用于幂等的场景 操作服务器资源. 用户不幂等的场景 将表单中数据按照 name = value 的形式, 加上 ? 拼接到 URL 后, 各个变量之间用 &amp; 连接. 将表单中的数据放在 HTTP 协议的请求头或消息体中 传输的数据收到浏览器对 URL 长度的限制(最大长度为 2048 字符) 可以通过 request body 技术传输大量数据, 上传文件通常使用 post 方式 参数会显示在地址栏上 数据不会显示在地址栏 使用 MIME类型 application/x-www-form-urlencode 的 URL 编码文本的格式传递参数 支持更多的编码类型且不对数据类型做限制]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础笔记]]></title>
    <url>%2F2019%2F03%2F11%2FJavaLearning%2FJavaNote%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. JVM JDK 和 JRE javac :包含于JDK中的将.java文件编译为字节码(.class)文件的编译器. JVM可以理解的代码就叫做字节码. 即扩展名为.class的文件. JSP 会被转换为 Java servlet. 并被 JDK 用 javac 编译器编译. 2. 字符型常量和字符串常量 形式上:字符型常量是单引号引起的一个字符.如&#39;a&#39;. 字符串常量是双引号引起的若干个字符如&quot;Hello world&quot;. 含义上:字符型常量可以当做一个整形值(16位 Unicode 字符 0~65535)参与表达式运算. 字符串常量代表一个地址值(引用字符串常量池中的对象. 不会被垃圾回收) 3. 重载(Overload)和重写(Override) 重载 重写 发生在同一个类中 发生在父子类中 方法名必须相同参数类型、个数、顺序、方法返回值和权限修饰符可以不同 方法名和参数列表必须相同. 权限修饰符范围大于等于父类抛出异常的范围小于等于父类. 返回值返回小于等于父类 4. 封装 继承 多态封装封装把一个对象的属性私有化. 同时提供一些想让外界访问的属性的方法. 继承继承是使用已存在的类的定义作为基础建立新类的技术. 新类的定义中可以增加新的成员变量和成员方法. 且同时拥有父类声明的可以被继承的变量和方法. 多态多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定. 只有在程序运行期间才能确定. 实现多态的方法:继承和接口 5. String StringBuffer 和 StringBuilder可变性StringString类中使用private final char value[]来保存字符串. 所以String对象是不可变的 StringBuilder 与 StringBuffer两者都继承自AbstractStringBuilder类. 该类同样使用char[] value来保存字符串. 但没有用final修饰. 所以这两种对象是可变的 线程安全性StringString中的对象是不可变的. 在字符串常量池中只有一个. 线程安全. StringBuffer 和 StringBuilderAbstractStringBuilder是StringBuilder与StringBuffer的父类. 定义了一系列字符串的基本操作.如expandCapacity, append, insert, indexOf等公共方法. StringBufferStringBuffer对方法加了同步锁或者对调用的方法加了同步锁. 所以是线程安全的 StringBuilderStringBuilder没有加锁. 所以是非线程安全的 性能 String类型每次被改变的时候. 都会在字符串常量池中生成一个新的String对象. 然后将指针指向新的String对象 StringBuffer每次都会对对象本身进行操作. 不会生成新的对象并改变引用. StringBuilder相比StringBuilder性能仅提升10%~15%左右. 但非线程安全. 使用 操作少量数据 =&gt; String 拼接字符串时 =&gt; StringBuilder StringBuffer 单线程操作字符串缓冲区下大量数据 =&gt; StringBuilder 多线程操作字符串缓冲区下大量数据 =&gt; StringBuffer 6. 自动装箱与拆箱装箱将基本类型用他们对应的引用类型包装起来.如:int-&gt;Integer 自动装箱时编译器调用valueOf将原始类型值转换成对象 拆箱将包装类型转换为基本数据类型.如:Integer-&gt;int 同时自动拆箱时，编译器通过调用类似intValue(). doubleValue()这类的方法将对象转换成原始类型值. 发生场景 进行 = 赋值操作（装箱或拆箱） 进行+，-，*，/混合运算 （拆箱） 进行&gt;. &lt;. ==比较运算（拆箱） 调用equals进行比较（装箱） ArrayList. HashMap等集合类 添加基础类型数据时（装箱） 注意事项生成无用对象增加GC压力因为自动装箱会隐式地创建对象.如果在一个循环体中. 会创建无用的中间对象. 这样会增加GC压力. 拉低程序的性能.所以在写循环时一定要注意代码. 避免引入不必要的自动装箱操作. 对象相等比较==可以用于基本类型进行比较. 也可以用于对象进行比较. 当用于对象与对象之间比较时. 比较的不是对象代表的值. 而是检查两个对象是否是同一对象.这个比较过程中没有自动装箱发生.进行对象值比较不应该使用==，而应该使用对象对应的equals方法. public class AutoboxingTest &#123; public static void main(String args[]) &#123; // Example 1: == comparison pure primitive – no autoboxing int i1 = 1; int i2 = 1; System.out.println("i1==i2 : " + (i1 == i2)); // true // Example 2: equality operator mixing object and primitive Integer num1 = 1; // autoboxing int num2 = 1; System.out.println("num1 == num2 : " + (num1 == num2)); // true // Example 3: special case - arises due to autoboxing in Java Integer obj1 = 1; // autoboxing will call Integer.valueOf() Integer obj2 = 1; // same call to Integer.valueOf() will return same // cached Object cache range(-128~127) System.out.println("obj1 == obj2 : " + (obj1 == obj2)); // true // Example 4: equality operator - pure object comparison Integer one = new Integer(1); // no autoboxing Integer anotherOne = new Integer(1); System.out.println("one == anotherOne : " + (one == anotherOne)); // false &#125;&#125;Output:i1==i2 : truenum1 == num2 : trueobj1 == obj2 : trueone == anotherOne : false 缓存的对象在Java中. 会对-128到127的Integer对象进行缓存. 当创建新的Integer对象时. 如果符合这个这个范围. 并且已有存在的相同值的对象. 则返回这个对象 否则创建新的Integer对象. 静态方法内不能调用非静态成员静态方法可以不通过对象进行调用. 因此在静态方法里. 不能调用其他非静态变量. 也不可以访问费静态变量成员. 7. 在 Java 中定义一个空的无参构造方法的作用Java程序在执行子类的构造方法之前. 如果没有用super()来调用父类特定的构造方法. 就会调用父类的无参构造方法.因此. 如果父类中只定义了有参构造方法. 而子类的构造方法中没有用super()来调用父类中特定的构造方法. 则编译时将发生错误. 8. 接口和抽象类的区别 接口 抽象类 方法默认是public. 所有方法都不能有实现且子类必须重写全部方法Java 8开始. 接口提供默认方法default. 子类不需重写 可以有非抽象方法 实例变量必须是public static final类型 可以不是final类型 多继承 单继承 不能用new实例化. 但可以声明. 但是必须引用一个实现该接口的对象接口是行为的抽象. 是一种行为的规范.适合对类的行为抽象 同样不能用new实例化. 但可以声明. 但是必须引用一个继承该类的对象抽象是对类的抽象. 是一种模板设计.适合对事物抽象 为什么接口属性必须是 public static final 接口是一种高度抽象的模板. 而接口中的属性也就是模板成员.就应当是所有实现模板的类的共有特性. 其次. 接口中如果可以定义非final变量的话. 而方法又都是abstract的. 这就会造成有可变成员变量. 但对应的方法却无法操作这些变量.接口是一种更高层面的抽象. 是一种规范. 功能定义的声明. 所有可变的东西都应归属到实现类中. 这样的接口才能起到标准化. 规范化的作用.所以接口中的属性必然是final的 最后, 接口只是对事物的属性和行为更高层次的抽象.对修改关闭. 对扩展开放.接口是对开闭原则的一种体现 接口的静态方法在Java 8中. 接口也可以定义静态方法. 可以直接用接口名调用. 实现类和实现四不可以调用的. 如果同时实现多个接口. 接口中定义了一样的默认方法. 必须重写. 否则会报错. 9. 成员变量和局部变量的区别 成员变量 局部变量 成员变量属于类. 可以用public private static等修饰符修饰 局部变量在方法中定义或是方法的参数. 不能被权限修饰符修饰. 除了 final 非静态时. 随对象存储于堆内存中 随方法存储于栈内存中 没有被赋初值. 则会自动以类型的默认值而赋值 不会被自动赋值 10. == 与 equals==: 判断两个对象的地址是不是相等. 即是不是同一个对象. 都是基本类型时比较的是值是否相等. 都是引用类型时比较的是内存地址是否相等.基本类型和它的封装类型时. 封装类型拆箱为基本类型然后比较值是否相等. equals: 通过方法中定义的方式进行比较.所有类都继承了Object类的equals()方法. 其默认是用==来进行比较两个对象. 如果调用方法的对象重写了此方法. 按重写的方法中的方式进行比较. 11. equals 与 hashCode重写equals时必须重写hashCode方法 hashCode()hashCode()的作用是获取哈希码. 也称为散列码. 返回的是一个 int 整数. 这个哈希码的作用是确定该对象在哈希表中的索引位置. hashCode()定义在 JDK 的 Object.java中. 意味着任何内都包含有hashCode()函数. 散列表存储的是键值对(key-value). 特点是:能根据”键”快速检索出对应的”值”. 这里就会用到散列码. 用来快速定位要查找的对象存储位置. 为什么要有 hashCode当把对象加入 HashSet 时. HashSet会先计算对象的 hashCode 值来判断对象加入的位置, 同时会与其他加入的对象的 hashCode 值作比较, 如果没有相符的 hashCode , HashSet 会假设对象没有重复出现, 如果发现有相同的 hashCode 值的对象, 这时就会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同. 如果两者相同, HashSet 就不会让其加入操作成功. 如果不同, 就会重新散列到其他位置. 这样就大大减少了 equals 的次数, 相应地就大大提高了执行速度. hashCode() 与 equals() 相关规定 如果两个对象相等, 则 hashCode 一定也是相同的 两个对象相等, 调用 equals() 方法是返回一定是 true 两个对象有相同的 hashCode 值, 它们不一定是相等的 因此, equals 方法被重写时, hashCode 也一定要重写覆盖 hashCode 的默认行为是对堆上的对象产生独特值, 如果没有重写 hashCode , 则该 class 的两个对象无论如何都不会相等(即使这两个对象指向相同的数据) 12. 线程 进程 程序 线程 线程与进程类似, 但线程是一个比进程更小的执行单位. 一个进程在其执行过程中可以产生多个线程. 同类的多个线程共享同一块内存和一组系统资源, 所以系统在产生一个线程, 或者在各个线程之间切换工作时, 负担要比进程小得多, 因此, 线程也被称为轻量级进程 进程 进程是程序的一次执行过程,是系统运行程序的基本单位,因此进程是动态的. 系统运行一个程序即使一个进程从创建, 运行到消亡的过程. 一个正在执行的程序就是一个进程, 它在计算机中一个一个指令地执行者, 同时每个进程占有某些系统资源, 如CPU时间, 内存空间, 文件, 输入输出设备的使用权等. 当程序被执行时, 会被操作系统载入到内存中. 线程和进程的最大的不同在于基本上各进程是独立的, 而同一进程中的各线程极有可能会相互影响. 程序 程序是含有指令和数据文件, 被存储在硬盘或其他的数据存储设备中的静态代码 13. 线程的基本状态 Java 线程状态变化如下图 线程在创建之后处于 NEW(新建) 状态, 调用 start() 方法后开始运行后, 线程处于 READY(可运行) 状.可运行状态状态的线程获得了 CPU 时间片(timeslice)后就处于 RUNNING(运行) 状态. 操作系统隐藏 Java 虚拟机(JVM)中的 RUNNABLE 和 RUNNING 状态, 它只能看到 RUNNABLE 状态. 所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态. 当线程执行 wait() 方法之后, 线程进入 WAITING(等待) 状态. 进入等待状态的进程需要依靠其他线程的通知才能返回到运行状态. 而 TIME_WATING(超时等待) 状态相当于在等待状态的基础上增加了超时限制. 比如通过 sleep(long millis) 方法或 wait(long millis) 方法可以将 Java 线程置于 TIME_WATING(超时等待) 状态. 当超时时间到达后, Java 线程会返回到 RUNNABLE 状态. 当线程调用同步(synchronized)方法时, 在没有获取到锁的情况下, 线程将会进入到 BLOCKED(阻塞) 状态. 线程在执行 Runnable 的 run() 方法之后将会进入到 TERMINATED(终止) 状态 14. final static this super 关键字finalfinal 关键字主要作用在三个地方: 变量 方法 类 对于一个 final 变量, 如果是基本类型的变量, 则其一旦在初始化之后便不能修改. 如果是引用类型的变量, 则在对其进行初始化之后便不能在让其指向另一个对象. 当用 final 修饰一个类时, 表明这个类不能被继承. final 类中的所有成员方法都会被隐式地指定为 final 方法. 使用 final 方法的原因是: 把方法锁定, 以防任何继承类修改它的含义. staticstatic 关键字主要有以下四种使用场景: 修饰成员变量和成员方法: 被 static 修饰的成员属于类, 不属于单个这个类的某个对象, 被该类的所有对象共享, 建议通过类名调用. 被 static 声明的成员变量属于静态变量. 静态变量存放在 Java 内存区域的方法区. 调用格式: 类名.静态变量名 类名.静态方法名() 方法区与 java 堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据. 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分, 但是它却有一个别名叫做 Non-Heap(非堆), 目的应该是与 Java 堆区分开来 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法). 该类不管创建多少对象, 静态代码只执行一次. &gt; static&#123;&gt; 静态代码块;&gt; &#125;&gt; 一个类的静态代码块可以有多个, 位置任意. 它不处于任何方法体内, JVM 加载类时会执行这些静态的代码块, 如果静态代码块有多个, JVM 将按照他们在类中出现的先后顺序依次执行它们. 静态代码块对于定义在它之后的静态变量, 可以赋值, 但是不能访问. 静态内部类(static 修饰类的话只能修饰内部类): 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后隐含地保存着一个引用, 该引用是指向创建它的外围类(外围类名.this), 但是静态内部类却没有. 静态内部类的创建是不需要依赖外围类的创建. 它不能够使用外围类的非 static 成员变量和方法. 静态内部类实现单例模式 public class Singleton &#123; // 声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时, 静态内部类 SingletonHolder 没有被加载进内存. 只有当调用 getUniqueInstance() 方法而触发 Singleton.INSTANCE 时 SingletonHolder 才会被加载, 此时初始化 INSTANCE 实例, 并且 JVM 能确保该实例只被实例化一次. 静态导包(用来导入类中的静态资源): 格式为: import static 这两个关键字连用可以导入某个类中的指定静态资源, 并且不需要使用类名调用类中的静态成员, 可以直接使用类中静态变量和成员方法. // Math. --- 将Math中的所有静态资源导入, 这时候可以直接使用里面的静态方法, 而不用通过类名进行调用// 如果只想导入单一某个静态方法，只需要将换成对应的方法名即可import static java.lang.Math.;// 换成import static java.lang.Math.max;具有一样的效果 public class Demo &#123; public static void main(String[] args) &#123; int max = max(1,2); System.out.println(max); &#125;&#125; static{} 静态代码块与 {} 非静态代码块(构造代码块)相同点: 都是在 JVM 加载类时且在构造方法执行之前执行, 在类中都可以定义多个, 定义多个时按定义的顺序执行, 一般在代码块中对一些 static 变量进行赋值. 不同点: 静态代码块在非静态代码块之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法). 静态代码块只在第一次 new 执行一次, 之后不再执行. 而非静态代码块在每 new 一次就执行一次. 非静态代码块可以在普通方法中定义, 而静态代码块不行. 非静态代码块与构造函数的区别是: 非静态代码块是给所有对象进行统一初始化, 而构造函数是给对应的对象初始化, 因为构造函数可以是多个的, 运行哪个构造函数就会建立什么样的对象 而无论建立哪个对象, 都会先执行相同的构造代码块. 也就是说, 构造代码块中定义的是不同对象共性的初始化内容. thisthis 关键字用于引用类的当前实例, 如: class Manager &#123; Employees[] employees; void manageEmployees() &#123; int totalEmp = this.employees.length; System.out.println("Total employees: " + totalEmp); this.report(); &#125; void report() &#123; &#125;&#125; 在以上示例中, this 关键字用于两个地方: this.employees.length: 访问 Manager 类的当前实例的变量 this.report(): 调用 Manager 类的当前实例的方法 supersuper 关键字用于从子类访问父类的变量和方法. super.方法名(): 调用父类的非 private 方法 super(): 调用父类的构造方法 super.变量名: 操作父类的非 private 变量 使用 this 和 super 要注意的问题: super 调用父类中的其他构造方法时, 要放在构造方法的首行. this 调用本类中的其他构造方法时, 也要放在首行 this, super 不能用在 static 方法中 被 static 修饰的成员属于类, 不属于单个这个类的某个对象, 被类中所有对象共享. 而 this 代表对父类的引用, 指向父类对象. 所以, this 和 super 是属于对象范畴的东西, 而静态方法是属于类范畴的东西 15. Java 中的异常处理Java 异常类层次结构图 在 Java 中, 所有的异常都有一个共同的祖先 java.lang.Throwable类. Throwable有两个重要的子类:Exception(异常)和Error(错误). 二者都是 Java 异常处理的重要子类, 各自都包含大量的子类. Error: 是程序无法处理的错误, 表示运行程序中较严重的问题. 大多数错误是 JVM 出现的问题. 如: Java虚拟机运行错误(VritualMachineError), 当 JVM 没有足够的内存资源执行操作时, 将出现 OutOfMemoryError . 这些异常发生时, JVM 一般会选择线程终止. 这些错误表示故障发生于虚拟机自身, 或者发生在虚拟机试图执行应用时. 这些错误是不可查的, 错误通过 Error 的子类描述. Exception: 是程序本身可以处理的异常. Exception 类有一个重要的子类: RuntimeException. 该类异常由虚拟机抛出, 线程不会被终止. NullPointerException: 访问的变量没有任何引用对象时, 抛出该异常. ArithmeticException: 算数运算异常, 整数除以 0 时, 抛出该异常. ArrayIndexOutOfBoundsException: 数组下标越界时, 抛出该异常. Throwable 类常用方法 public String getMessage(): 返回异常发生时的详细信息. public String toString(): 返回异常发生时的简要描述. public String getLocalizedMessage(): 返回异常对象的本地化信息. 使用 Throwable 的子类覆盖这个方法, 可以生成本地化信息. 如果子类没有覆盖该方法, 则该方法返回的信息与 getMessage() 返回的结果相同. public void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息. 异常处理try catch try: 用于捕获异常. 其后可接任意个 catch 块. 如果没有 catch 块, 则必须跟一个 finally 块 catch: 用于处理 try 捕获到的异常. 越具体的类必须越先捕获处理. finally: 无论是否捕获或处理异常, 块中的语句都会被执行. 当在 try 块或 catch 块中遇到 return 或 throw 语句时, finally 语句块将在方法返回之前执行. 以下 4 种特殊情况下, finally块不会被执行: 在 finally 语句块中第一行发生了异常. 如果在其他行发生异常, 之前行的代码仍会执行. 在前面的代码中使用了 System.exit(int) 退出虚拟机. 程序所在的线程死亡 当所有的非守护线程中止时, 不论存不存在守护线程, 虚拟机都会kill掉守护线程从而中止程序. 所以, 如果守护线程中存在 finally 代码块, 那么当所有的非守护线程中止时, 守护线程被 kill 掉, 其 finally 代码块是不会执行的. 关闭 CPU 关于返回值: 如果 try 于中中有 return , 返回的是 try 语句块中的变量值. 详细过程如下: 如果有返回值, 就把返回值保存到局部变量中 执行 jsr 指令跳转到 finally 语句中执行 执行完 finally 语句后, 返回之前保存在局部变量中的值 如果 try , finally 块中均有 return , 则忽略 try 中的 return , 而使用 finally 中的 return throw使用 throw 语句抛出异常, 在方法上声明 , 交由调用方法的对象来处理. 16. 序列化 Java 序列化技术是将对象编码成字节流. 反之, 将字节流重新构建成对象, 称之为反序列化. 实现对象的持久化. 实现借助 common-lang 工具类 import org.apache.commons.lang3.SerializationUtils;public class Test &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Java"); user.setAddress("China"); byte[] bytes = SerializationUtils.serialize(user); User u = SerializationUtils.deserialize(bytes); System.out.println(u); &#125;&#125; 注意事项: 序列化对象必须实现序列化接口. 序列化对象里面的属性是对象的话也要实现序列化接口. 类的对象序列化后, 类的序列化 ID 不能轻易修改, 不然反序列化会失败. 类的对象序列化后, 类的属性有增加或者删除不会影响序列化, 只是值会丢失. 如果父类序列化了, 子类会继承父类的序列化, 子类无需添加序列化接口. 如果父类没有序列化, 子类序列化了, 子类中的属性能正常序列化, 但父类的属性会丢失, 不能序列化. 用 Java 序列化的二进制字节数据只能由 Java 反序列化, 不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成 Json/Xml 通用格式的数据, 再恢复原来的对象. 如果某个字段不想序列化, 在该字段前加上 transient 关键字即可 17. 反射 Java 反射机制在程序运行时, 对于任意一个类, 都能够知道这个类的所有属性和方法. 对于任意一个对象, 都鞥能够调用它的任意一个方法和属性. 这种动态调用对象的方法的功能, 称为 Java 的反射机制 反射机制很重要的一点就是”运行时”. 其使得我们可以在程序运行时加载, 探索以及使用编译期间完全未知的 .class文件. 也就是说, Java 程序可以在一个运行时才得知名称的 .class 文件, 然后获悉其完整构造, 并生成对象实体, 或对其变量 field 进行操作, 或调用其方法 method. 获取Class类的三种方法: 类名.class 对象名.getClass() Class.forName(“要加载的类名”) 主要方法 Class.getName(): 获取类的名称 Class.getFields(): 获取当前类及其所继承的父类的 public 变量 Class.getDeclaredFields(): 获取当前类的所有成员变量, 不论访问权限 Class.getMethods(): 获取当前类及其所继承的父类的 public 方法 Class.getDeclaredMethods(): 获取当前类的所有成员方法, 不论访问权限 Method.setAccessible(true): 获取当前方法的访问权限, 操作私有方法时必须设置, 否则会报异常 IllegalAccessException Field.setAccessible(true): 获取当前变量的访问权限, 操作私有方法时必须设置, 否则会报异常 IllegalAccessException Method.invoke(): 调用当前方法 Field.set(): 修改当前变量的值 修改常量的特殊情况使用 static final 修饰的常量值, 在 JVM 编译时, 会在常量被使用的地方将常量名直接替换为常量值来优化代码. 而有些数据类型不会被优化. 要想避免上面出现的特殊情况, 有两种方法来修改常量的值 方法一: public class TestClass &#123; //...... private final String FINAL_VALUE; //构造函数内为常量赋值 public TestClass()&#123; this.FINAL_VALUE = "FINAL"; &#125; //......&#125; 输出: Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = Modified 解释: 将赋值放在构造函数中, 构造函数只有在 new 对象时才会调用, 所以不会在编译阶段被直接优化为常量值, 而是指向常量名. 这样就可以在运行阶段来通过反射修改常量 方法二: 将声明常量的语句改为使用三目表达式赋值: private final String FINAL_VALUE = null == null ? "FINAL" : null; 因为 null == null ? &quot;FINAL&quot; : null 是在运行时刻计算的, 在编译时刻不会计算, 也就不会被优化. 判断是否能修改]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS跨域资源共享]]></title>
    <url>%2F2019%2F03%2F09%2FJavaLearning%2FWeb%2FCORS%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[简介 跨域资源共享(CORS)标准新增了一组 HTTP 首部字段,允许服务器声明哪些源站有权限访问哪些资源.另外,规范要求,对那些可能对服务器数据产生副作用的HTTP 请求方法(特别是 GET 以外的 HTTP 请求,或者搭配某些 MIME 类型的 POST 请求),浏览器必须首先使用 OPTIONS 方法发起一个预检请求(preflight request),从而获知服务端是否允许该跨域请求.服务器确认允许之后,才发起实际的 HTTP 请求.在预检请求的返回中,服务器端也可以通知客户端,是否需要携带身份凭证(包括 Cookies 和 HTTP 认证相关数据). 两种请求浏览器将CORS请求分成两类:简单请求和非简单请求 只要满足一下两个条件,就属于简单请求: 请求方法是以下三种方法之一: HEAD GET POST HTTP的header信息不超出以下几种字段 Accept Accept-Language Content-Language Last-Event-ID Content-Type只限于:application/x-www-form-urlencoded,multipart/form-data,text/plain 不满足以上条件的就属于非简单请求 简单请求对于简单请求,浏览器直接发出CORS请求.在RequestHeader中添加Origin字段 Origin字段用来说明本次请求的请求源(协议+域名+端口).服务器根据这个值决定是否同意这次请求 如果Origin指定的请求源不在许可范围内,服务器会返回一个正常的HTTP回应.这个响应的header信息中没有包含Access-Control-Allow-Origin字段,浏览器发现后就知道出错.从而抛出一个,然后被XMLHttpRequest的onerror`回调函数捕获. 这种错误无法通过状态码识别,因为是一个正常的HTTP回应 如果Origin指定的域名在许可范围内,服务器返回的响应会多出几个字段. Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 以Access-Control-的字段与CORS请求相关 Access-Control-Allow-Origin 该字段是必须的.它的值是请求时Origin字段的值,或者为*表示接受任意域名的请求. Access-Control-Allow-Credentials 该字段可选,它的值是一个布尔值,表示是否允许发送Cookies.默认情况下,Cookies不包括在CORS请求之中.设置为true则Cookie可以包含在请求中,一起发送给服务器.如果服务器不要浏览器发送 Cookie,删除该字段即可. Cookie中携带有Session Id相关信息,所以在请求一些需要得到Session进行身份验证的服务时,需要加上这个字段设置为true.比如:登录操作. 而客户端也需要在Ajax请求中打开withCredentials属性. &gt; xhrFields: &#123;&gt; withCredentials: true&gt; &#125;,&gt; crossDomain: true&gt; 注意:如果要发送Cookie,Access-Control-Allow-Origin就不能为*.必须明确指定与网页一致的域名.Cookie也遵循同源策略,只有用服务器域名设置的Cookie才会上传,其他域名的Cookie不会上传.(防止了伪造Cookie的攻击手段) Access-Control-Expose-Headers 该字段可选.CORS请求时,XMLHTTPRequest对象的getResponseHeader()方法只能拿到6个基本字段:Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma.如果想要拿到其他的字段,就需要在此字段中指定.上面的例子中指定,getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值 非简单请求预检请求非简单请求是对服务器有特殊要求的请求,如请求方法为PUT或DELETE,或者Content-Type字段的类型是application/json 非简单请求的CORS请求,会在正式通信之前,增加一次HTTP查询请求,即预检请求. 浏览器查询服务器,当前网页所在的域名是否在服务器的许可名单之中,以及可以使用哪些HTTP动词和头信息字段.只有在得到肯定答复后,浏览器才会发出正式的XMLHttpRequest请求,否则就报错 var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面构造了一个非简单请求.请求方法是PUT,并且发送一个自定义字段X-Custom-Header 浏览器就会自动发出一个预检请求.确认服务器是否接受这样的请求.预检请求的HTTP头信息如下 OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 预检请求的请求方法是OPTIONS,表示这个请求是用来查询的.头信息里,关键字段是Origin,表示请求源 Access-Control-Request-Method 该字段是必须的,用来列出浏览器的CORS请求会用到哪些HTTP方法,这里是PUT Access-Control-Request-Headers 该字段可以有多个值,用,分隔.指定浏览器CORS请求会额外发送的头信息字段,这里是X-Custom-Header 预检请求的回应服务器收到预检请求后,检查Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后,确认是否允许跨域请求,并作出回应 HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中,关键的是Access-Control-Allow-Origin字段,表示http://api.bob.com可以请求数据.如果为*表示接受任意域名的跨域请求. 如果服务器否定了预检请求,会返回一个正常的HTTP回应,但是没有任何CORS相关的头信息字段.这是浏览器会认为服务器不同意预检请求,便会出发一个错误,被XMLHttpRequest对象的onerror回调函数捕获.控制台会打印出如下的报错信息:XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. Access-Control-Allow-Methods 该字段必须,可以有多个值,用,分隔.表明服务器支持的所有跨域请求的方法.返回所有是为了避免多次预检请求. Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段,则Access-Control-Allow-Headers字段是必须的.也可以由多个值,用,分隔.表明服务器至支持的所有头信息字段,不限于浏览器在预检请求中请求的字段. Access-Control-Allow-Credentials 同简单请求. Access-Control-Max-Age 该字段可选.用来指定本次预检请求的有效期,单位为秒.在有效期内,不用发出另一条预检请求. 服务器正常请求和回应一旦服务器通过了预检请求,以后每次浏览器正常的CORS请求就会和简单请求一样,会有一个Origin头信息字段,服务器的回应也会有一个Access-Control-Allow-Origin头信息字段.]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CROS</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux线上环境搭建]]></title>
    <url>%2F2019%2F03%2F05%2FJavaLearning%2FTools%2FServerSetting%2F</url>
    <content type="text"><![CDATA[服务器环境搭建 Java安装 到官网下载jdk. 解压到tar -zxvf jdk_8u_201 -C /usr/java 编辑环境变量vim /etc/profile,使环境变量生效source /etc/profile export CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$GIT_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$JRE_HOME/bin: 检查是否安装成功:java -version Mysql安装1T/e&gt;dle=reo 到官网Yum仓库下载rpm包. rpm -ivh &lt;文件名&gt;或者yum localinstall &lt;文件名&gt;安装刚才下载好的包 此时便可以通过yum安装最新的mysql.使用指令yum install mysql-community-server安装 配置 启动mysql:service mysqld start 关闭mysql:service mysqld stop 查看mysql提供的初始root密码:cat /var/log/mysqld.log | grep password 登录mysql,若出现提示Access denied for user &#39;root&#39;@&#39;localhost&#39;,可能是密码错了.否则百度 修改root密码:ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;vnaso943983&#39;; 如果不想使用强密码,需要先降低密码策略等级: SET GLOBAL validate_password.policy=0; 创建用户CREATE USER &#39;vnaso&#39;@&#39;%&#39; IDENTIFIED BY &#39;vnaso222&#39;;,并授权:GRANT ALL ON *.* TO &#39;vnaso&#39;@&#39;%&#39; WITH GRANT OPTION; 修改默认字符集.打开/etc/my.cnf,添加如下配置 # 对本地的mysql客户端的配置[client]default-character-set = utf8mb4# 对其他远程连接的mysql客户端的配置[mysql]default-character-set = utf8mb4# 本地mysql服务的配置[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ci 查看字符集:SHOW VARIABLES WHERE Variable_name LIKE &#39;character\_set\_%&#39; OR Variable_name LIKE &#39;collation%&#39;; 查看时区:show variables like &#39;%zone%&#39;; 修改时区为UTC:set time_zone = &#39;utc&#39;;flush privileges;修改时区并刷新. 如果报错Unknown or incorrect time zone: &#39;UTC&#39;,在shell执行:mysql_tzinfo_to_sql /usr/share/zoneinfo |mysql -u root mysql -p,有warning提示Unable to load xxx是正常的. 如果修改了之后,再次查询还是System,修改配置文件/etc/my.cnf,在[mysqld]下添加default-time-zone = UTC Git安装 到官网获取下载链接.wget &lt;url&gt;下载 使用tar -zxvf &lt;文件名&gt;解压缩. 安装git前置依赖:yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker 进入git安装目录下,进行安装:./configure --prefix=/usr/local/git-&gt;make &amp;&amp; make install 如果报错no such file or directory.使用:yum install autoconf然后在目录中键入autoconf,再次进行安装即可. 添加环境变量.vim /etc/profile,使环境变量生效source /etc/profile 检查是否安装成功git --version 配置 生成私钥:ssh-keygen -t rsa -C &quot;XXX@outlook.com&quot;密钥名称可自定义 告知系统来管理生成的密钥:ssh-add ~/.ssh/id_rsa 如果报错could not open a connection to your authentication agent 执行命令:eval ssh-agent(是~,而不是单引号).然后再执行:ssh-add ~/.ssh/id_rsa 在远程服务器中添加公钥:cat ~/.ssh/id_rsa.pub Nginx安装 到官网下载压缩包,解压. 安装nginx编译文件及库文件yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel pcre pcre-devel 进入解压后的目录进行安装:./configure --prefix=/usr/local/nginx-&gt;make &amp;&amp; make install 测试:/usr/local/sbin/nginx -t 配置参考Nginx配置文件说明 Tomcat安装 到官网下载压缩包,解压.一般选择core就行 防火墙打开8080端口,启动tomcat:$CATALINA_HOME/bin/startup.sh 测试:访问&lt;服务器地址&gt;:8080 配置 修改默认编码.vim /opt/Develop/apache-tomcat-9.0.16/conf/server.xml.搜索8080,在&lt;Connector&gt;节点中添加URIEncoding=&quot;UTF-8&quot; 编辑环境变量.vim /etc/profile,添加export CATALINA_HOME = /opt/apache-tomcat-9.0.1.然后source /etc/profile使配置生效 Maven安装 到官网下载压缩包,解压. 添加环境变量:vim /etc/profile,添加export $MAVEN_HOME=....并将$MAVEN_HOME/bin添加到$PATH中 source /etc/profile使配置生效 测试:mvn -v Vstpd安装 下载安装:yum install vstpd 创建接收上传文件的文件夹:mkdir /ftpfile 创建只有上传权限不能登录的用户:useradd ftpuser -d /ftpfile/ -s /sbin/nologin 给创建的ftpuser此用户赋予/ftpfile的权限:chown -R ftpuser.ftpuser /ftpfile/.此时用户名和用户组都是ftpuser 给ftpuser设置密码:passwd ftpuser 编辑配置文件,让上传目录指向之前创建的目录:vim /etc/vsftpd/vsftpd.conf 搜索banner节点,此处配置ftp的欢迎信息.ftpd_banner=xxxxx 可以选择添加use_localtime=yes表示使用服务器时间 添加anonymous_enable=NO关闭匿名用户访问 配置FTP被动模式的端口 pasv_min_port=30000pasv_max_port=30000 ftp配置 # 修改为NO，关闭匿名用户访问anonymous_enable=NO# 将所有本地用户限制在自家目录中。chroot_local_user=YES # 设置系统用户FTP主目录local_root=/data# 开启charoot写权限allow_writeable_chroot=YES#配置可以登录ftp的用户目录userlist_deny=NOuserlist_file=/etc/vsftpd/user_list#配置ftp用户访问目录配置目录user_config_dir=/etc/vsftpd/userconfig# 配置FTP被动模式的端口pasv_min_port=30000pasv_max_port=30000 配置ftp用户登录后访问的目录 在/etc/vsftpd目录下新建userconfig目录 在目录下配置用户的登录目录,文件名即对应的用户名 vim /etc/vsftpd/userconfig/ftpuser 在创建的文件中添加local_root=/ftpfile/ftpuser /ftpfile表示对应用户登录ftp时的根目录 注意:路径前不能有空格,否则不识别!!!!会报错unrecognised variable in config file: local_root 重启vsftpd 启动:systemctl start vsftpd.service(service vsftpd start) 停止:systemctl stop vsftpd.service(service vsftpd stop) 重启:systemctl restart vsftpd.service(service vsftpd restart) 打开防火墙,添加21端口和30000端口. 添加端口:firewall-cmd --add-port=21/tcp --permanent,firewall-cmd --add-port=21/tcp --permanent 重启防火墙:firewall-cmd --reload 测试.浏览器打开ftp://服务器地址登录.如果只能下载不能上传,请查阅开启关闭SELinux相关信息 swap交换缓存创建 创建swap文件:sudo fallocate -l 4G /swapfile(在/下创建一个大小为4G的文件swapfile) 授权swap文件:chmod 600 /swapfile(该文件的读写只能root操作) 告知系统将文件用于swap:mkswap /swapfile 启用swap文件:swapon /swapfile 确认:free 至此已经在系统中启用了swap交换缓存,但是一旦系统重启后,服务器还不能自动启用该文件. 使swap永久生效 打开文件nano /etc/fstab,在文件末尾添加/swapfile swap swap sw 0 0 ^X表示Ctrl + X,按下选择yes保存退出. 环境变量配置在腾讯云服务器中的配置 export CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$GIT_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$JRE_HOME/bin:export GIT_HOME=/usr/local/gitexport MAVEN_HOME=/opt/Develop/apache-maven-3.6.0export JAVA_HOME=/usr/java/jdk1.8.0_201export JRE_HOME=/usr/java/jdk1.8.0_201/jreexport CATALINA_HOME=/opt/Develop/apache-tomcat-9.0.16]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2019%2F03%2F04%2FJavaLearning%2FTools%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux学习笔记系统命令tar解压解压到指定目录:tar -zxvf &lt;要解压的文件&gt; -C &lt;目的路径&gt; tar 命令参数 -x或–extract或–get:从备份文件中还原文件 -Z或–compress或–uncompress:通过compress指令处理备份文件 -f&lt;备份文件&gt;或–file=&lt;备份文件&gt;:指定备份文件 -v:显示操作过程 -C &lt;目录&gt;:这个选项用在解压缩,若要在特定目录解压缩,可以使用这个选项 防火墙(使用firewalld)开启关闭重启:service firewalld start/stop/restart 查看运行状态:service firewalld status/sudo firewall-cmd --state 查看防火墙开放的端口:sudo firewall-cmd --list-ports 删除端口:firewall-cmd --zone=&lt;分区名&gt; --remove-port=&lt;端口号&gt;/&lt;通讯协议&gt; --permanent 为防火墙添加端口:sudo firewall-cmd --zone=&lt;分区名&gt; --add-port=&lt;端口号&gt;/&lt;通讯协议&gt; --permanent(永久生效) 防火墙分为多个区域,可用sudo firewall-cmd --get-zones查看,默认是public 软件安装查看软件是否安装rom -qa | grep &lt;软件名&gt; 下载安装软件yum install &lt;软件名1,2,3...&gt;/yum -y install &lt;软件名1,2,3...&gt; 安装rpm软件包:rpm -ivh &lt;软件包名&gt; rpm 命令参数 -i:安装过程中显示正在安装的文件信息 -h:安装过程中显示安装进度 服务进程查看服务进程:ps -ef| grep &lt;进程名&gt; 修改权限为文件添加可执行权限:chmod +x file.name,可以用通配符*.后缀名 查看文件查看文件最后n行:tail -n &lt;行数&gt; &lt;文件名&gt; 动态查看文件最后n行:tail -n &lt;行数&gt; -f &lt;文件名&gt;,使用ctrl+c来结束 创建文件创建指定大小文件:fallocate -l &lt;文件大小&gt; &lt;文件名&gt; 例:sudo fallocate -l 4G /swapfile(在/下创建一个大小为4G的文件swapfile) 查看系统状态查看内存使用情况:free free 命令参数 -m:以MB为单位显示.默认单位为KB.向下取整 用户操作创建用户:useradd 用户名或adduser 用户名.后者创建的用户会自动创建主目录,系统shell版本和创建时输入密码,而前者没有. 修改用户密码:passwd 用户名 删除用户:userdel 用户名 vim 搜索 在normal模式下按下/即可进入查找模式,输入要查找的字符串并按下回车.Vim会跳转到第一个匹配.按下n查找下一个,按下N查找上一个. 注意查找回车应当用\n,替换回车应当用\r vim默认采用大小写敏感.在查找模式中加入\c表示大小写不敏感,\C敏感.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx学习笔记]]></title>
    <url>%2F2019%2F03%2F04%2FJavaLearning%2FTools%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx使用Nginx配置 在···/nginx/conf目录下的nginx.conf # 全局块... # events块events &#123; ...&#125;# http块http &#123; # http全局块 ... # 虚拟主机server块 server &#123; # server全局块 ... # location块 location [PATTERN] &#123; ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; # http全局块 ... &#125; 全局块 配置影响nginx全局的指令.一般有运行nginx服务器的用户组,nginx进程pid存放路径,日志存放路径,配置文件引入,允许生成worker process数等. ########### 每个指令必须有分号结束。##################user administrator administrators; #配置用户或者组，默认为nobody nobody。#worker_processes 2; #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg events块 配置影响nginx服务器或与用户的网络连接.有每个进程的最大连接数,选取哪种事件驱动模型处理连接请求,是否允许同时接受多个网路连接,开启多个网络连接序列化等. events &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off #use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport worker_connections 1024; #每个worker process最大连接数&#125; http块 可以嵌套多个server,配置代理,缓存,日志定义等绝大多数功能和第三方模块的配置.如文件引入,mime-type定义,日志自定义,是否使用sendfile传输文件,连接超时时间,单连接请求数等. http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #access_log off; #取消服务日志 log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式 access_log log/access.log myFormat; #combined为日志格式的默认值 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 # 定义常量 # 负载均衡,按权重或规则将请求转发到某个服务器 upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 &#125; error_page 404 https://www.baidu.com; #请求失败时跳转的错误页 server块 配置虚拟主机的相关参数,一个http中可以有多个server. 并且可以过滤有人恶意将某些域名指向自己的主机服务器. #定义某个负载均衡服务器 server &#123; keepalive_requests 120; #单连接请求上限次数。 listen 4545; #监听端口 server_name 127.0.0.1; #监听地址 &#125; server_name server_name是监听你的HTTP请求头中的host. 默认情况下，Nginx 允许直接以 IP 的方式就能直接访问到网站，或者通过未设置的域名访问(比如有人把他自己的域名指向了你的服务器 IP),可通过如下设置进行防护 例如: &gt; server &#123;&gt; listen 80 default_server;&gt; server_name _;&gt; return 444; # 过滤其他域名的请求，返回444状态码&gt; &#125;&gt; server &#123;&gt; listen 80;&gt; server_name www.aaa.com; # www.aaa.com域名&gt; location / &#123;&gt; proxy_pass http://localhost:8080; # 对应端口号8080&gt; &#125;&gt; &#125;&gt; server &#123;&gt; listen 80;&gt; server_name www.bbb.com; # www.bbb.com域名&gt; location / &#123;&gt; proxy_pass http://localhost:8081; # 对应端口号8081&gt; &#125;&gt; &#125;&gt; server_name的值为www.aaa.com.在浏览器中输入www.aaa.com,那么匹配到了对应server_name,请求就会被转发到http://localhost:8080.这里www.aaa.com和www.bbb.com都绑定到了服务器 而对于未绑定的域名指向服务器时,匹配不到配置的虚拟主机域名,就会使用默认的虚拟主机,然会返回444. listen 80 default_server:指定该server配置段为80端口的默认主机，即对于未绑定的域名指向你的服务器时,匹配不到你配置的虚拟主机域名后,会默认使用这个虚拟主机 server_name _:此处的_可以换成任意其他无效字符或无效的域名,表示该server配置不会被正常访问到 access_log:日志 格式:access_log logs/aaa.access.log main-日志类型 日志存放路径 日志格式 location块详细参考-知否 详细参考-本地 nginx跨域代理的一些设置 配置请求的路由,以及各种页面的处理情况 location ~*^.+$ &#123; #请求的url过滤,正则匹配 #root path; #根目录 #index vv.txt; #设置默认页 proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip &#125; 通配符 =表示精确匹配.只有请求的url路径与后面的字符串完全相等时,才会命中 ~表示该规则是使用正则定义的,区分大小写 ~*表示该规则是使用正则定义的,不区分大小写 ^~表示如果该符号后面的字符是最佳匹配,采用该规则,不再进行后续的查找 属性解释 root表示url匹配上了此location定义的正则后,就将这个url映射到定义的根目录. 例如 location /user/img,root /usr/local/resource;. 那么如果请求为http://www.aaa.com/user/img/aaa.jpg,/user/img对应/usr/local/resource.该请求得到的结果就是/usr/local/resource下的aaa.jpg index就是设置默认的欢迎页面.页面需要存在于定义的root目录下. 接上例index index.html;. 那么如果请求为http://www.aaa.com/user/img/,请求的结果就是/usr/local/resource/user/img下的index.html,有点类似于相对路径.而如果要让index.html为/usr/local/resource/路径下的index.html的话,需要把root换为alias,具体参照root和alias的区别. 注意unknown directive所有关键词后都必须加一个空格,否则会报错unknown directive xxx Linux下命令 在···/nginx/sbin/目录下 启动nginx:nginx -s start 停止nginx:nginx -s stop 重启nginx:nginx -s reload 测试配置:nginx -t Nginx日志目录 在···/nginx/logs/目录下 目录下通常存放有access.log,error.log以及nginx.pid. nginx.pid中保存着nginx的进程号,可以通过查看此文件获取进程号来kill nginx. root和alias的区别root 示例1location / &#123; root /data/www/; index index.html;&#125; 请求http://example.com这个地址,那么在服务器中真实对应的地址为/data/www/index.html 请求 真实地址 http://example.com /data/www/index.html http://example.com/a.png /data/www/a.png root 示例2location /aaa/ &#123; root /data/www/; index index.html;&#125; 请求 真实地址 http://example.com/aaa/ /data/www/aaa/indexhtml http://example.com/aaa/a.gif /data/www/aaa/a.gif alias 示例1location /&#123; alias /data/www/; index index.html;&#125; 请求 真实地址 http://example.com /data/www/index.html http://example.com/b.jpg /data/www/a.jpg alias 示例2location /bbb/&#123; alias /data/www/; index index.html;&#125; 请求 真实地址 http://example.com/bbb/ /data/www/index.html http://example.com/bbb/b.jpg /data/www/b.jpg 对比上面4个示例可以发现,使用root的真实地址是root+location+(文件名),而使用alias的真实地址是alias+(文件名). 注意 alias只能作用在location中,而root可以存在server,http,location. alias后面必须要用/结束. Nginx实现解决前后端分离的跨域问题参考 在前端使用ajax向从后端获取数据发送跨域请求,由于浏览器的同源策略限制,会报403错误. 同源策略 同源是指”协议+域名+端口”三者相同,即便两个不同的域名指向同一个ip地址,也非同源 同源策略限制行为 Cookie,LocalStorage和IndexDB无法读取 DOM和JS对象无法获得 Ajax请求不能发送 常见的跨域场景 URL 说明 是否允许通信 http://www.domain.com/a.jshttp://www.domain.com/b.jshttp://www.domain.com/lab/c.js 同一域名,不同文件或路径 允许 http://www.domain.com:8000/a.js http://www.domain.com/b.js 同一域名,不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名,不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.jshttp://domain.com/c.js 主域相同,子域不同 不允许(cookie这种情况下也不允许访问) http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案Nginx代理跨域 一种比较简单的解决方案,无需动后端代码 Nginx配置server &#123; listen 80; server_name vnaso.live; location / &#123; if ($http_origin ~* (http://vnaso\.live$) ) &#123; add_header Access-Control-Allow-Origin '$http_origin'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; add_header 'Access-Control-Allow-Credentials' 'true'; &#125; if ($http_origin ~* (http://127.0.0.1:8080$) ) &#123; add_header Access-Control-Allow-Origin '$http_origin'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; add_header 'Access-Control-Allow-Credentials' 'true'; &#125; proxy_pass http://127.0.0.1:8080/; #proxy_cookie_path / /; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Cookie $http_cookie; root /opt/Develop/apache-tomcat-9.0.16/webapps/ROOT/; # index index.html; &#125;&#125; if语句来决定匹配跨域请求,并为这些请求添加RequestHeader,上面配置的add_header Access-Control-Allow-Origin:服务器默认是不允许跨域的,这里可以添加接受跨域的请求源(origin). Access-Control-Allow-Methods:设置允许接收哪些方法的跨域请求 Access-Control-Allow-Headers:不添加此属性会报错:Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.原因是当前的Content-Type不被支持.详情看下方的预检请求. proxy_pass:表示将匹配的请求转发到该url下 proxy_set_header:为转发的请求添加RequestHeader 相关知识CORS]]></content>
      <categories>
        <category>Tool</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logback学习笔记]]></title>
    <url>%2F2019%2F02%2F15%2FJavaLearning%2FTools%2Flogback%2F</url>
    <content type="text"><![CDATA[Logback使用标签属性介绍根标签 - configuration属性 scan:布尔值.表示是否自动扫描logback.xml的文本变化. scanPeriod:字符串.表示每间隔多长时间对logback.xml进行扫描.格式:数字 + 时间单位(如:seconds,minutes) debug:布尔值.表示是否打印logback内部的日志信息. 常用配置为:&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;&lt;/configuration&gt; 表示自动每60秒扫描一次logback.xml的配置有无变化,如果有就更新,且不打印logback的内部日志.这样可以热更新logback配置文件 子标签 &lt;property&gt;:定义参数常量 &lt;appender: &lt;root&gt;: configuration - property属性 name:变量名 value:变量值 常用来设置一些配置文件中需要使用的常量值,如默认日志等级,最大保存天数,日志存储位置等. configuration - appender属性 name:变量名 class:具体的实现类的全限定类名 用来定义日志的输出源的配置 class的取值一般有两个:ch.qos.logback.core.ConsoleAppender和ch.qos.logback.core.rolling.RollingFileAppender 前者的功能是在输出到控制台,后者功能可以按时间分卷输出到文件 子标签 &lt;encoder&gt;:把日志转为字符串并将其输出到文件中 &lt;encoding&gt;:编码方式 &lt;filter&gt;:过滤器 &lt;file&gt;:日志文件输出储存位置 &lt;rollingPolicy&gt;:分卷模式 configuration - appender - encoder子标签 &lt;pattern&gt;:日志格式 configuration - appender - rollingPolicy属性 class:分卷模式的全限定类名 &lt;append&gt;:布尔值.日志被追加到文件结尾.如果是false,清空现存文件,默认是true 用来定义日志的分卷模式 class常用的类是ch.qos.logback.core.rolling.TimeBasedRollingPolicy 可以按照时间进行分卷 子标签 &lt;filenamePattern&gt;:分卷日志文件名格式 &lt;MaxHistory&gt;:日志最大保存天数 configuration - appender - filter属性 class:实现过滤规则的类的全限定类名 子标签 &lt;level&gt;:要进行过滤的级别 &lt;onMatch&gt;:等于level属性值时的操作.有NEUTRAL(有序列表里的下个过滤器过接着处理日志),ACCEPT和DENY可选 &lt;onMismatch&gt;:不等于时的操作,类上 用来定义输出源要过滤的日志等级 示例: &gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt;&gt; &lt;level&gt;ERROR&lt;/level&gt;&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;&gt; &lt;/filter&gt;&gt; 以上配置表示只保留Error等级的日志信息 configuration - logger属性 name:指定为哪个包或类添加appender level:指定为哪个级别及以上记录日志,如果不指定,则默认继承&lt;root&gt;下的level additivity:是否向上级传递打印信息.默认值为true 子标签 &lt;appender-ref&gt;:为name表示的包或类指定appender.用属性ref来指定 用来定义包或类的日志打印级别及指定appender 示例: &gt; &lt;logger name="com.vnaso" additivity="false" level="INFO"&gt;&gt; &lt;!-- 设置日志输出 --&gt;&gt; &lt;appender-ref ref="vnasoRss"/&gt;&gt; &lt;appender-ref ref="console"/&gt;&gt; &lt;/logger&gt;&gt; 表示为com.vnaso这个包及下面所有类指定name为vnasoRss和console的appender来记录INFO及以上的日志,且不向上继承. Appender是绑定在logger上的,而logger又有继承关系,因此一个logger打印信息时的目的地Appender需要参考它的父亲和祖先.在logback中,默认情况下,如果一个logger打印一条信息,那么这条信息首先会打印至它自己的Appender,然后打印至它的父亲和父亲以上的祖先的Appender,但如果它的父亲设置了 additivity = false,那么这个logger除了打印至它自己的Appender外,只会打印至其父亲的Appender,因为它的父亲的additivity 属性置为了false,开始变得忘祖忘宗了,所以这个logger只认它父亲的Appender;此外,对于这个logger的父亲来说,如果父亲的logger打印一条信息,那么它只会打印至自己的Appender中(如果有的话),因为父亲已经忘记了爷爷及爷爷以上的那些父辈了. configuration - root属性 level(only):指定为哪个级别及以上记录日志 子标签 &lt;appender-ref&gt;:为name表示的包或类指定appender.用属性ref来指定 &lt;root&gt;标签是一种特殊的logger,但是它不能特别指定包或类.也就是说,它只能够接收继承了它且additivity值为true的logger传来的打印信息,具体查看继承关系 继承关系 继承关系是通过logger的name属性来实现的. 示例 &lt;root&gt;&gt;com.vnaso&gt;com.vnaso.controller&gt;com.vnaso.controller.UserController.java 以上对应继承关系:祖&gt;爷&gt;父&gt;子 level继承关系 appender继承关系]]></content>
      <categories>
        <category>Tool</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>Logback</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven学习笔记]]></title>
    <url>%2F2019%2F02%2F04%2FJavaLearning%2FTools%2FMaven%2F</url>
    <content type="text"><![CDATA[Maven使用Maven安装与配置下载与安装Maven官网下载地址 在如下位置点击下载最新版本Maven的压缩包 解压文件得到apache-maven-xxx文件夹.xxx为版本号 新建环境变量MAVEN_HOME,变量值为maven根目录地址 打开环境变量设置的步骤为: 右击此电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 Win+R-&gt;sysdm.cpl-&gt;高级-&gt;环境变量 编辑环境变量path,添加%MAVEN_HOME%\bin\ 至此,maven安装完毕.打开命令提示符窗口(Win+R-&gt;cmd),输入mvn -v查询maven版本,检查maven是否成功安装.成功如图所示 配置创建maven仓库 如果不自行创建,maven将默认使用Default: ${user.home}/.m2/repository作为本地仓库 在想要作为maven仓库的地方创建文件夹maven-repository作为maven的本地仓库 打开maven安装根目录-&gt;conf-&gt;settings.xml 在&lt;settings&gt;标签下,找到&lt;localRepository&gt;标签.如果没有则自行添加. 修改值为本地仓库的地址,如&lt;localRepository&gt;C:\Maven\apache-maven-3.6.0\maven-repository&lt;/localRepository&gt; 修改下载镜像地址 将下载镜像更换为阿里云中央仓库,解决依赖从境外网站下载过慢的问题 打开maven安装根目录-&gt;conf-&gt;settings.xml 在&lt;settings&gt;标签下找到&lt;mirrors&gt;标签,添加如下代码 &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 保存即可 针对Maven添加依赖时没有自动提示的解决方案 到Maven仓库官网搜索,点击需要添加的依赖.复制&lt;dependency&gt;标签即可. Maven仓库官网 在IDEA中配置Maven 打开IDEA,settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 修改Maven home directory为maven安装根目录 勾选User settings file后的Override,然后修改为安装根目录-&gt;conf-&gt;settings.xml 勾选Local repository后的Override,然后修改为本地的repository地址 Maven项目结构 项目根目录/ src/ main/ 项目主体根目录 java 源代码目录 resources 所需资源目录 filters 资源过滤文件目录 assembly 组件的描述配置(如何打包) config 配置文件 wepapp web应用的目录.WEB-INF,css,js等 test/ 项目测试目录根 java 单元测试java源代码文件 resources 测试需要用的资源库 filters c测试资源过滤库 site Site一些文档 target/ 存放项目构建后的文件和目录.jar,war,编译的class文件等 pom.xml MMaven的pom文件 LICENSE.TXT 项目的LISENCE README.TXT 项目的README Maven生命周期 Maven生命周期执行顺序从上至下 每执行当前指令之前,会把之前(上方)的指令都执行一次 每执行当前周期之前会执行之前的生命周期 clean生命周期 清理项目 clean 描述 pre-clean 执行清理前需要完成的工作execute processes needed prior to the actual project cleaning clean 清理上一次构建生成的文件remove all files generated by the previous build post-clean 执行清理后需要完成的工作execute processes needed to finalize the project cleaning default生命周期 构建项目 default 描述 validate 验证工程是否正确,所需要的资源是否可用validate the project is correct and all necessary information is available compile 编译项目的源代码compile the source code of the project test 使用已编译的测试代码,测试已编译的源代码test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed package 采用编译的代码,并以其可分配格式(如JAR)进行打包take the compiled code and package it in its distributable format, such as a JAR. verify 运行所有检查,验证包是否有效且达到质量标准run any checks on results of integration tests to ensure quality criteria are met install 把包安装在本地的repository中,可以被其他工程作为依赖来使用install the package into the local repository, for use as a dependency in other projects locally deploy 在整合或者发布环境下执行,将最终版本的包拷贝到远程的repository,使得其他的开发者或者工程可以共享done in the build environment, copies the final package to the remote repository for sharing with other developers and projects. site生命周期 建立和发布项目站点 site 描述 pre-site 生成项目站点之前需要完成的工作execute processes needed prior to the actual project site generation site 生成项目站点文档generate the project’s site documentation post-site 生成项目站点之后需要完成的工作execute processes needed to finalize the site generation, and to prepare for site deployment site-deploy 将项目站点发布到服务器deploy the generated site documentation to the specified web server Maven默认生命周期 Default Lifecycle 生命周期阶段 描述 validate 验证 确保当前配置和 POM 的内容是有效的。这包含对 pom.xml 文件树的验证。 initialize 初始化 在执行构建生命周期的主任务之前可以进行初始化。 generate-sources 生成源码 代码生成器可以开始生成在以后阶段中处理或编译的源代码。 process-sources 处理源码 提供解析、修改和转换源码。常规源码和生成的源码都可以在这里处理。 generate-resources 生成资源 可以生成非源码资源。通常包括元数据文件和配置文件。 process-resources 处理资源 处理非源码资源。修改、转换和重定位资源都能在这阶段发生。 compile 编译 编译源码。编译过的类被放到目标目录树中。 process-classes 处理类 处理类文件转换和增强步骤。字节码交织器和常用工具常在这一阶段操作。 generate-test-sources 生成测试源码 mojo 可以生成要操作的单元测试代码。 process-test-sources 处理测试源码 在编译前对测试源码执行任何必要的处理。在这一阶段，可以修改、转换或复制源代码。 generate-test-resources 生成测试资源 允许生成与测试相关的（非源码）资源。 process-test-resources 处理测试资源 可以处理、转换和重新定位与测试相关的资源。 test-compile 测试编译 编译单元测试的源码。 process-test-classes 对测试编译生成的文件做后期处理(需Maven2.0.5及以上) test 测试 运行编译过的单元测试并累计结果。 prepare-package 执行打包前的所有操作(需Maven2.1及以上) package 打包 将可执行的二进制文件打包到一个分布式归档文件中，如 JAR 或 WAR。 pre-integration-test 前集成测试 准备集成测试。这种情况下的集成测试是指在一个受到一定控制的模拟的真 实部署环境中测试代码。这一步能将归档文件部署到一个服务器上执行。 integration-test 集成测试 执行真正的集成测试。 post-integration-test 后集成测试 解除集成测试准备。这一步涉及测试环境重置或重新初始化。 verify 检验 检验可部署归档的有效性和完整性。过了这个阶段，将安装该归档。 install 安装 将该归档添加到本地 Maven 目录。这一步让其他可能依赖该归档的模块可以使用它。 deploy 部署 将该归档添加到远程 Maven 目录。这一步让这个工件能为更多的人所用。 Maven环境隔离配置 在pom.xml中的&lt;build&gt;节点下插入&lt;resources&gt;节点,在其中添加&lt;resource&gt;节点来声明要进行环境分离的resource目录.然后在pom.xml中&lt;project&gt;节点下(与&lt;build&gt;同级)增加&lt;profiles&gt;节点,通过添加&lt;profile&gt;节点来配置不同环境. 在&lt;build&gt;节点下插入&lt;resources&gt;节点 &lt;resources&gt; &lt;!-- 设置resources资源文件夹目录 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources.$&#123;deploy.type&#125;&lt;/directory&gt; &lt;!-- 排除指定文件 --&gt; &lt;excludes&gt; &lt;exclude&gt;*.jsp&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;!-- 设置resources资源文件夹目录 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt;&lt;/resources&gt; 在&lt;project&gt;节点下插入&lt;profiles&gt;节点,并配置各个环境的环境标识及其他属性 &lt;profiles&gt; &lt;!-- dev环境 --&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 设置默认使用该环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;!-- 设置环境标识 --&gt; &lt;properties&gt; &lt;deploy.type&gt;dev&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- beta环境 --&gt; &lt;profile&gt; &lt;id&gt;beta&lt;/id&gt; &lt;!-- 设置环境标识 --&gt; &lt;properties&gt; &lt;deploy.type&gt;beta&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- product环境 --&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;!-- 设置环境标识 --&gt; &lt;properties&gt; &lt;deploy.type&gt;prod&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 创建resources.&lt;环境标识&gt;目录,这样便可结合&lt;resource&gt;中定义的${deploy.type}和&lt;profile&gt;中定义的&lt;properties&gt;属性值来选择使用哪个环境 Maven命令使用 -Dmaven.test.skip=true:跳过测试 -P${deploy.type}:使用指定的环境.例如:mvn package -Pdev,使用dev环境 mvn help:effective-settings:查看生效的配置.这里的内容是settings.xml中生效的配置,可以用来查看repository地址和mirror的配置]]></content>
      <categories>
        <category>Tool</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
</search>
