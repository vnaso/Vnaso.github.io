<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IDEA导入项目]]></title>
    <url>%2F2018%2F12%2F03%2FTools%2FWeb%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[idea给导入的工程完善配置信息 idea升级重新安装后，发现导入的工程项目中tomcat的配置不在了。不明白Project structure 中各个选项的作用，但经过一系列踩坑，大概明白了从0开始配置project structure和tomcat。 配置工程信息 首先先将lib包右键--&gt;add as libraries File--&gt;Project structure 打开项目结构界面 如果是重新安装的Idea，需现在project下选择jdk，否则跳过 进入module界面，在第二列中出现当前项目Struts2，对其右键--&gt;add--&gt;web创建一个webfacet，然后对其右键--&gt;add--&gt;Struts2创建一个Struts2的module。然后给在第三列中点击＋按钮Struts2添加Fileset，将显示的所有文件添加进去如果没有自动列出struts.xml的话，则手动点击打开struts.xml，然后Idea会弹出提示该文件还未添加进Fileset中，点击将其添加。 重要： module下当前项目名下，右边第三栏中的source在直接打开项目时，不会在content root中添加src的目录位置，需要手动添加进去，否则会报can&#39;t resolve symbol xxx的错误，导致文件不被读取。所以需要使用的文件都要添加到content root中，webmodule下第三栏最下边有Source Roots选框，需要选中才能在对应的目录中引用web下的文件 如果启动tomcat打开网页报错找不到资源，则去Artifacts中查看是否将第三栏下面的Available Elements添加到了&lt;output root&gt;中 具体应该在WEB-INF\classes下 点击进入Artifacts，点击第二列的＋，选择Web Application:Exploded 将项目打包为war:Exploded Apply --&gt; OK完成配置 配置tomcat 点击add configuration --&gt; ＋ --&gt; Tomcat server，填好参数，配置好tomcat 点击deployment添加Artifact将之前配置好的Artifact添加进来 Apply --&gt; OK 完成配置 点击运行tomcat测试]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate之hbm.xml标签]]></title>
    <url>%2F2018%2F12%2F03%2FJava%2FHibernate-01%2F</url>
    <content type="text"><![CDATA[hbm.xml中set标签&lt;hibernate-mapping&gt; &lt;class name="com.suxiaolei.hibernate.pojos.Customer" table="customer"&gt; &lt;!--主键设置 --&gt; &lt;id name="id" type="string"&gt; &lt;column name="id"&gt;&lt;/column&gt; &lt;generator class="uuid"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!--属性设置 --&gt; &lt;property name="username" column="username" type="string"&gt;&lt;/property&gt;&lt;property name="username" column="username" type="string"&gt;&lt;/property&gt;&lt;p &lt;property name="password" column="password" type="string"&gt;&lt;/property&gt; &lt;property name="age" column="age" type="integer"&gt;&lt;/property&gt; &lt;property name="registerTime" column="register_time" type="timestamp"&gt;&lt;/property&gt; &lt;set name="orders" inverse="true" cascade="all"&gt; &lt;key column="customer_id"&gt;&lt;/key&gt; &lt;one-to-many class="com.suxiaolei.hibernate.pojos.Order"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; &lt;hibernate-mapping&gt;&lt;class name="com.suxiaolei.hibernate.pojos.Order" table="orders"&gt; &lt;id name="id" type="string"&gt; &lt;column name="id"&gt;&lt;/column&gt; &lt;generator class="uuid"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="orderNumber" column="orderNumber" type="string"&gt;&lt;/property&gt; &lt;property name="balance" column="balance" type="integer"&gt;&lt;/property&gt; t&lt;many-to-one name="customer" class="com.suxiaolei.hibernate.pojos.Customer"&gt; &lt;column name="customer_id"&gt;&lt;/column&gt; &lt;/many-to-one&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; set标签 标签中的name属性表示customer对象中关系集合的属性名，inverse与cascade属性说明。 key标签 column属性可以理解为指定生成的外键的字段名 在数据库中表示”一对多”的关系是通过外键关联的方式实现的，”多方”通过持有”一方”的主键值来确定关系，怎么持有”一方”的主键值？“多方”将使用一列来存储”一方”的主键值，然后将此列作为外键列参照”一方”的主键列。所以使用Hibernate开发时需要将两表的关系列（外键列）告诉Hibernate,就是完成这个工作的，Hibernate就能根据 customer_id列取出关联信息。 例如：从customer表中取出一条记录后，Hibernate会根据该customer记录的主键值再从order表中查找customer_id列，取出值相等的记录，然后组装到Customer对象中的set集合属性中，反之亦然。因为取出来的记录（只是一些零碎的值，还没有组装成对象）需要存放到Set集合中，所以要告诉Hibernate在Set集合里面能放什么类型的数据。这个标签就是完成这个工作的，class属性是指定这个这个Set集合里面元素的类型。 xxx-to-xxx标签 用来表明两个表之间的关联关系,name指定了哪一个属性是关系属性,class指定了关系属性的类型(也指定了与哪一个表关联)column属性是指定这个关联属性是按照customer_id列的值，在customer表中查询获得的。 注意在多对多关联中,若不在set标签中对table属性进行设置,则会默认生成两个中间表.而对table进行设置后,只会生成一个指定名称的中间表]]></content>
      <categories>
        <category>JavaFramework</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate踩坑集锦]]></title>
    <url>%2F2018%2F12%2F03%2FJava%2FHibernate-issues%2F</url>
    <content type="text"><![CDATA[Hibernate踩坑集锦hibernate.cfg.xml配置&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 定义数据库驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;!-- 定义用户名 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!-- 定义密码 --&gt; &lt;property name="hibernate.connection.password"&gt;cc943983&lt;/property&gt; &lt;!-- 数据库连接 --&gt; &lt;!--MySQL8.0中必须添加时区 &amp;amp;serverTimezone=UTC 否则会报错：Unable to open JDBC Connection for DDL execution--&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://127.0.0.1:3306/user?useSSL=false&amp;amp;serverTimezone=UTC &lt;/property&gt; &lt;!-- 定义方言 --&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQL8Dialect&lt;/property&gt; &lt;!-- 定义C3PO连接池 --&gt; &lt;property name="hibernate.connection.provider_class"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider &lt;/property&gt; &lt;!-- 注册上下文 把session和线程绑定,从而实现一个线程只有一个session --&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 配置数据库自动创建表和显示sql --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 配置文件一般放置在项目Source Root下的Resource目录中,如java/resource xxx.hbm.xml配置User.hbm.xml &lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="beans.User" table="m_user" schema="user"&gt; &lt;id name="id" column="user_id"&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="name" column="user_name"/&gt; &lt;set name="orders" cascade="all-delete-orphan"&gt; &lt;key column="user_order_id"/&gt; &lt;one-to-many class="beans.Order"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Order.hbm.xml &lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="beans.Order" table="m_order" schema="user"&gt; &lt;id name="id" column="order_id" &gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="product" column="order_item"/&gt; &lt;many-to-one name="user" class="beans.User" column="user_order_id"/&gt; &lt;set name="goods" cascade="all" table="abc"&gt; &lt;key column="orderId"&gt;&lt;/key&gt; &lt;many-to-many class="beans.Goods" column="goodsId"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Goods.hbm.xml &lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="beans.Goods" table="m_goods" schema="user"&gt; &lt;id name="id" column="goods_id"&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="name" column="goods_name"/&gt; &lt;property name="price" column="goods_price"/&gt; &lt;set name="orders" inverse="true" cascade="all" table="abc"&gt; &lt;key column="goodsId"&gt;&lt;/key&gt; &lt;many-to-many class="beans.Order" column="orderId"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 标签说明 &lt;hibernate-mapping&gt;根元素 属性 说明 package 指定一个包前缀,如果在映射文档当中没有指定全限定类名,则使用这个作为包名 &lt;class&gt;根元素-子标签:用于定义一个持久化类与数据表的映射关系 属性 说明 class 用于指定类和表的映射 name 指定该持久化类映射的持久化类的全限定类名 table 指定该持久化类映射的表明,Hibernate默认以持久化类的类名作为表名 lazy 指定是否使用延迟加载 &lt;id&gt;class-子标签:标识属性,用于唯一的标识某个持久化实例 属性 说明 name 持久化类的标识属性名 type 标识Hibernate类型的名字 column 对应数据库表的主键的字段名 &lt;generator&gt;class-&gt;id-子标签:用于设定标识符生成器 标识符生成器 说明 increment 由Hibernate自动以递增方式生成(常用) identity 由底层数据库生成标识符 sequence Hibernate根据底层数据库的序列生成标识符,要求堆成数据库支持序列 hilo Hibernate分局high/low算法生成标识符 seqhilo 使用一个高/低位算法来高效的生成long,short或者int类型的标识符 native 根据底层数据库对自动生成标识符的方式,自动选择identity,sequence,hilo uuid.hex Hibernate采用128位的UUID算法生成宏标识符 uuid.string UUID被编码成一个16字符长的字符串 assigned 适用于自然主键,由java应用程序负责生成标识符 foreign 使用另外一个相关联的对象的标识符 &lt;property&gt;class-子标签:用于指定类的属性和表的字段的映射,使它们产生关联 属性 说明 name 指定该持久化类的名字 column 指定与类的属性映射的表的字段名,默认使用类的属性名作为字段名 type 指定Hibernate映射类型.一般不设置,使用默认值 not-null 若属性值为true,表明不允许为null,默认为false access 指定Hibernate的默认的属性访问策略.默认为property,即使用getter,setter unique 设置是否为该属性所映射的数据列添加唯一约束 index 指定一个字符串的索引名称 关联映射标签设置 &lt;set&gt;class-子标签 属性 说明 name 关联类属性的名称,需为集合类型,必须填写 table 关联类的目标数据库表,无默认值建议在==多对多==关联中使用-否则会生成两张中间表 lazy 指定关联对象延迟加载策略,默认为true fetch 设置抓取数据的策略,默认为select inverse 描述对象之间关联关系的维护方式,默认为false.true表示由关联的另一方来维护,即当前对象对数据库的修改不会生效 cascade all: 所有情况下均进行关联操作，即save-update和deletenone: 所有情况下均不进行关联操作。这是默认值save-update: 在执行save/update/saveOrUpdate时进行关联操作 delete: 在执行delete 时进行关联操作all-delete-orphan: 当一个节点在对象图中成为孤儿节点时，删除该节点 &lt;key&gt;class-&gt;set-子标签:表明集合对应的表的外键列 因为集合属性都需要保存到另一个数据表中，所以保存集合属性的数据表必须包含一个外键列用于参照到主键列，可以在集合属性元素中用子元素&lt;key…/&gt;来映射 属性 说明 coLumn 指定外键字段名 not-null 非空 unique 是否唯一约束 undate 是否可更新 property-ref 指定外键字段是否为原表的主键 column属性可以理解为指定生成的外键的字段名 在数据库中表示”一对多”的关系是通过外键关联的方式实现的，”多方”通过持有”一方”的主键值来确定关系，怎么持有”一方”的主键值？“多方”将使用一列来存储”一方”的主键值，然后将此列作为外键列参照”一方”的主键列。所以使用Hibernate开发时需要将两表的关系列（外键列）告诉Hibernate,就是完成这个工作的，Hibernate就能根据 column列取出关联信息 实例可参考同文件目录下:Hibernate_01.md &lt;xxx-to-xxx&gt;class-子标签;set-子标签:表明两表之间的关联关系 属性 说明 name 指定持久化类中的哪个属性为关系属性 class 指定关系属性的类型,即与哪个表关联 column 指定从哪一列的值获取对应的数据,若没有则自动创建 数据库注意事项 表名格式最好为项目名_表名,字段名为表名_字段名,使用单个单词,可能会和==数据库保留字段冲突==而报错 在IDEA中对Hibernate进行逆向工程时,由于IDEA有bug,导致无法识别数据库中的外键.所以需要手动设置外键,所以建议==数据库表不设外键==,而由Hibernate来创建 使用Maven搭建项目注意事项建Maven项目的时候，如果没有进行特殊的配置，Maven会按照标准的目录结构查找和处理各种类型文件.如果xxx.hbm.xml放在非Resource文件夹下,Maven将不会把xml文件添加到target文件夹中,导致运行程序时找不到资源文件.解决办法如下: 建立Resource目录,将hbm.xml和cfg.xml都放置在资源文件夹中 找到Maven的pom.xml配置文件,在根元素下添加以下代码 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;]]></content>
      <categories>
        <category>JavaFramework</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate之hbm.xml标签]]></title>
    <url>%2F2018%2F12%2F03%2FJava%2FSSH%2F</url>
    <content type="text"><![CDATA[SSH框架整合pom.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.vnaso.ssh&lt;/groupId&gt; &lt;artifactId&gt;SSHTest&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSHTest&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;!-- 统一源码的编码方式 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 统一各个框架版本 --&gt; &lt;struts.version&gt;2.5.18&lt;/struts.version&gt; &lt;spring.version&gt;4.3.8.RELEASE&lt;/spring.version&gt; &lt;hibernate.version&gt;5.1.7.Final&lt;/hibernate.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Junit依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring整合ORM框架依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring junit--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Struts2 核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Struts2和Spring整合依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Hibernate 核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- C3P0 依赖 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;version&gt;5.3.7.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- AspectJ依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;maven_ssh&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 统一源代码编译输出的JDK版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包时跳过单元测试 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19.1&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 如果没有此配置 在使用maven打包时可能会报错 Error assembling WAR: webxml attribute is required--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;webXml&gt;web\WEB-INF\web.xml&lt;/webXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; &lt;package&gt;:指定maven项目打包方式 &lt;properties&gt;:用来定义全局变量.用法:${标签名} &lt;dependencies&gt;:描述当前项目依赖关系 &lt;dependency&gt;:描述当前项目单个依赖关系 &lt;build&gt;:构建项目所需要的信息 &lt;finalName&gt;:指定最后打包的包名 &lt;plugins&gt;:包含插件所需要的信息 纯xml版本applicationContext.xml内容&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;bean id="productService" class="com.vnaso.ssh.Service.Impl.ProductServiceImpl"&gt; &lt;property name="productDao" ref="productDao"/&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id="productDao" class="com.vnaso.ssh.Dao.Impl.ProductDaoImpl"&gt; &lt;property name="hibernateTemplate" ref="hibernateTemplate"/&gt; &lt;/bean&gt; &lt;!-- 配置 HibernateTemplate --&gt; &lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate5.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 配置sessionFactory:spring接管sessionFactory创建 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* com.vnaso.ssh.Service..*(..))"/&gt; &lt;!-- 建立切入点表达式和事务通知的关联--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt; &lt;/aop:config&gt; &lt;!-- --&gt;&lt;/beans&gt; Dao部分 &lt;bean&gt;的属性已经包含spring需要的所有约束. 为ProductService,ProductDao创建了bean,并注入需要的bean. Hibernate部分 Spring接管SessionFactory的创建,直接作为单例bean使用,简化了创建的操作.bean的创建有两种方式: 通过cfg.xml文件创建 结合properties文件直接给对应property赋值 为HibernateTemplate创建bean,并注入SessionFactory 事务部分 为TransactionManager创建bean,并注入SessionFactory.配置事务管理器 使用&lt;tx:advice&gt;配置事务的通知,属性transaction-manager指定为TransactionManager的bean 子标签&lt;tx:method&gt;用于指定各个事务方法的权限,name用来匹配方法,可以用通配符.其他参照 Spring-notes 使用&lt;aop:config&gt;配置切面 &lt;aop:pointcut&gt;用于定义切点 &lt;aop:advisor&gt;用于建立切点表达式和事务通知的关联 struts.xml内容&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN" "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name="struts.devMode" value="true"/&gt; &lt;package name="product" extends="struts-default" namespace="/product"&gt; &lt;action name="addProduct" class="com.vnaso.ssh.Action.ProductAction" method="addProduct"&gt; &lt;result name="addProduct"&gt;view/addProductSuccess.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="findAllProduct" class="com.vnaso.ssh.Action.ProductAction" method="findAllProduct"&gt; &lt;result name="findAllProduct"&gt;view/findAllProductSuccess.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;/&gt;开启开发者模式,便于在网页查看错误信息 其他与直接使用struts2时配置相同 hibernate.cfg.xml内容&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 定义数据库驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;!-- 定义用户名 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!-- 定义密码 --&gt; &lt;property name="hibernate.connection.password"&gt;cc943983&lt;/property&gt; &lt;!-- 数据库连接 --&gt; &lt;!--MySQL8.0中必须添加时区 &amp;amp;serverTimezone=UTC 否则会报错：Unable to open JDBC Connection for DDL execution--&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://127.0.0.1:3306/vnaso?useSSL=false&amp;amp;serverTimezone=UTC &lt;/property&gt; &lt;!-- 定义方言 --&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 定义C3PO连接池 --&gt; &lt;property name="hibernate.connection.provider_class"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider &lt;/property&gt; &lt;!-- 注册上下文 把session和线程绑定,从而实现一个线程只有一个session--&gt; &lt;!--&lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt;--&gt; &lt;!-- 配置数据库自动创建表和显示sql --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;mapping resource="product.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 需要注意:在与spring整合时,&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;需要删除 spring整合hibernate管理事务后,由Spring的TransactionManager管理事务后, currentSession是绑定到SpringSessionContext的,而不是thread此时hibernate.current_session_context_class应该是SpringSessionContext,而它又会在使用LocalSessionFactoryBean时自动的设置.所以就不需要你去设置current_session_context_class 参考链接 web.xml配置&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!-- 配置struts2和核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;view/test01.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; &lt;filter&gt;标签配置struts2的核心过滤器 &lt;listener&gt;配置spring的监听器,在web容器启动时,自动装配applicationContext.xml的配置信息 &lt;context-param&gt;自定义applicationContext.xml的位置,不设置则默认位于WEB-INF/目录下 xml+注解版本总结 容器应该是单例的 容器一个应用只有一个,应该存储在应用域中 Struts2的配置文件有加载顺序,遇到相同的配置时,后加载的配置会覆盖先加载的 需要解决的问题 整合SSH的pom 集合所有约束的bean.xml log4j2(书签中) 使用TransationMangeger时注意导入的class的hibernate后的版本号 maven项目部署到tomcat上 clean-&gt;install-&gt;tomcat run web.xml中配置spring的classloader作用及原因 “MySQLNonTransientConnectionException: Public Key Retrieval is not allowed” 重启电脑或软件就能解决 的原因 Struts2的modeldriven模型驱动模式]]></content>
      <categories>
        <category>JavaFramework</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>Spring</tag>
        <tag>Struts2</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring笔记]]></title>
    <url>%2F2018%2F12%2F03%2FJava%2FSpring-notes%2F</url>
    <content type="text"><![CDATA[Spring笔记IOC简化Java开发采取以下四种策略,降低Java开发的复杂性 基于POJO的轻量级和最小侵入性编程 通过依赖注入(DI)和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板式代码 依赖注入 Sprin通过应用上下文(Application Context)装载bean的定义并把它们组装起来.Spring应用上下文全权负责对象的创建和组装.Spring自带多种应用上下文的实现,他们之间的主要区别仅仅在于如何加载配置 两种方式配置bean 通过xml配置, 通过java配置 应用切面 DI能够让相互协作的软件组件保持松耦合,而面向切面编程(AOP)允许你把遍布应用各处的功能分离出来形成可重用的组件. Beanbean的创建方式 调用默认无参构造函数创建(常用) 使用静态工厂中的方法创建对象 使用实例工厂中的方法创建 bean的作用范围通过配置bean的scope属性来调整作用范围,属性取值有 属性值 描述 singleton 单例的(默认值) prototype 多例的(当我们让spring接管struts2的action创建时,action必须配置此值) request 作用范围是一次请求,和当前请求的转发 session 作用范围是一次会话 globalsession 作用范围是一次全局会话 bean的生命周期单例:随着容器的创建而创建,销毁而销毁 多例:每次使用时创建对象,只要对象在使用中就一直存在,被垃圾回收器回收销毁 在config类中装配bean带有@Bean注解的方法可以采用任何必要的java功能来产生bean实例. 引用创建bean的方法来装配bean @Beanpublic CDPlayer cdPlayer()&#123; return new CDPlayer(aDisc()); // aDisc()也是位于其他任何位置的一个创建bean的方法&#125; @Beanpublic CompactDisc aDisc()&#123; return new ADisc();&#125; 使用Setter方法注入 @Beanpublic CDPlayer cdPlayer(CompactDisc aDisc)&#123; CDPlayer cdPlayer = new CDPlayer(); cdPlayer.setCompactDisc(aDisc); return cdPlayer;&#125; 依赖注入注入方式 使用构造函数注入 使用set方法注入(推荐,不改变类结构) 使用注解注入 注入的数据类型 基本类型和String类型 其他bean类型(必须在spring的配置文件中出现过的bean) 复杂类型(集合类型) 基于注解的IoC 用于创建bean对象 @Component: 作用:相当于配置了一个bean标签 位置:出现在类上面 属性:value.含义是指定bean的id,默认值:当前类的短名,首字母小写 @Controller,@Service,@Repository这三个注解是基于@Component的拓展,并且具有特定功能.分别用于表现层,业务层和持久层 @Bean 作用:把方法的返回值注入容器中 位置:出现在方法上 属性:name-用于指定bean的id,默认值是方法的名称,首字母小写 用于注入数据 @AutoWired: 作用:自动按照类型注入,只要有唯一的类型匹配就能注入成功.如果注入的beasn在容器中不唯一,就把变量名作为bena的id,在容器中查找,找到后也能注入成功.还不成功则报错 @Qualifier 作用:在自动按照类型注入的基础上,再按照bean的id注入.在给类成员注入数据时,不能独立使用.但是在给方法的形参注入数据时,可以独立使用. 属性:value-用于指定bean的id @Resource 作用:直接按照bean的id注入 属性:name-用于指定bean的id @Value 作用:用于注入基本类型和String类型数据.可以借助SpEL表达式读取properties文件中的配置 属性:value-用于指定要注入的数据 用于改变作用范围 @Scope 作用:用于改变bean的作用范围 属性:value-用于指定范围的取值 新增注解 @ComponentScan 作用:告知Spring哪些packages的用注解标识的类会被spring自动扫描并且装入bean容器 位置:最好单独写在一个config类上 属性:value,basePackages-用于指定扫描的包,是String集合 @Configuration 作用:把当前类看做为Spring的配置类 类上的注解@Configuration是最新的用注解配置spring,也就是说这是个配置文件,和原来xml配置是等效的,只不过现在用java代码进行配置了,加上一个@Configuration注解就行了.不需要繁琐的xml配置了，这样基于注解的配置，可读性也大大增高了。 @Import 作用:导入其他配置类 属性:value-指定需要导入的配置类,值类型为字节码(.class)的集合 这样就可以使用其他配置类中的bean,而不需要去将一个配置类创建为bean. @PropertiesSource 作用:将properties配置文件中的值存储到Spring的Environment中,Environment接口提供方法去读取配置文件中的值,参数是properties文件中定义的key值.或使用${xxx..xxx}来获取值 属性:value-值为properties的路径String集合 Srping整合junit 拷贝Spring提供的整合jar包:spring-test-4.2.4.RELEASE.jar 使用junit提供的一个注解,把原有的main函数替换掉,换成Spring提供的@RunWith,要替换的类:SpringJunit4ClassRunner 即@RunWith(SpringJunit4ClassRunner.class) 使用注解告知Spring,配置文件或者注解所在的位置:@ContextConfiguration 即@ContextConfiguration(classes={配置类字节码}) 如果不整合junit,在单元测试时无法使用在方法之外的变量 AOP术语 连接点(Join point) 连接点是程序执行过程中能够应用通知的所有点. 通知(Advice) 通知是指拦截到切点之后要做的事情就是通知,包含了需要用于多个应用对象的横切行为. 切点(Pointcut) 切点定义了通知被应用的具体位置.切点定义了那些连接点会得到通知. 切面(Aspect) 切面是通知和切点的结合.通知和切点共同定义了切面的全部内容–它是什么,在何时和在何处完成其功能. 引入(Introduction) 引入允许我们向现有的类添加新方法或属性. 织入(Weaving) 织入是把切面应用到目标对象并创建新的代理对象的过程.切面在指定的连接点被织入到目标对象中.在目标对象的生命周期里有多个点可以进行织入. aop配置步骤切点表达式关键字:execution(表达式) 表达式写法: 访问修饰符+返回值+包名.包名...类名.方法名(参数列表) 访问修饰符可以省略 返回值可以使用通配符*,表示任意返回值 包名可以使用通配符,但是有几个包就需要几个* 参数类别可以使用具体类型来表示参数类型,也可以使用通配符表示任意参数: 基本类型直接写类型名称:int 应用类型必须是包名.类名:java.lang.Integer 全匹配方式: public void com.vnaso..test.testMethod() 包名后面’..’: 表示当前包及子包 方法参数(..): 表示任何参数类型 全通配方式: * *.*.*(...) xml 把通知类交给spring管理 &lt;bean id=&quot;xxx&quot; class=&quot;aaa.bbb.xxx&quot;/&gt; 导入aop名称控件,并且使用aop:config开始aop的配置 &lt;aop:config&gt;…&lt;/aop:config&gt; 使用aop:aspect配置切面,id属性用于给切面提供一个唯一表示,ref属性用于应用通知Bean的id &lt;aop:aspect id=&quot;abcde&quot; ref=&quot;xxx&quot;&gt;….&lt;/aop:aspect&gt; 配置通知的类型,指定增强的方法何时执行.method属性用于指定增强的方法名称,pointcut属性用于指定切点表达式 &lt;aop:before method=&quot;sadfa&quot; pointcut=&quot;pt&quot;/&gt; 定义切入点表达式,需要定义在通知之前 &lt;aop:pointcut expression=&quot;execution(* com.vnaso..test.testMethod(..))&quot; id = &quot;pt&quot;/&gt; java注解 定义切面:@Aspect,位于类名上. 为切面创建Bean 定义通知:@Before,@After,@AfterReturning,@AfterThrowing,@Around.位于方法上. 定义切点:@Pointcut(切点表达式) 位于要织入的方法上 位于一个空方法上,让方法名()等同于切点表达式. 注意:不能漏掉切点的方法的括号 @Pointcut("execution(* com.vnaso..test.testMethod(..))")private void pt()&#123;&#125;@Before("pt()")public void beforeMethod()&#123; // do something ...&#125; 启动自动代理功能:@EnableAspectJAutoProxy,建议写在配置类上 通知类型 前置通知(Before):在目标方法被调用之前调用通知功能 后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么 返回通知(After-returning):在目标方法成功执行之后调用通知 异常通知(After-throwing):在目标方法抛出异常后调用通知 环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为 执行顺序: try&#123; try&#123; //@Before method.invoke(..); &#125;finally&#123; //@After &#125; //@AfterReturning&#125;catch()&#123; //@AfterThrowing&#125; 注意:被调用的方法才能作为切点,而作为junit测试单元的方法运行时不会有通知 声明式事务APIPlatformTransactionManager此接口是spring的事务管理器,它提供了我们常用的操作事务的方法 接口方法 获取事务状态信息 TransactionStatus getTrasaction(TrasactionDefinition definition) 提交事务 coid commit(TransactionStatus status) 回滚事务 void rollback(TransactionStatus status) 实现类 DataSourceTransactionManager HibernateTransactionManager HibernateX.HibernateTransactionManager X指的是Hibernate的版本 JpaTransactionManager JdoTransactionManager JtaTransactionManager TransactionDefinition它是事务的定义信息对象 方法 获取事务对象名称 String getName() 获取事务隔离级 int getIsolationLevel() ISOLATION_DEFAULT 默认级别，归属下面某一种 ISOLATION_READ_UNCOMMITTED 可以读取未提交数据 ISOLATION_READ-COMMITTED 只能读取已提交数据，解决脏读问题(Oracle默认级别) ISOLATION_REPEATABLE_READ 是否读取其他事务提交修改后的数据,解决不可重复读问题(MySQL默认级别) ISOLATION_SERIALIZABLE 是否读取其他事务提交后的数据,解决幻影读问题 获取事务传播行为 int getPropagationBehavior() REQUIRED 如果当前没有事务,就新建一个事务,如果已经存在一个事务中,加入到这个事务中.(默认值) SUPPORTS 支持当前事务.如果当前没有事务,就以非事务方式执行(没有事务) MANDATORY 使用当前事务,如果当前没有事务,就抛出异常 REQUERS_NEW 新建事务,如果当前在事务中,把当前事务挂起 NOT_SUPPORTED 以非事务方式执行操作,如果当前存在事务,就把当前事务挂起 NEVER 以非事务方式运行,如果当前存在事务,抛出异常 NESTED 如果当前存在事务,则在嵌套事务内执行.如果当前没有事务,则执行REQUIRED类似的操作 获取事务超时时间 int getTimeout() 默认值是-1,没有超时限制.如果有,以秒为单位设置 获取事务是否只读 boolean isReadOnly() TransactionStatus此接口提供的是事务具体的运行状态.描述了某个时间点上事务对象的状态信息 方法 刷新事务 void flush() 获取是否存在存储点 boolean hasSavepoint() 获取事务是否完成 boolean isCompleted() 获取事务是否为新的事务 boolean isNewTransaction() 获取事务是否回滚 boolean isRollbackOnly() 设置事务回滚 void setRollbackOnly() xml配置 配置事务管理器 &lt;bean id = "transactionManager" class="..."&gt; &lt;property name="dataSource" ref="..."/&gt;&lt;/bean&gt; 配置事务的通知 &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!-- 配置事务的属性 --&gt; &lt;tx:attributes&gt; &lt;!-- 可以使用通配符 --&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORT" read-only="true"/&gt; &lt;tx:method name="..."/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice &lt;tx:method&gt;标签属性 isolation:配置事务的隔离级别 propagation:配置事务的传播行为 timeout:指定事务的超时时间 read-only:配置是否只读事务,默认false(读写) rollback-for:用于指定一个异常,执行产生该异常时,事务回滚.产生其他异常时,不会滚.没有默认值,任何异常都回滚 no-rollback-for:用于指定一个异常,当执行产生该异常时,事务不回滚.产生其他异常时,事务回滚.没有默认值,任何异常都回滚 配置aop:切点表达式,通知和切入点表达式的关联 &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression="execution(* com.vnaso.test..testMethod(..))" id="pt1"/&gt; &lt;!-- 配置事务通知和切入点表达式的关联 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt;&lt;/aop:config&gt; java配置 配置事务管理器 新建事务管理的配置类,并编写TransactionManager及其所需要的DataSource的bean 配置spring开启注解事务的支持 一般情况下该注解写在spring的配置类上,需使用@Import导入其他配置类. 使用注解@EnableTransactionManagement开启事务的支持 在需要事务的地方使用@Transactional注解,一般位于@Service下 @Transational(propagation=Propagation.REQUIRED,readOnly=false,...) 接口:表示该接口的所有实现类都有事务 类上:表示该类中所有方法都有事务 方法上:表示该方法有事务 就近原则 知识点 Spring表达式语言装配 SpEL AOP:通知包含了需要用于多个应用对象的横切行为;连接点是程序执行过程中能够应用通知的所有点;切点定义了通知被阴影的具体位置(在哪些连接点).引入允许我们向现有的类添加新的方法和属性. POJO:Plain Old Java Object,是一个简单的、正规Java对象,它包含业务逻辑处理或持久化逻辑等,但不是JavaBean、EntityBean等,不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口 JavaBean:是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。 实用技巧善用properties,降低维护成本,减弱依赖使用方法: 定义一个ResourceBundle对象 private static ResourceBundle bundle = ResourceBundle.getBundle(PROPERTIES_FULL_PATH); PROPERTIES_FULL_PATH为properties全类名路径 使用getXxx(key)根据key读取对应类型的值 优化选项: 使用一个Map容器来存储,用于没有线程安全问题环境下(单例) private static Map&lt;String,Object&gt; beans = new HashMap&lt;String,Object&gt;();// 使用静态代码,初始化mapstatic&#123; // 读取配置文件中所有的配置 Enumeration&lt;String&gt; keys = bundle.getKeys(); // 遍历keys while(keys.hasMoreElements)&#123; // 取出一个key String key = key.nextElement(); // 根据key获取beanPath String beanPath = bundle.getString(key); // 根据beanPath反射创建类对象 Object value = Class.forName(beanPath).newInstance(); // 把key和value存入map中 beans.put(key,value); &#125;&#125; 动态代理作用:不改变源码的基础上,对已有的方法增强.(是AOP思想的实现技术) 基于接口的动态代理要求:被代理类至少实现一个接口 提供者:JDK官方 涉及的类:Proxy 创建代理对象的方法:newProxyInstance(ClassLoader,Class[],InvocationHandler) 参数的含义: ClassLoader:类加载器,和被代理对象使用相同的类加载器. Class[]:字节码数组,被代理类实现的接口.(要求代理对象和被代理对象具有相同的行为) InvocationHandler:它是一个接口,就是用于提供增强的代码.一般传入一个该接口的实现类,也可以传入一个匿名内部类.含义就是:如何代理.此处的代码只能是谁用谁提供. 使用的是策略模式 IActor proxyActor = Proxy.newProxyInstance(actor.getClass().getClassLoader(),actor.getClass().getInterfaces(),new InvocationHandler()&#123; @Override public Object invoke(Object proxy,Method method,Object[] args)throws Throwable&#123; // 执行被代理对象的任何方法都会经过该方法,该方法有拦截的功能 // 方法的参数 // Object proxy: 代理对象的应用,不一定每次都会有 // Method method: 当前执行的方法 // Object[] args: 当前执行方法所需的参数 // 返回值: 当前执行方法的返回值,Object 也可以接受返回类型void. void也是Object子类 // TODO 要添加的增强的代码 &#125;&#125;); 基于子类的动态代理要求:被代理类不能是最终类,不能被final修饰 提供者:第三方CGLib.需导jar包 涉及的类:Enhancer 创建代理对象的方法:create(Class,Callback) 参数的含义: Class:被代理对象的字节码 Callback:如何代理.它和InvocationHandler的作用是一样的,它也是一个接口,我们一般使用该接口的子类MethodInterceptor.在使用时也是创建该接口的匿名内部类 Actor actor = (Actor)Enhance.create(actor.getClass(),new MethhodInterceptor()&#123; @Override public Object intercept(Object proxy,Method method,Object[] args,MethodProxy methodProxy)throws Throwable&#123; // 执行被代理对象的任何方法,都会经过该方法.它和基于接口动态代理的invoke方法作用是一样的 // 方法的参数 // 前面三个和invoke方法的参数含义和作用都是一样的 // MethodProxy methodProxy: 当前执行方法的代理对象,一般不用 // TODO 增强的代码 &#125;&#125;);]]></content>
      <categories>
        <category>JavaFramework</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA常用快捷键]]></title>
    <url>%2F2018%2F12%2F03%2FTools%2FIDEA-shortcut-keyboard%2F</url>
    <content type="text"><![CDATA[Ctrl 快捷键 介绍 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 （必备） Ctrl + N 根据输入的 类名 查找类文件 （必备） Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 （必备） Ctrl + P 方法参数提示显示 （必备） Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 （必备） Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备） Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码处显示错误信息 （必备） Ctrl + F3 调转到所选中的词的下一个引用位置 （必备） Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备） Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号（必备） Ctrl + Delete 删除光标后面的单词或是中文句 （必备） Ctrl + BackSpace 删除光标前面的单词或是中文句 （必备） Ctrl + 1,2,3…9 定位到对应数值的书签位置 （必备） Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 （必备） Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 （必备） Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 （必备） Ctrl + 前方向键 等效于鼠标滚轮向前效果 （必备） Ctrl + 后方向键 等效于鼠标滚轮向后效果 （必备） Alt 快捷键 介绍 Alt + \ 显示版本控制常用操作菜单弹出层 （必备） Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备） Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备） Alt + 左方向键 切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 右方向键 按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 （必备） Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 （必备） Alt + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备） Shift 快捷键 介绍 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 （必备） Shift + Tab 取消缩进 （必备） Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备） Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备） Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 （必备） Ctrl + Alt 快捷键 介绍 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 （必备） Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + C 重构-快速提取常量 Ctrl + Alt + F 重构-快速提取成员变量 Ctrl + Alt + V 重构-快速提取变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 （必备） Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 （必备） Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Alt + 右括号（]） 在打开多个项目的情况下，切换下一个项目窗口 Ctrl + Alt + 左括号（[） 在打开多个项目的情况下，切换上一个项目窗口 Ctrl + Shift 快捷键 介绍 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备） Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 （必备） Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 （必备） Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 （必备） Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 （必备） Ctrl + Shift + + 展开所有代码 （必备） Ctrl + Shift + - 折叠所有代码 （必备） Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 （必备） Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 （必备） Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 （必备） Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签 （必备） Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备） Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备） Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备） Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备） Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备） Alt + Shift 快捷键 介绍 Alt + Shift + N 选择 / 添加 task （必备） Alt + Shift + F 显示添加到收藏夹弹出层 / 添加到收藏夹 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备） Alt + Shift + 前方向键 移动光标所在行向上移动 （必备） Alt + Shift + 后方向键 移动光标所在行向下移动 （必备） Ctrl + Shift + Alt 快捷键 介绍 Ctrl + Shift + Alt + V 无格式黏贴 （必备） Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 （必备） Ctrl + Shift + Alt + C 复制参考信息 其他 快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 （必备） F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 （必备） F12 回到前一个工具窗口 （必备） Tab 缩进 （必备） ESC 从工具窗口进入代码文件窗口 （必备） 连按两次Shift 弹出 Search Everywhere 弹出层]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven的使用]]></title>
    <url>%2F2018%2F12%2F03%2FTools%2FMaven%2F</url>
    <content type="text"><![CDATA[Maven使用Maven安装与配置下载与安装Maven官网下载地址 在如下位置点击下载最新版本Maven的压缩包 解压文件得到apache-maven-xxx文件夹.xxx为版本号 新建环境变量MAVEN_HOME,变量值为maven根目录地址 打开环境变量设置的步骤为: 右击此电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 Win+R-&gt;sysdm.cpl-&gt;高级-&gt;环境变量 编辑环境变量path,添加%MAVEN_HOME%\bin\ 至此,maven安装完毕.打开命令提示符窗口(Win+R-&gt;cmd),输入mvn -v查询maven版本,检查maven是否成功安装.成功如图所示 配置创建maven仓库 如果不自行创建,maven将默认使用Default: ${user.home}/.m2/repository作为本地仓库 在想要作为maven仓库的地方创建文件夹maven-repository作为maven的本地仓库 打开maven安装根目录-&gt;conf-&gt;settings.xml 在&lt;settings&gt;标签下,找到&lt;localRepository&gt;标签.如果没有则自行添加. 修改值为本地仓库的地址,如&lt;localRepository&gt;C:\Maven\apache-maven-3.6.0\maven-repository&lt;/localRepository&gt; 修改下载镜像地址 将下载镜像更换为阿里云中央仓库,解决依赖从境外网站下载过慢的问题 打开maven安装根目录-&gt;conf-&gt;settings.xml 在&lt;settings&gt;标签下找到&lt;mirrors&gt;标签,添加如下代码 &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 保存即可 针对Maven添加依赖时没有自动提示的解决方案 到Maven仓库官网搜索,点击需要添加的依赖.复制&lt;dependency&gt;标签即可. Maven仓库官网 在IDEA中配置Maven 打开IDEA,settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 修改Maven home directory为maven安装根目录 勾选User settings file后的Override,然后修改为安装根目录-&gt;conf-&gt;settings.xml 勾选Local repository后的Override,然后修改为本地的repository地址 Maven项目结构 项目根目录/ src/ main/ 项目主体根目录 java 源代码目录 resources 所需资源目录 filters 资源过滤文件目录 assembly 组件的描述配置(如何打包) config 配置文件 wepapp web应用的目录.WEB-INF,css,js等 test/ 项目测试目录根 java 单元测试java源代码文件 resources 测试需要用的资源库 filters c测试资源过滤库 site Site一些文档 target/ 存放项目构建后的文件和目录.jar,war,编译的class文件等 pom.xml MMaven的pom文件 LICENSE.TXT 项目的LISENCE README.TXT 项目的README Maven生命周期 Maven生命周期执行顺序从上至下 每执行当前指令之前,会把之前(上方)的指令都执行一次 每执行当前周期之前会执行之前的生命周期 clean生命周期 清理项目 clean 描述 pre-clean 执行清理前需要完成的工作execute processes needed prior to the actual project cleaning clean 清理上一次构建生成的文件remove all files generated by the previous build post-clean 执行清理后需要完成的工作execute processes needed to finalize the project cleaning default生命周期 构建项目 default 描述 validate 验证工程是否正确,所需要的资源是否可用validate the project is correct and all necessary information is available compile 编译项目的源代码compile the source code of the project test 使用已编译的测试代码,测试已编译的源代码test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed package 采用编译的代码,并以其可分配格式(如JAR)进行打包take the compiled code and package it in its distributable format, such as a JAR. verify 运行所有检查,验证包是否有效且达到质量标准run any checks on results of integration tests to ensure quality criteria are met install 把包安装在本地的repository中,可以被其他工程作为依赖来使用install the package into the local repository, for use as a dependency in other projects locally deploy 在整合或者发布环境下执行,将最终版本的包拷贝到远程的repository,使得其他的开发者或者工程可以共享done in the build environment, copies the final package to the remote repository for sharing with other developers and projects. site生命周期 建立和发布项目站点 site 描述 pre-site 生成项目站点之前需要完成的工作execute processes needed prior to the actual project site generation site 生成项目站点文档generate the project’s site documentation post-site 生成项目站点之后需要完成的工作execute processes needed to finalize the site generation, and to prepare for site deployment site-deploy 将项目站点发布到服务器deploy the generated site documentation to the specified web server Maven默认生命周期 Default Lifecycle 生命周期阶段 描述 validate 验证 确保当前配置和 POM 的内容是有效的。这包含对 pom.xml 文件树的验证。 initialize 初始化 在执行构建生命周期的主任务之前可以进行初始化。 generate-sources 生成源码 代码生成器可以开始生成在以后阶段中处理或编译的源代码。 process-sources 处理源码 提供解析、修改和转换源码。常规源码和生成的源码都可以在这里处理。 generate-resources 生成资源 可以生成非源码资源。通常包括元数据文件和配置文件。 process-resources 处理资源 处理非源码资源。修改、转换和重定位资源都能在这阶段发生。 compile 编译 编译源码。编译过的类被放到目标目录树中。 process-classes 处理类 处理类文件转换和增强步骤。字节码交织器和常用工具常在这一阶段操作。 generate-test-sources 生成测试源码 mojo 可以生成要操作的单元测试代码。 process-test-sources 处理测试源码 在编译前对测试源码执行任何必要的处理。在这一阶段，可以修改、转换或复制源代码。 generate-test-resources 生成测试资源 允许生成与测试相关的（非源码）资源。 process-test-resources 处理测试资源 可以处理、转换和重新定位与测试相关的资源。 test-compile 测试编译 编译单元测试的源码。 process-test-classes 对测试编译生成的文件做后期处理(需Maven2.0.5及以上) test 测试 运行编译过的单元测试并累计结果。 prepare-package 执行打包前的所有操作(需Maven2.1及以上) package 打包 将可执行的二进制文件打包到一个分布式归档文件中，如 JAR 或 WAR。 pre-integration-test 前集成测试 准备集成测试。这种情况下的集成测试是指在一个受到一定控制的模拟的真 实部署环境中测试代码。这一步能将归档文件部署到一个服务器上执行。 integration-test 集成测试 执行真正的集成测试。 post-integration-test 后集成测试 解除集成测试准备。这一步涉及测试环境重置或重新初始化。 verify 检验 检验可部署归档的有效性和完整性。过了这个阶段，将安装该归档。 install 安装 将该归档添加到本地 Maven 目录。这一步让其他可能依赖该归档的模块可以使用它。 deploy 部署 将该归档添加到远程 Maven 目录。这一步让这个工件能为更多的人所用。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编程Tips]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2FTips%2F</url>
    <content type="text"><![CDATA[Tips代码技巧相关使用反射来动态加载资源如果在实际项目中,需要加载许多张图片,手动添加就会变得十分复杂.这时可以使用反射来动态加载.同时还降低了耦合度.事例代码如下: // 反射动态添加图片Field[] fields = R.drawable.class.getFields();int i = 0;for (Field field : fields) &#123; if (field.getName().startsWith("img_")) &#123; try &#123; imageList.add(new TestImage("第" + i++ + "张图", field.getInt(new R.drawable()))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;return imageList; 使用R.xxx.class.getXxx()方法来加载对应资源目录的对应变量或方法.例如R.drawable.class.getFields()就对应获取drawable目录下的所有资源. 使用getName()方法来获取资源的名称. getXxx(Object obj)方法用来获取资源id,参数Obeject是要从中提取表示字段的值的对象.即把字段的原始值包装为Object类型,最后会返回该Object. 通过Resources类的getIdentifier方法Resources res=getResources();return res.getIdentifier(type,"drawable",getPackageName()); getResources方法是来自于contenxt（也就是Activity类），它直接可以返回一个Resouces对象。而Resouces的getIdentifier方法可以返回R.java中的任何资源id，当然，你必须指定3个参数：字段名type,类名&quot;drawable&quot;,包名getPackageName(). 类名 类名则是资源所属的类.比如我们知道的,在R.java类中的几个固定的类：drawable、id、string、layout等,在它们下边又定义了许多资源id 字段名 字段名则是资源id的名字.比如del这个资源id定义:public static final int del=0x7f020002;del就是一个资源id的名字,0x7f020002则是它的16进制值 包名 指定全限定名的包名部分 （全限定名的定义如下： 类的全限定名 在常量池中， 一个类型的名字并不是我们在源文件中看到的那样， 也不是我们在源文件中使用的包名加类名的形式。 源文件中的全限定名和class文件中的全限定名不是相同的概念。 源文件中的全新定名是包名加类名， 包名的各个部分之间，包名和类名之间， 使用点号分割。 如Object类， 在源文件中的全限定名是java.lang.Object 。 而class文件中的全限定名是将点号替换成“/” 。 例如， Object类在class文件中的全限定名是 java/lang/Object 。 如果读者之前没有接触过class文件格式， 是class文件格式的初学者， 在这里不必知道全限定名在class文件中是如何使用的， 只需要知道， 源文件中一个类的名字， 在class文件中是用全限定名表述的。） 举个栗子：如果R 的全限定名为 android.R 或者 com.company.R，则包名在这里就是“android”或“com.company”。getPackageName其实是this.getPackageName()，它直接返回本类的包名。 gradle相关gradle中compile弃用,使用api指令和implement指令api 指令完全等同于compile指令，没区别，你将所有的compile改成api，完全没有错。 implement指令这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开 解决支持库版本兼容问题引用第三方的库版本低于(或不一致)app/build.gradle中的支持库版本,可能会出现以下问题: all com.android.support libraries must use the exact same version specification 解决方法 在app/build.gradle中添加以下代码 configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == 'com.android.support') &#123; if (!requested.name.startsWith("multidex")) &#123; details.useVersion '28.0.0' &#125; &#125; &#125;&#125; 这段代码含义为:使所有模块com.android.support都使用相同的支持库版本details.useVersion &#39;xxx.xx.x&#39; 实用工具,库Fresco-Adnroid加载图片 官网链接 简单使用案例,优化RecyclerView Glide加载图片官网链接 简单使用案例,优化GridView 简单使用不需要修改布局控件.只需要重写Adapter类,使用Glide.with(context).load(&quot;file://&quot;+urls.get(i)).into(vh.imageView);即可 需要在gradle中添加依赖 implementation &quot;com.github.bumptech.glide:glide:4.8.0&quot; 错误解决集锦Can’t resolve sysbol R1.在新建包中发生此类错误,clean project无效,rebuild project报错:”错误:程序包R不存在” 原因分析: 这种情况多发生于没有import **.R的情况,此时IDE会在当前包下寻找R “程序包R不存在“翻译一下为:您引用的R可能与包名不符，非包名路径下的文件可能需要写明 “import 包名.R”。请在查验包名正确后重试 解决方案: 在文件中import 包名(AndroidManifest中的).R,然后再build 如果这种文件少，也可先把报错的.java文件移动至于包名相同的目录进行调试]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment显示点击图片]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2FAndroidProject%2FAndroidProj-1%2F</url>
    <content type="text"><![CDATA[Fragment显示点击图片项目内容 应用显示一个大图,一行文字和一行可滚动的图片列表.点击图片列表项,可在上方大图切换为所点击的图片. 应用分为横屏和竖屏显示,横屏状态下不显示图片列表. 横竖屏切换时,大图的显示不会切换回默认.即需要保存切屏时的UI状态 项目主要文件 具体实现活动主界面配置竖屏布局&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".FragmentWorkTest.MyFragmentActivity"&gt; &lt;fragment android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/main_fragment" android:name="com.vnaso.integratedhomework.FragmentWorkTest.MainFragment"/&gt; &lt;fragment android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/list_fragment" android:name="com.vnaso.integratedhomework.FragmentWorkTest.ListFragment"/&gt;&lt;/LinearLayout&gt; 将界面分为两个fragment显示 main_fragment为大图和文字部分,它对应的类为MainFragment list_fragment为图片列表部分,它对应的类为ListFragment 横屏布局&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".FragmentWorkTest.MyFragmentActivity"&gt; &lt;fragment android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/main_fragment" android:name="com.vnaso.integratedhomework.FragmentWorkTest.MainFragment"/&gt;&lt;/LinearLayout&gt; 只有main_fragment,根据项目内容,横屏时只显示大图和文字,所以没有图片列表的fragment 此文件需放置在res/layout-land,若没有则需执行创建.该文件名字与竖屏时活动主界面布局文件相同,系统会自动根据手机是横屏还是竖屏状态加载相应的布局文件. 活动Activity配置public class MyFragmentActivity extends FragmentActivity&#123; private MainFragment mainFragment; private ListFragment listFragment; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_fragment); &#125; 在活动启动时负责加载活动布局 Fragment配置MainFragment配置&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;ImageView android:layout_width="300dp" android:layout_height="200dp" android:layout_gravity="center" android:layout_margin="10dp" android:id="@+id/img_main" android:src="@drawable/img_default"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/img_main_name" android:gravity="center" android:layout_margin="8dp" android:text="点击下列图片以显示"/&gt;&lt;/LinearLayout&gt; 用ImageView和TextView控件来显示大图和文字.并设置了默认的图片源和文字 public class MainFragment extends Fragment &#123; private View view; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; view = inflater.inflate(R.layout.main_frag,container,false); if(savedInstanceState!=null)&#123; String name = savedInstanceState.getString("imageName"); int resourceId = savedInstanceState.getInt("imageId"); if(name!=null &amp;&amp; resourceId != 0)&#123; refresh(name,resourceId); &#125; &#125; return view; &#125; public void refresh(String name,int resourceId)&#123; if(view!=null)&#123; ImageView mainImage = view.findViewById(R.id.img_main); TextView mainName= view.findViewById(R.id.img_main_name); // 使用glide库来管理图片 Glide.with(getContext()).load(resourceId).into(mainImage); mainName.setText(name); &#125;else &#123; Toast.makeText(getContext(),"view未被创建",Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onSaveInstanceState(@NonNull Bundle outState) &#123; super.onSaveInstanceState(outState); // 获取当前 ListFragment 的实例,来获取当前显示的大图的信息 ListFragment listFragment = (ListFragment)getFragmentManager().findFragmentById(R.id.list_fragment); outState.putString("imageName",listFragment.getSelectedImageName()); outState.putInt("imageId",listFragment.getSelectedImageId()); &#125;&#125; MainFragment继承Fragment,并重写onCreateView()方法.方法定义了从R.layout.main_frag来填充与当前类关联的fragment容器.并根据onSavedinstance是否为空来判断是否恢复数据,主要在横竖屏切换时起作用. Android中,当手机横竖屏切换时,会新创建一个Activity,之前数据不会在新建的Activity中显示 自定义了一个refresh()方法来刷新UI.主要帮助在另一个Fragment的图片列表点击时,显示相应的大图. 重写了onSavedInstanceState()方法,用来保存当前UI的数据,并用于数据恢复.主要在竖屏切换为横屏时起作用 ListFragment配置&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/img_list_recycler_view" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 用RecyclerView来显示图片列表 public class ListFragment extends Fragment &#123; // 标识是否是横屏 private boolean isLand; // 当前选中的图片信息 private String selectedImageName; private int selectedImageId; // 内部类 ImgAdapter class ImgAdapter extends RecyclerView.Adapter&lt;ImgAdapter.ViewHolder&gt; &#123; // Recycler要显示的list private List&lt;TestImage&gt; mImgList; // ViewHolderThere is no default constructor available i class ViewHolder extends RecyclerView.ViewHolder&#123; View imgView; TextView imgName; ImageView imgImage; public ViewHolder(View view)&#123; super(view); imgView = view; imgName = view.findViewById(R.id.img_name); imgImage = view.findViewById(R.id.img_image); &#125; &#125; // 构造方法,传入显示的数据源 public ImgAdapter(List&lt;TestImage&gt; imgList)&#123; mImgList = imgList; &#125; // 创建ViewHolder实例 @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; final View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.image_item,viewGroup,false); final ViewHolder holder = new ViewHolder(view); final MainFragment mainFragment = (MainFragment)getFragmentManager().findFragmentById(R.id.main_fragment); holder.imgView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 获取点击的对象的实例 int position = holder.getAdapterPosition(); TestImage testImage = mImgList.get(position); selectedImageName = testImage.getImgName(); selectedImageId = testImage.getImgId(); mainFragment.refresh(testImage.getImgName(), testImage.getImgId()); Toast.makeText(getContext(), testImage.getImgName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder; &#125; // 对RecyclerView子项进行赋值 @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int i) &#123; TestImage testImage = mImgList.get(i); viewHolder.imgImage.setImageResource(testImage.getImgId()); viewHolder.imgName.setText(testImage.getImgName()); &#125; // 获得RecyclerView子项的个数 @Override public int getItemCount() &#123; return mImgList.size(); &#125; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Configuration mConfiguration = this.getResources().getConfiguration(); //获取设置的配置信息 int ori = mConfiguration.orientation; //获取屏幕方向 if (ori == mConfiguration.ORIENTATION_LANDSCAPE) &#123; //横屏 isLand = true; &#125; else if (ori == mConfiguration.ORIENTATION_PORTRAIT) &#123; //竖屏 isLand = false; &#125; &#125; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.list_frag,container,false); RecyclerView recyclerView = view.findViewById(R.id.img_list_recycler_view); // 创建并添加 layoutManager LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity()); layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); recyclerView.setLayoutManager(layoutManager); // 初始化图片列表 ImgAdapter imgAdapter = new ImgAdapter(initImage()); recyclerView.setAdapter(imgAdapter); if(savedInstanceState!=null)&#123; MainFragment mainFragment = (MainFragment)getFragmentManager().findFragmentById(R.id.main_fragment); mainFragment.refresh(savedInstanceState.getString("imageName"),savedInstanceState.getInt("imageId")); &#125; return view; &#125; public List&lt;TestImage&gt; initImage() &#123; List&lt;TestImage&gt; imageList = new ArrayList&lt;&gt;(); // 反射动态添加图片 Field[] fields = R.drawable.class.getFields(); int i = 0; for (Field field : fields) &#123; if (field.getName().startsWith("img_")) &#123; try &#123; imageList.add(new TestImage("第" + i++ + "张图", field.getInt(new R.drawable()))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; return imageList; &#125; @Override public void onSaveInstanceState(@NonNull Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putString("imageName",selectedImageName); outState.putInt("imageId",selectedImageId); &#125; public String getSelectedImageName() &#123; return selectedImageName; &#125; public int getSelectedImageId() &#123; return selectedImageId; &#125;&#125; ListFragment把RecyclerView的适配器实现类ImgAdapter作为内部类,便于ImgAdapter获取ListFragment中的数据.简化了在点击RecyclerView子项时保存当前选中图片信息的操作. 继承了Fragment所以重写onCreateView()方法. 首先,将R.layout.list_frag作为填充内容放入到关联的fragment容器中. 然后初始化了RecyclerView. initImage()中使用了反射来动态加载drawable中符合添加条件的资源 最后根据onSavedInstanceState是否为空判断是否加载大图数据,主要在横屏切换为竖屏时起作用. RecyclerView配置&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;!--&lt;com.facebook.drawee.view.DraweeView--&gt; &lt;ImageView android:layout_width="80dp" android:layout_height="50dp" android:id="@+id/img_image" android:layout_margin="8dp" /&gt; &lt;TextView android:layout_width="80dp" android:layout_height="wrap_content" android:id="@+id/img_name" android:layout_margin="8dp" android:gravity="center"/&gt;&lt;/LinearLayout&gt; 定义每一个RecyclerView子项的布局,由一个图片和一行文字组成 适配器部分代码在ListFragment的配置中 遇到的问题及解决方法 使用getFragmentManager().findFragmentById()方法获取自定义的Fragment的子类时,需要向下转型.因为此方法返回的是Fragment类型,若不向下转型,则无法使用特有的方法. 无论是Activity还是Fragment,都有onSavedInstanceState(),若要保存数据,记得重写该方法.该方法保存的Bundle对象不共用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一行代码之Fragment]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2F%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2FFragment%2F</url>
    <content type="text"><![CDATA[FragmentFragment是一种可嵌入在活动当中的UI片段,能让程序更加合理和充分地利用大屏幕的空间. 使用方式简单用法 新建两个布局 新建一个LeftFragment类并继承自Fragment(强烈建议使用android.support.v4.app.Fragment包下的fragment,他可以让碎片在所有的Android系统版本中保持功能一致性) 重写Fragment的onCreateView()方法 public class LeftFragment extends Fragment&#123; @Override public View onCreatView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState)&#123; // 将刚才定义的布局动态加载进来 View view = inflater.inflate(R.layout.left_fragment,container,false); return view; &#125;&#125; 重复2~3,为另一个布局做同样工作. 在activity_main.xml中添加两个&lt;fragment&gt;控件,控件的android:name属性指定为新建的两个碎片类的全限定类名 动态添加碎片 在简单用法的基础上新建第三个布局,并为其创建类以及重写onCreateView() 修改activity_main.xml,将需要使用动态加载的&lt;fragment&gt;用&lt;FrameLayout&gt;替换.FrameLayout的所有控件默认都会摆放在布局的左上角,由于这里仅需要在布局里放入一个碎片,不需要定位,因此非常适合使用FrameLayout 在代码中向FrameLayout里添加内容,从而实现动态添加碎片的功能(注释代码为添加的代码) public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(this); // 动态添加RightFragment碎片// replaceFragment(new RightFragment()); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button:// replaceFragment(new AnotherRightFragment()); break; default: break; &#125; &#125; // replaceFragment具体实现// private void replaceFragment(Fragment fragment) &#123; // 获取FragmentManage// FragmentManager fragmentManager = getSupportFragmentManager(); // 开启事务// FragmentTransaction transaction = fragmentManager.beginTransaction(); // 向FrameLayout容器添加或替换碎片// transaction.replace(R.id.right_layout, fragment); // 是否将Fragment加入到返回栈// transaction.addToBackStack(null);// transaction.commit();// &#125;&#125; 动态添加碎片主要分为5步 创建待添加的碎片实例 获取FragmentManager,在活动中可以直接通过调用getSupportFragmentManager()方法得到 开启一个事务,通过调用beginTransaction()方法开启 向容器内添加或替换碎片,一般使用replace()方法实现,需要传入容器的id和待添加的碎片实例 提交事务,调用commit()方法来完成 FragmentTransaction中提供了一个addToBackStack()方法,可以将一个事务添加到返回栈中.它接收一个名字用于描述返回栈的状态,一般传入null即可. 碎片和活动之间进行通信碎片和活动都是各自存在于一个独立的类当中,他们之间并没有那么明显的方式来直接进行通信. 活动中获取碎片的实例 FragmentManager提供了一个类似于findViewById()的方法,专门用于从布局文件中获取碎片的实例,代码如下: RightFragment rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment); 调用此方法,可以在互动中得到相应碎片的实例,然后轻松调用碎片里的方法 碎片中获取活动的实例 在每个碎片中都可以通过调用getActivity()方法来得到和当前碎片相关联的活动实例 Mainactivity activity = (MainActivity)getActivity(); 另外当碎片中需要使用Context对象时,也可以使用getActivity()方法 动态布局加载技巧限定符符合条件的设备将加载对应限定符文件目录下的布局文件 屏幕特征 限定符 描述 大小 small 提供给小屏幕设备的资源 大小 normal 提供给中等屏幕设备的资源 大小 large 提供给大屏幕设备的资源 大小 xlarge 提供给超大屏幕设备的资源 分辨率 ldpi 提供给低分辨率设备的资源(120dpi以下) 分辨率 mdpi 提供给中等分辨率设备的资源(120dpi-160dpi) 分辨率 hdpi 提供给高分辨率设备的资源(160dpi-240dpi) 分辨率 xhdpi 提供给超高分辨率设备的资源(240dpi-320dpi) 分辨率 xxhdpi 提供给超超高分辨率设备的资源(320dpi-480dpi) 方向 land 提供给横屏设备的资源 方向 port 提供给竖屏设备的资源 最小宽度限定符在res目录下新建layout_swXXXdp,可以指定一个最小宽度值,然后以这个最小值为临界点,屏幕宽度大于这个值的设备就加载该目录下的布局(layout-swXXXdp/activiy_main),屏幕宽度小于这个值的设备则加载默认布局(layout/activiy_main) 碎片实战p170]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>Android Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一行代码之UI控件]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2F%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2FUI%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[UI控件常用控件 TextView Button EditText 通过findViewById()方法得到实例,然后调用getText()方法获取输入内容,在调用toString()方法转换成字符串 ImageView 通过android:src指定图片 ProgressBar 通过android:visibility指定,可选值有visible,invisible,gone.或setVisibility()方法传入常量值View.VISIBLE,View.INVISIBLE,View.GONE.android:max属性设定最大值 AlertDialog 通过AlertDialog.Builder builer = new AlertDialog.Builder(MainActivity.this);创建Builder实例使用setTitle,setMessage,setCancelable,setPositiveButton,setNegativeButton,来赋予属性.最后使用create()方法创建AlertDialog实例,再调用show()方法即可显示. ProgressDialog 通过ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);创建实例,其他方法类似于AlterDialog注意 如果setCancelable()中传入了false,表示ProgressDialog不能通过Back键取消掉.此时必须在某个时刻调用ProgressDialog的dismiss()方法来销毁 基本布局线性布局LinearLayout线性布局会将它说包含的控件在线性方向上依次排列,可通过android:orientation来设置vertical或horizontal.可以使用android:layout_weight来按比例指定控件大小 相对布局RelativeLayout相对布局可以通过相对定位的方式让控件出现在布局的任何位置,通过对控件添加属性可完成对控件的布局 属性 参数 描述 android:layout_alignParentTop true/false 和父布局顶部对齐 android:layout_alignParentRight true/false 和父布局右端对齐 android:layout_centerInParent true/false 和父布局中心对齐 android:layout_toLeftOf 控件的id的引用 使控件位于引用控件的左侧 android:layout_above 控件的id的引用 使控件位于引用控件的上方 android:layout_below 控件的id的引用 使控件位于引用控件的下方 这些属性可以结合使用,以实现不同的定位 帧布局FrameLayout帧布局的所有控件都默认摆放在布局的左上角,通过android:layout_gravity来设置对齐方式,left,right,center,top,bottom.这些属性可用|链接一起使用,例如:right|top右上角对齐 百分比布局百分比布局只为FrameLayout和RelativeLayout进行了功能扩展,提供了PercentFrameLayout和PercentRelativeLayout两个布局 百分比布局需要在项目的build.gradle中添加百分比布局库的依赖,在app/build.gradle文件的dependencies闭包中添加compile &#39;com.android.support:percent:24.2.1&#39; 每当修改了任何gradle文件时,Android Studio会提示需要同步修改后的gradle1,点击Sync Now即可 百分比布局中,可为控件添加属性app:layout_widthPercent和app:layout_heightPercent分别设置布局长宽的百分比值.使用app需要在布局中定义一个app的命名空间 &lt;android:support.percent.PercentFrameLayout &lt;!-- 此处省略其他设置 --&gt; xmlns:app="http://schema.android.com/apk/res-auto"&gt;&lt;/android:support.percent.PercentFrameLayout&gt; 自定义布局引入布局使用引入布局来减少重复的布局代码 使用方法 在一个布局下,通过&lt;include layout = &quot;@Layout/xxx&quot;&gt;来引入指定名称的xml布局文件 自定义布局如果不居中有一些控件要求能够响应事件,我们还是需要在每个活动中为这些空间单独编写一次事件注册代码,比如说标题栏中的返回按钮,不管在哪一个活动中,这个按钮的功能都是相同的.而如果每个活动中都要重新注册一遍返回按钮的点击事件,无疑会增加很多重复代码,这种情况下最好是使用自定义控件的方式解决 新建TitleLayout继承自LinearLayout,让它称为我们自定义的标题栏控件 public class TitleLayout extends LinearLayout&#123; public TitleLayout(Context context,AttributeSet attrs)&#123; super(context,attrs); // 指定加载的布局是R.layout.title,父布局是TitleLayout=this LayoutInflater.from(context).inflate(R.layout.title,this); &#125;&#125; 重写LinearLayout中带有两个参数的构造函数,在布局中引入TitleLayout控件就会调用这个构造函数,然后借助LayoutInflater的from()方法构建出一个LayoutInflater对象调用inflate()方法来对R.layout.title布局进行动态加载.inflate()方法需要传入两个参数,第一个参数是要加载的布局文件的id,第二个参数是给加载好的布局再添加一个父布局 在布局文件中添加自定义文件 &lt;LinearLayout ...&gt; &lt;com.example.TitleLayout android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; 必须指明自定义控件的完整类名,包名不可以省略 为按钮添加注册点击事件 Button titleBack = (Button)findViewById(R.id.title_back);titleBack.setOnclickListener(new OnClickListener()&#123; @Override public void onClick(View v)&#123; // do same thing &#125;&#125;); 这样,每当在一个布局中引人自定义控件时,控件的点击事件就已经自动实现好了(默认使用写好的onClick()方法),省去重复冗余的代码 ListView当程序中有大量数据需要展示时,可以借助ListView实现,ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内,同时屏幕上原有的数据则会滚动出屏幕 定制ListView 定义一个实体类,作为ListView适配器的适配类型,需要有getter方法 为ListView的子项创建一个自定义的布局 创建一个自定义的适配器,该适配器继承来自ArrayAdapter,并将泛型指定为实体类 public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt;&#123; private int resourceId; public FruitAdapter(Context context,int textViewResourceId,List&lt;Fruit&gt; objects)&#123; super(context,textViewResourceId,objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position,View convertView,ViewGroup parent)&#123; // 获取当前项的实例 Fruit fruit = getItem(position); View view; // 为当前项加载传入的布局,false表示不为这个View添加父布局,否则无法添加到ListView中 if(convertView == null)&#123; view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); &#125;else&#123; view = convertView; &#125; TextView fruitName = (TextView)view.findViewById(R.id.fruit_name); fruitName.setText(fruit.getName); return view; &#125;&#125; FruitAdapter重写了父类的一组构造函数,用于将上下文,ListView子项布局的id和数据都传递进来.另外重写getView(),这个方法在每个子项被滚动到屏幕内的时候都会被调用 if代码段用于优化ListView的加载,防止了在每一次调用getView()方法时都将布局重新加载一遍.原理是getView()方法中传入的convertView`可以将之前加载好的布局进行==缓存==,以便之后可以进行调用 LayoutInflater的inflate(int resourceId,ViewGroup root,boolean attachToRoot)方法接收3个参数,第一个参数为要填充的xml文件的id,第二个参数为从第一个参数填充成的view对象的父控件,意义是为第一个参数生成的View对象的根布局提供一些列LayoutParams参数的控件,第三个参数表示第一个参数填充成的View对象是否要附着到第二个参数指定的空间上作为子控件 接下来为每个View设置属性,并将布局返回.这样就完成了自定义的适配器 创建自定义的适配器对象,并把适配器传递给ListView,就完成了定制ListView界面 initFruits(); // 初始化包含所有列表项的ListFruitAdapter adapter = new FruidAdapter(MainActivity.this,R.layout.fruit_item,fruitList);ListView listView = (ListView)findViewById(R.id.list_view);listView.setAdapter(adapter); 使用ViewHolder进行优化public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt;&#123; private int resourceId; public FruitAdapter(Context context,int textViewResourceId,List&lt;Fruit&gt; objects)&#123; super(context,textViewResourceId,objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position,View convertView,ViewGroup parent)&#123; // 获取当前项的bean实例 Fruit fruit = getItem(position); View view; ViewHolder viewHolder; // 为当前项加载传入的布局,false表示不为这个View添加父布局,否则无法添加到ListView中 if(convertView == null)&#123; view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); viewHolder = new ViewHolder(); viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_name); // 将ViewHolder存储在View中 view.setTag(viewHolder); &#125;else&#123; view = convertView; // 通过View重新获取ViewHolder viewHolder = (ViewHolder)view.getTag(); &#125; fruitName.setText(fruit.getName); return view; &#125;&#125;class ViewHolder&#123; TextView fruitName;&#125; 新增一个内部类ViewHolder,用于对控件的实例进行缓存,当convertView为null的时候创建一个ViewHolder对象,并将控件的实例全部存放在ViewHolder中,当convertView不为null时,调用getTag()方法取出ViewHolder,这样所有的控件都缓存在ViewHolder里,从而避免了每次都通过findViewById()方法来获取控件的实例 ListView的点击事件ListView listView = (ListView)findViewById(R.id.list_view);listView.setOnClickListener(new AdapterView.OnItemClickListener()&#123; @Override public void onClick(AdapterView&lt;?&gt; parent,View view,int position,long id)&#123; Fruit fruit = fruitList.get(position); // do something &#125;&#125;); 使用setOnItemClickListener()方法为ListView注册一个监听器,当点击ListView中任何一个子项时,就会回调onItemClick()方法,通过position参数判断出用户点击的是哪一个子项,接着获取到相对应的对象 RecyclerView要使用REcyclerView控件,需要在项目的build.gradle中添加相应的依赖库 在app/build.gradle文件的dependencies闭包中添加implementation&#39;com.android.support:design:26.1.0&#39;或者implementation&#39;com.android.support:recyclerview-v7:26.1.0&#39;,并在添加完之后点击Sync Now进行同步.前者中的design包含后者中的recyclerview-v7模块(功能更加齐全) 定义一个实体类,作为RecyclerView适配器的适配类型,需要有getter方法 为RecyclerView的子项创建一个自定义的布局 为RecyclerView创建一个适配器FruitAdapter继承自RecyclerView.Adapter,并将泛型指定为FruitAdapter.ViewHolder public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private List&lt;Fruit&gt; mFruitList; // 静态类,只在第一次加载外部类时加载一次 static class ViewHolder extends RecyclerView.ViewHolder&#123; TextView fruitName; // 此处传入的view一般是RecyclerView子项的最外层布局 public ViewHolder(View view)&#123; super(view); fruitName = (Text)view.findViewById(R.id.fruit_name); &#125; &#125; // 用于传入要显示的数据源 public FruitAdapter(List&lt;Fruit&gt; fruitList)&#123; mFruitList = fruitList; &#125; // 用于创建ViewHolder实例 @Override public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); ViewHolder holder = new ViewHolder(view); return holder; &#125; // 用于对RecyclerView子项的数据进行赋值 @Override public void onBindViewHolder(ViewHolder holder,int position)&#123; Fruit fruit = mFruitList.get(position); holder.fruitName.setText(fruit.getName()); &#125; // 用于获得RecyclerView的子项个数 @Override public int getItemCount()&#123; return mFruitList.size(); &#125;&#125; 定义了一个内部类ViewHolder,ViewHolder继承自RecyclerView.ViewHolder然后ViewHolder的构造函数传入一个View参数,这个参数通常是RecyclerView子项的最外层布局,之后便可以通过findViewById得到布局中的View实例 因继承自RecyclerView.Adapter,所以必须重写onCreateViewHolder(),onBindViewHolder()和getItemCount()方法. onCreateViewHolder(ViewGroup parent,int viewType)用于创建ViewHolder实例.在方法中加载RecyclerView的子项fruit_item布局,然后用加载出来的布局创建一个ViewHolder实例返回 onBindViewHolder()方法用于对RecyclerView子项的数据进行赋值,会在每个子项被滚动到屏幕内的时候执行,通过position参数获得当前项的实例 getItemCount()方法用于告诉RecyclerView一共有多少个子项 使用RecyclerView private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;();initFruits(); // 初始化RecyclerView子项数据RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);// 创建一个LinearLayoutManager对象LinearLayoutManager layoutManager = new LinearLayoutManager(this);// 指定RecyclerView的布局方式为 LinearLayoutrecyclerView.setLayoutManager(layoutManager);FruitAdaper adapter = new FruitAdapter(fruitList);recyclerView.setAdapter(adapter); 创建一个LinearLayoutManager对象,并将它设置到RecyclerView当中.LayoutManager用于指定RecyclerView的布局方式 RecyclerView工作原理 横向滚动和瀑布流布局 横向滚动 创建一个LinearLayoutManager对象,并将方向设置为水平,再把它设置到RecyclerView当中 layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL) 瀑布流 RecyclerView提供了三种内置布局排列方式:LinearLayoutManager,GridLayoutManager和StaggeredGridLayoutManager StaggerGridLayoutManager瀑布流布局的宽度是根据布局的列数来自动适配,而不是固定值 StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL); StaggeredGridLayoutManager的构造函数接收两个常熟,第一个参数是用于指定布局的列数,第二个参数用于指定布局的排列方向 点击事件RecyclerView没有提供类似于setOnItemClickListener()这样的注册监听器的方法,而需要自己给子项具体的View去注册点击事件 public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private List&lt;Fruit&gt; mFruitList; // 静态类,只在第一次加载外部类时加载一次 static class ViewHolder extends RecyclerView.ViewHolder&#123; View fruitView; TextView fruitName; // 此处传入的view一般是RecyclerView子项的最外层布局 public ViewHolder(View view)&#123; super(view); fruitView = view; fruitName = (Text)findViewById(R.id.fruit_name); &#125; &#125; // 用于传入要显示的数据源 public FruitAdapter(List&lt;Fruit&gt; fruitList)&#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); final ViewHolder holder = new ViewHolder(view); // 为fruitView注册点击事件 holder.fruitView.setOnClickListerner(new View.OnClickListerner()&#123; @Override public void onClick(View v)&#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); // do something &#125; &#125;); return holder; &#125;&#125; 在ViewHolder中添加fruitView变量来保存子项最外层的布局实例,然后在`onCreateViewHolder()方法中注册点击事件即可 GridViewGridView简略流程图 在使用GridView时,同样也需要传入一个适配器.如果需要加载过多的图片时,推荐自行重写一个类继承自BaseAdapter)或SimpleAdapter. BaseAdapter子类需要重写实现的方法简介 android中的适配器Adapter是数据与视图View之间的桥梁,用于对要显示的数据进行处理,并通过绑定到组件进行数据的显示. BaseAdapter是Android应用程序中经常用到的基础数据适配器的基类，它实现了Adapter接口。其主要用途是将一组数据传到像ListView、Spinner、Gallery及GridView等UI显示组件进行显示.我们经常使用的ListView的adapter,即SimpleAdapter,是继承自BaseAdapter基类的。BaseAdapter是一个基类,没有实现绑定数据的功能.而SimpleAdapter实现了基本控件的绑定,如TextView,Button,ImageView等。并已经为我们实现好了数据优化工作。 getCount():决定了我们将要绘制的资源数,当然这个数目不能大于资源的总数,不过却可以小于资源的总数. How many items are in the data set represented by this Adapter. getItem(int position):getItem方法不是在Baseadapter类中被调用的,而是在Adapterview.getItemAtPosition(position)中被调用的.getItemAtPosition(position)是在setOnItemClickListener,setOnItemLongClickListener、setOnItemSelectedListener的点击选择处理事件中方便地调用来获取当前行数据的. Get the data item associated with the specified position in the data set. getItemId(int position):该方法的返回值决定第position处的列表项的ID,某些方法(如onclicklistener的onclick方法)有id这个参数,而这个id参数就是取决于`这个返回值的 Get the row id associated with the specified position in the list. getView(int position, View convertView, ViewGroup parent):通过传入的参数position,加工成我们想要的View并返回 Get a View that displays the data at the specified position in the data set. onItemClick方法onItemClick()方法位于Adapter.OnItemClickListener,OnItemClickListener是静态内部接口. class里面的interface都是static的 public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; // 实现点击响应事件&#125; AdapterView&lt;?&gt; parent 当前被点击的View，如果你是为ListView加入的Listener,那么当前的View就是ListView View view 每次点击Item的View int position 每次点击Item的位置,默认从0开始 long id 每次点击Item的id(注意:加入的headerView是 -1),没有headerView时(默认情况下)，position与id是一样的 UI实战应用p146]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>Android UI控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GridView实现的连连看]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2FAndroidProject%2FAndroidProj-2%2F</url>
    <content type="text"><![CDATA[GridView实现的连连看项目内容设计完成一个8*9的连连看小游戏。要求 具备25种不同的连连看动物（或其他图标） 当手指点击相同的动物，动物消失 当手指点击不同的动物，动物不消失 图标出现的时候是随机出现的 可以设置不同的难度，不同难度级别对应不同的动物种类数量，难：25种，中等,15种，简单10种 遵守连连看规则，如果图片无阻塞的方能连接（可以不出现关联的线段） 具备胜负判断、打乱重拍的功能 在界面上点击右键菜单，选择打乱重拍功能 系统选项菜单中可以选择难度 在导航中可以切换显示游戏说明和游戏界面以及参数设置界面 项目结构 具体实现MainActivityMainActivity布局内容&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/container" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" &gt; &lt;FrameLayout android:id="@+id/container_fragment" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id="@+id/navigation" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginStart="0dp" android:layout_marginEnd="0dp" android:background="?android:attr/windowBackground" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:menu="@menu/navigation" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 搭建页面切换的雏形 BottomNavigationView配合ConstraintLayout使用,完成下方导航栏的布局. FrameLayout用来作为fragment的容器. MainActivity.java配置package com.vnaso.picmatch;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.design.widget.BottomNavigationView;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.support.v7.app.AppCompatActivity;import android.view.MenuItem;public class MainActivity extends AppCompatActivity &#123; private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener = new BottomNavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.navigation_home: replace(new RuleFragment()); return true; case R.id.navigation_dashboard: replace(new ViewFragment()); return true; case R.id.navigation_notifications: replace(new SettingFragment()); return true; &#125; return false; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); BottomNavigationView navigation = findViewById(R.id.navigation); navigation.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener); replace(new RuleFragment()); &#125; // 切换页面视图 private void replace(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.container_fragment, fragment); fragmentTransaction.commit(); &#125; public void reload(Fragment fragment) &#123; replace(fragment); &#125;&#125; 类加载时添加一个OnNavigationItemSelectedListener监听器,监听BottomNavigationView的子项的点击事件,并实现切换到对应的页面. 重写onCreate()方法,在方法中使用findViewById实例化了BottomNavigationView.并给BottomNavigationView的类对象设置了监听器. replace()方法在这里用来实现打开应用时,默认加载一个fragment 编写了两个成员方法 replace()-用于切换fragment reload()-用于给其他fragment提供刷新页面的方法(可能不是最好的解决方法) RuleFragmentRuleFragment布局内容&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/settings_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="2dp" android:gravity="center" android:padding="2dp" android:text="游戏规则" android:textSize="15pt" android:textStyle="bold" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="5dp" android:background="#c9c9c9" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="40dp" android:gravity="center" android:text="只有非完全封闭的方块才能消除" android:textSize="40sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="5dp" android:background="#c9c9c9" /&gt; &lt;TextView android:id="@+id/settings_rule" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:text="剩下的 I DO NOT KNOW !" android:textSize="40sp" /&gt;&lt;/LinearLayout&gt; 没啥好说的,新学到的知识:使用一个&lt;View&gt;添加android:background属性,实现线条的效果 RuleFragment.java内容package com.vnaso.picmatch;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class RuleFragment extends Fragment &#123; private View view; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; super.onCreateView(inflater, container, savedInstanceState); view = inflater.inflate(R.layout.rule_fragment, container, false); return view; &#125;&#125; 没有要实现的东西,所以只初始化了布局.(说法可能不恰当) SettingFragmentSettingFragment布局内容&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/settings_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="2dp" android:gravity="center" android:padding="2dp" android:text="游戏设置" android:textSize="15pt" android:textStyle="bold" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="5dp" android:background="#c9c9c9" /&gt; &lt;RadioGroup android:id="@+id/difficulty_selector" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="5dp" android:layout_weight="1" android:text="难度" android:textSize="15sp" android:textStyle="bold" /&gt; &lt;RadioButton android:id="@+id/difficulty_hard" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="5dp" android:layout_weight="1" android:background="@null" android:button="@null" android:drawableStart="@drawable/radio" android:drawablePadding="10dp" android:text="Hard" android:textSize="20sp" /&gt; &lt;RadioButton android:id="@+id/difficulty_medium" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="5dp" android:layout_weight="1" android:background="@null" android:button="@null" android:drawableStart="@drawable/radio" android:drawablePadding="10dp" android:text="Medium" android:textSize="20sp" /&gt; &lt;RadioButton android:id="@+id/difficulty_easy" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="5dp" android:layout_weight="1" android:background="@null" android:button="@null" android:drawableStart="@drawable/radio" android:drawablePadding="10dp" android:text="Easy" android:textSize="20sp" /&gt; &lt;/RadioGroup&gt; &lt;Button android:id="@+id/difficulty_confirm" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:text="确认" /&gt;&lt;/LinearLayout&gt; 要点1:使用RadioButton时要以RadioGroup为父标签,才能作为一个单选组 要点2:RadioButton如果要使图标和文字之间有间距,则需要设置android:button属性为@null,转而使用android:drawableStart(推荐)或android:drawableLeft来设置图标.这时android:drawablePadding才能生效. radio.xml编写如下: &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/ic_check_true" android:state_checked="true" /&gt; &lt;item android:drawable="@drawable/ic_check_false" android:state_checked="false" /&gt;&lt;/selector&gt; android:drawable用来设置图标资源,android:state_checked用来设置图标应用于哪种选择状态. SettingFragment.java内容package com.vnaso.picmatch;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.Toast;public class SettingFragment extends Fragment &#123; private View view; private Button mbtn_confirm; private RadioGroup mrg_difficulty_selector; private RadioButton mrb_difficulty_hard; private RadioButton mrb_difficulty_medium; private RadioButton mrb_difficulty_easy; private String difficulty = null; private static final String TAG = "SettingFragment"; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; super.onCreateView(inflater, container, savedInstanceState); view = inflater.inflate(R.layout.settings_fragment, container, false); mbtn_confirm = view.findViewById(R.id.difficulty_confirm); mrg_difficulty_selector = view.findViewById(R.id.difficulty_selector); mrb_difficulty_hard = view.findViewById(R.id.difficulty_hard); mrb_difficulty_medium = view.findViewById(R.id.difficulty_medium); mrb_difficulty_easy = view.findViewById(R.id.difficulty_easy); mbtn_confirm.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (difficulty != null) &#123; Log.d(TAG, "onClick: " + "GAME_DIFFICULTY: " + difficulty); ViewFragment.GAME_DIFFICULTY = difficulty; &#125; else &#123; Toast.makeText(getContext(), "请选择难度", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); mrg_difficulty_selector.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; if (mrb_difficulty_hard.getId() == checkedId) &#123; difficulty = mrb_difficulty_hard.getText().toString(); &#125; else if (mrb_difficulty_medium.getId() == checkedId) &#123; difficulty = mrb_difficulty_medium.getText().toString(); &#125; else if (mrb_difficulty_easy.getId() == checkedId) &#123; difficulty = mrb_difficulty_easy.getText().toString(); &#125; &#125; &#125;); return view; &#125;&#125; 实例化了布局文件中的RadioGroup和RadioButton以及Button,并为它们Button添加了点击事件监听器 为RadioButton添加了选择状态变化监听器,将当前选中的标签所表示的难度值赋给了私有变量difficulty,作为难度值保存起来. 为Button添加了点击事件监听器,当点击Button时,如果已经通过点击RadioButton选择了难度,就会将难度传递给ViewFragment,否则就弹出Toast提醒选择难度. ViewFragment(主要)ViewFragment布局内容view_fragment.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;GridView android:id="@+id/gridview" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="3dp" android:horizontalSpacing="3dp" android:numColumns="8" android:verticalSpacing="3dp" /&gt; &lt;Button android:id="@+id/rebuild" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_alignParentBottom="true" android:layout_marginBottom="60dp" android:text="重玩" /&gt; &lt;TextView android:id="@+id/show_difficulty" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_centerHorizontal="true" android:layout_marginBottom="75dp" android:text="游戏难度:" /&gt; &lt;Button android:id="@+id/surrender" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentLeft="true" android:layout_alignParentBottom="true" android:layout_marginBottom="60dp" android:text="认输" /&gt;&lt;/RelativeLayout&gt; 主要包含了一个GridView用来显示游戏界面,2个Button提供重玩和认输功能,TextView显示当前游戏难度. ViewFragment.java内容(主要)package com.vnaso.picmatch;import android.content.DialogInterface;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.AdapterView;import android.widget.Button;import android.widget.GridView;import android.widget.ImageView;import android.app.AlertDialog;import android.widget.TextView;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;public class ViewFragment extends Fragment implements AdapterView.OnItemClickListener &#123; private static final String TAG = "ViewFragment"; private View view; private GridView gridView; private ArrayList&lt;HashMap&lt;String, Integer&gt;&gt; imgList = new ArrayList&lt;&gt;(); private int imgSelected = 0; private ImageView view1 = null; private ImageView view2 = null; private int positionSelected1 = -1; private int positionSelected2 = -1; public static String GAME_DIFFICULTY = "Easy"; private int[][] gameMatrix = new int[11][10]; private int totalNumber; @Nullable @Override public View onCreateView(@NonNull final LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; super.onCreateView(inflater, container, savedInstanceState); view = inflater.inflate(R.layout.view_fragment, container, false); gridView = view.findViewById(R.id.gridview); initImg(72); initMatrix(gameMatrix); ImageAdapter imageAdapter = new ImageAdapter(getContext(), imgList); gridView.setAdapter(imageAdapter); gridView.setOnItemClickListener(this); TextView textView = view.findViewById(R.id.show_difficulty); textView.setText("游戏难度:" + GAME_DIFFICULTY); Button rebuild = view.findViewById(R.id.rebuild); rebuild.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; MainActivity activity = (MainActivity) getActivity(); activity.reload(new ViewFragment()); &#125; &#125;); Button surrender = view.findViewById(R.id.surrender); surrender.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext()); builder.setIcon(R.mipmap.ic_launcher); builder.setTitle("失败了!"); builder.setMessage("是否重新来？"); builder.setPositiveButton("好！", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MainActivity activity = (MainActivity) getActivity(); activity.reload(new ViewFragment()); &#125; &#125;); builder.setNegativeButton("溜了溜了", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MainActivity activity = (MainActivity) getActivity(); activity.finish(); &#125; &#125;); builder.create().show(); &#125; &#125;); return view; &#125; // 初始化图片 private void initImg(int amount) &#123; if (amount % 2 != 0 || amount &lt; 0) &#123; throw new IllegalArgumentException("输入了不恰当的生成数量!"); &#125; totalNumber = amount; // 根据难度设置总图案数 int types = 25; switch (GAME_DIFFICULTY) &#123; case "Hard": types = 25; break; case "Medium": types = 15; case "Easy": types = 10; &#125; // 遍历drawable中的资源,获取以img开头的需要的图片资源,添加到imgList中 // 根据难度动态加载图片种数 ArrayList&lt;HashMap&lt;String, Integer&gt;&gt; imgRes = new ArrayList&lt;&gt;(); Field[] fields = R.drawable.class.getFields(); try &#123; int i = 0; for (Field field : fields) &#123; if (i &gt;= types) break; if (field.getName().startsWith("img")) &#123; HashMap&lt;String, Integer&gt; item = new HashMap&lt;&gt;(); item.put("img", field.getInt(new R.drawable())); imgRes.add(item); i++; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 根据难度生成包含指定数量图片的imgList // 数量小于等于图片种数*2 if (amount / 2 &lt;= types) &#123; for (int i = 0; i &lt; amount / 2; i++) &#123; imgList.add(imgRes.get(i)); imgList.add(imgRes.get(i)); &#125; &#125; else if (amount / 2 &gt; types) &#123; // 数量大于图片种数*2 for (int i = 0; i &lt; types; i++) &#123; imgList.add(imgRes.get(i)); imgList.add(imgRes.get(i)); &#125; for (int i = types; i &lt; amount / 2; i++) &#123; int rd = (int) (Math.random() * imgRes.size()); imgList.add(imgRes.get(rd)); imgList.add(imgRes.get(rd)); &#125; &#125; // 打乱顺序 Collections.shuffle(imgList); Log.d(TAG, "initImg: success!"); &#125; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; HashMap&lt;String, Integer&gt; item = imgList.get(position); int resId = item.get("img"); if (imgSelected == 0 &amp;&amp; view1 == null &amp;&amp; positionSelected1 == -1) &#123; imgSelected = resId; view1 = view.findViewById(R.id.img); positionSelected1 = position; // 点击添加选中效果 view1.setBackgroundResource(R.drawable.ic_check_false); &#125; else &#123; positionSelected2 = position; view2 = view.findViewById(R.id.img); if (imgSelected == resId &amp;&amp; view1 != null &amp;&amp; positionSelected1 != positionSelected2 &amp;&amp; view2.getDrawable() != null &amp;&amp; view1.getDrawable() != null &amp;&amp; isRemovable(positionSelected1, positionSelected2)) &#123; view1.setImageDrawable(null); view2.setImageDrawable(null); totalNumber -= 2; if (totalNumber == 0) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext()); builder.setIcon(R.mipmap.ic_launcher); builder.setTitle("胜利了!"); builder.setMessage("恭喜你!"); builder.create().show(); &#125; Log.d(TAG, "onItemClick: \n" + show(gameMatrix)); &#125; imgSelected = 0; // 移除所有选中的状态+ view1.setBackgroundResource(0); view1 = null; view2 = null; positionSelected1 = -1; positionSelected2 = -1; &#125; &#125; // 初始化判断矩阵 private void initMatrix(int[][] matrix) &#123; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; if (i == 0 || i == matrix.length - 1) &#123; // 第一行全为0,最后一行全为0 matrix[i][j] = 0; &#125; else if (j == 0 || j == matrix[i].length - 1) &#123; // 第一列全为0,最后一列全为0 matrix[i][j] = 0; &#125; else &#123; matrix[i][j] = 1; &#125; &#125; &#125; Log.d(TAG, "initMatrix: \n" + show(matrix)); &#125; // 打印二维数组 private String show(int[][] gameMatrix) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; gameMatrix.length; i++) &#123; for (int j = 0; j &lt; gameMatrix[i].length; j++) &#123; sb.append(" ").append(gameMatrix[i][j]).append(" "); &#125; sb.append("\n"); &#125; return sb.toString(); &#125; // 判断是否可移除 private boolean isRemovable(int position1, int position2) &#123; Log.d(TAG, "onItemClick: 当前点击的position是:" + position1 + "和" + position2); // 元素的行 int pos1 = (position1 / 8) + 1; // 元素的列 int pos2 = (position1 % 8) + 1; Log.d(TAG, "isRemovable: pos1,pos2:" + pos1 + "和" + pos2); if (gameMatrix[pos1 - 1][pos2] == 0 || gameMatrix[pos1][pos2 - 1] == 0 || gameMatrix[pos1 + 1][pos2] == 0 || gameMatrix[pos1][pos2 + 1] == 0) &#123; // 元素的行 int pos3 = (position2 / 8) + 1; // 元素的列 int pos4 = (position2 % 8) + 1; Log.d(TAG, "isRemovable: pos3,pos4:" + pos3 + "和" + pos4); if (gameMatrix[pos3 - 1][pos4] == 0 || gameMatrix[pos3][pos4 - 1] == 0 || gameMatrix[pos3 + 1][pos4] == 0 || gameMatrix[pos3][pos4 + 1] == 0) &#123; gameMatrix[pos3][pos4] = 0; &#125; else &#123; return false; &#125; gameMatrix[pos1][pos2] = 0; &#125; else &#123; return false; &#125; return true; &#125;&#125; onCreateView()方法中完成所有控件的实例化以及监听器的设置. rebuild按钮的点击事件为刷新当前页面.通过MainActivity mainActivity = (MainActivity)getActivity();获取到MainActivity,再调用提供的reload()方法,实现刷新页面的效果. surrender按钮的点击事件为显示一个AlertDialog提示用户选择:投降重新开始游戏或结束程序.在AlertDialog.Builder的PositiveButton和NegativeButton的点击事件中分别实现了重新开始游戏和结束程序的功能.然后调用builder.create().show()方法显示AlertDialog. initImg()方法实现了初始化游戏元素的功能.根据当前游戏的难度和已有的资源图片数量来决定如何加载游戏元素.并使用了Collections工具了的shuffle方法来将排序打乱,达到随机效果. 在有大量图片需要重复操作进行加载时,推荐使用反射机制来将所有需要的资源放在数组或集合中,极大程度方便了资源的获取.本代码中就使用了此方法. onItemClick()方法是在GrivView子项点击时调用.在这里结合isRemovable()方法完成点击消除的逻辑判断和实现.在方块全部消除完成时,构造一个AlertDialog来提示游戏胜利. 具体判断逻辑为: 如果此次点击事件之前没有选择任何方块,则在imgSelected中存入此次点击的item的view的资源id.在positionSelected存入此次点击的item的position,用于排除点击同一item多次的情况.在view1中保存此次点击的view,并为其添加选中的效果 如果此次点击事件之前有选择方块,则在view2中存入此次点击view,方便之后消除方块.在positionSelected2中存入此次点击的item的position. 判断此次点击的方块和已选择的方块是否可消除. 如果可以消除,使用view1和view2将图片消除(setImageDrawable(null)) 剩余方块数量totalNumber的值-2,如果运算后为0,则弹出游戏胜利,否则继续 如果不可以消除,继续. 所有属性重新初始化,回到没有方块选中的状态. initMatrix()方法是用来初始化一个判断矩阵. isRemovable()方法传递两个GridView点击的子项的position参数.通过position参数将点击的子项转化到判断矩阵中,再通过逻辑判断两个子项是否非完全封闭,并返回逻辑判断结果. ImageAdapterImageAdapter.java内容package com.vnaso.picmatch;import android.content.Context;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.LinearLayout;import com.bumptech.glide.Glide;import java.util.ArrayList;import java.util.HashMap;public class ImageAdapter extends BaseAdapter &#123; private Context context; private ArrayList&lt;HashMap&lt;String, Integer&gt;&gt; imgList; public ImageAdapter(Context context, ArrayList&lt;HashMap&lt;String, Integer&gt;&gt; imgList) &#123; this.context = context; this.imgList = imgList; &#125; public void setImgList(ArrayList&lt;HashMap&lt;String, Integer&gt;&gt; imgList) &#123; this.imgList = imgList; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getCount() &#123; return imgList.size(); &#125; @Override public Object getItem(int position) &#123; return imgList.get(position); &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; class ViewHolder &#123; LinearLayout game_item; ImageView imageView; &#125; ViewHolder vh = null; if (convertView == null) &#123; convertView = LayoutInflater.from(context).inflate(R.layout.game_item, null); // 初始化ViewHolder vh = new ViewHolder(); vh.imageView = convertView.findViewById(R.id.img); vh.game_item = convertView.findViewById(R.id.game_item); // 将ViewHolder保存到convertView convertView.setTag(vh); &#125; vh = (ViewHolder) convertView.getTag(); if (imgList != null &amp;&amp; imgList.size() &gt; 0) &#123; Glide.with(context).load(imgList.get(position).get("img")).centerCrop().into(vh.imageView); &#125; return convertView; &#125;&#125; ImageAdapter继承了BaseAdapter类,带有两个私有成员变量context上下文和imgList保存游戏图片元素的HashMap数组.重写了getItemId(),getCount(),getItem()以及getView()方法. getItenId()返回的是该position对应的item的id.该方法的返回值决定第position处的列表项的ID,某些方法（如onclicklistener的onclick()方法）有id这个参数，而这个id参数就是取决于getItemId()这个返回值的. getCount()决定了我们将要绘制的资源数，当然这个数目不能大于资源的总数，不过却可以小于资源的总数。加入我们adapter管理的资源总共有10个，而我们通过getCount()返回的只有6个，那么最终`绘制出来的将只有6个 getItem()方法不是在Baseadapter类中被调用的，而是在Adapterview.getItemAtPosition(position)中被调用的.而getItemAtPosition(position) 则是在setOnItemClickListener(),setOnItemLongClickListener(),setOnItemSelectedListener()的点击选择处理事件中方便地调用来获取当前行数据的 getView()我们主要通过该方法,使用传入的参数position,convertView和parent来将成我们想要的View进行修改，最终返回一个View供GridView使用. 在方法内部使用ViewHolder的设计思路,定义了一个ViewHolder内部类,用来定义及保存要返回的view中的控件.将item的布局填充到convertView中,构造出要显示在GridView中的View.在使用Glide库的方法结合position为item加载优化后的图片后,返回convertView.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
        <tag>GridView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一行代码之活动]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2F%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2F%E6%B4%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[活动活动注册声明所有Activity都要在AndroidManifest.xml里注册,否则无法在项目中使用 &lt;manifest xmlns:"..." package="PACKAGE_NAME"&gt; &lt;application android:allowBackup="true" // 应图标 android:icon="@mipmap/ic_launcher" // 活动中标题栏内容 android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; // 对活动进行注册,全包名,这里是因为上文指定了包路径 &lt;activity android:name=".FirstActivity"&gt;&lt;/activity&gt; // 指定当前活动能够响应的action和category &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="andoird.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/application&gt;&lt;/manifest&gt;### onCreate()方法项目中任何活动都应该重写`Activity`的`onCreate()`方法```java@Overridepretected void onCreate(Bundle saveInstaceState)&#123; super.onCreate(savedInstaceState);&#125; 创建和加载布局在xml中使用@id+/id_name为元素添加id 在onCreate()方法中调用setContentView()来给当前的活动加载一个布局,该方法中传入一个布局文件的id,通过调用R.layout.布局文件名来将值传入setContentView()方法 ToastToast是Android系统提供的一种非常好的提醒方式,在程序中可以使用它将一些短小的信息通知给用户,不占用任何屏幕空间Toast.makeText(Context packageContext,String str,Toast.LENGTH_SHORT).show();先通过静态方法创建出一个Toast对象,然后调用show()将Toast显示出来 第一个参数是Context,即Toast要求的上下文,一般传入活动本身即可;第二个参数时Toast显示的文本内容;第三个参数是Toast显示的时长 在活动中使用menu 在res目录下新建一个menu文件夹,res-&gt;New-&gt;Directory 右击menu-&gt;New-&gt;Menu resource file 使用&lt;item&gt;标签创建菜单项 &lt;item &lt;!-- 设置id --&gt; android:id="@+id/item_name" &lt;!-- 给该菜单项指定一个名称 --&gt; android:title="TITLE"/&gt; 在onCreateOptionsMenu()中创建菜单 public boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().inflate(R.menu.main,menu); return true;&#125; 通过getMenuInflater()得到MenuInflater对象,再调用它的inflate()方法来创建菜单.返回true表示允许创建的菜单显示出来,false创建的菜单将无法显示 定义菜单响应事件 重写onOptionsItemSelected()方法 public boolean onOptionsItemSeleted(MenuItem item)&#123; // 通过调用getItemId()来判断我们点击的是哪一个菜单项 switch(item.getItemId())&#123; case ...: // do something &#125; return true;&#125; Intent 显式Intent Intent有多个构造函数的重载,其中一个是Intent(Context packageContext,Class&lt;?&gt; cls),第一个参数为启动活动的上下文,第二个参数Class则是指定想要启动的目标活动,通过这个构造函数即可构造出Intent的”意图”.然后使用Activity类中提供的一个startActivity(Intent intent)方法来启动活动 Intent intent = new Intent(MainActivity.this,AnotherActivity.class);startActivity(intent); 隐式Intent 通过在AndroidManifest.xml中的下配置的内容,指定当前活动能够响应的action和category &lt;intent-filter&gt; &lt;action android:name="com.example.activitytest.ACTION_START" /&gt; &lt;category android:name="android:intent.category.DEFAULT" /&gt;&lt;/intent-filter&gt; 注意: 每个Intent中只能指定一个action,但能指定多个category 调用Intent中的addCategory()方法来添加一个category intent.addCategory("com.example.activitytest.MY_CATEGORY"); 如果activity下intent-filter中有声明这个category,则会响应该Intent 隐式Intent启动其他程序的活动 Intent intent = new Intent(Intent.ACTION_VIEW);intent.setDate(Uri.parse("http://www.baidu.com"));startactivity(intent); 这里Intent的action是Intent.ACTION_VIEW,这是系统内置的工作,常量值为android.intent.action.VIEW,然后通过Uri.parse()方法将一个网址字符串解析成一个对象,再调用Intent的setDate()方法将这个Uri对象传递进去 在&lt;intent-filter&gt;标签中配置一个&lt;data&gt;标签,可以更加精确地指定当前活动能够响应什么类型的数据 &lt;data android:scheme=&quot;http&quot; /&gt;可以响应所有http协议的intent 向下一个活动传递数据使用Intent提供的一系列putExtra()方法的重载,把想要传递的数据暂存在Intent中,启动另外一个活动后,再通过getIntent()方法获取Intent,然后利用getStringExtra()等方法来获取传递的数据.setResult方法接收两个参数,第一个参数用于向上一个活动返回处理结果,一般使用RESULT_OK或RESULT_CANCELED,第二个参数则传入需要返回的Intent Intent intent = new Intent();intent.putExtra("data_return","Hello world");set(RESULT_OK,intent); 返回数据给上一个活动 传递数据 Activity中的startActivityForResult()方法期望在活动销毁时返回一个结果给上一个活动.方法第一个参数是Intent,第二个参数为请求码,用来在上一个活动的接收返回数据的方法中识别是从哪一个Activity返回的数据 Intent intent = new Intent(FirstActivity.this,SecondActivity.class);startActivityForResult(intent,1); 接收数据 使用startActivityForResult()启动的Activity被销毁之后会回调上一个活动的onActivityResult()方法,所以需要重写这个方法来得到返回的书 @Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; switch(requestCode)&#123; case 1: if(resultCode == RESULT_OK)&#123; String returnedData = data.getStringData("data_return"); &#125; break; &#125;&#125; onActivityResult()方法有三个参数,第一个参数requestCode即在启动活动时传入的请求码,第二个参数resultCode即返回数据时传入的处理结果,第三个参数data即带有返回数据的Intent 注意: 为了防止用户通过按下Back键返回到上一个Activity,需要重写onBackPressed()来完成数据的传递 @Overridepublic void onBackPressed()&#123; Intent intent = new Intent(); ... finish();&#125; 保存,恢复临时数据 保存数据 onSaveInstanceState(Bundle outState)方法携带一个Bundle类型的参数,Bundle提供了一系列方法用于保存数据. `putString()`-&gt;保存字符串.`putInt()`-&gt;保存整型...每个方法传入两个参数,第一个是`键`,用于从`Bundle`中取值;第二个是要保存的数据. @Overrideprotected void onSaveInstanceState(Bundle outState)&#123; super.onSaveInstanceState(outState); String tempData = "put something"; outState.putString("data_key",tempData);&#125; getString()-&gt;根据key取字符串 getInt()-&gt;根据key取整型 恢复数据 在onCreate()方法中会传入一个Bundle类型的参数,一般情况下都是null. 但是如果在活动被系统回收之前有通过onSaveInstanceState()方法保存数据的话,这个参数就会带有之前所保存的数据 传送数据 可结合Intent一起用于传递数据 把需要传递的数据保存在Bundle对象中 将Bundle对象存放在Intent里 在目标活动中从Intent中取出Bundle,再从中一一取出数据 活动的启动模式通过在AndroidManifest.xml中&lt;activity&gt;标签下添加属性android:launchMode设置 &lt;activity android:launchMode="singleTop"&lt;/activity&gt; standard(默认) 在standard模式下,每当启动一个新的活动,它就会在返回栈中入栈,并处于栈顶.每次启动都会创建该活动的一个新的实例 singleTop 在singleTop模式下,启动活动时如果发现返回栈的栈顶已经是该活动,则认为可以直接使用它,而不再创建新的活动实例 singleTask 在singleTask模式下,每次启动活动时,系统首先会在返回栈中检查是否存在该活动实例,若发现存在则直接使用该实例,并把在该活动之上的所有活动通通出栈,如果没发现,则创建新的实例 singleInstance 指定为singleInstance的活动会启用一个新的返回栈来管理这个活动 如果singleTask模式指定了不同的taskAffinity,也会启动一个新的返回栈 意义用于与其他程序共享调用该活动实例.在这种模式下会有一个单独的返回栈来管理这个活动,不管是哪个应用程序访问这个活动,都共用的同一个返回栈,实现共享活动 活动实战技巧知晓当前所在的活动 新建一个BaseActivity类,然后继承AppCompatActivity并重写onCreate()方法 public class BaseActivity extends AppCompatActivity&#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); // 获取当前实例的类名,并用Log打印出来 **Log.d("BaseActivity",getClass().getSimpleName());** &#125;&#125; 让BaseActivity替代AppCompatActivity,修改之前继承了AppCompatActivity的类的继承结构,让它们继承自BaseActivity BaseActivity继承自AppCompatActivity,所以所有活动现有功能不受影响 随时随地快捷退出程序 核心思路:用一个专门的集合类对所有的活动进行管理 新建一个ActivityCollector类作为活动管理器 通过List来暂存活动,然后提供活动的增删和销毁方法 public class ActivityCollector&#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); // 添加活动到活动管理器中 public static void addActivity(Activity activity)&#123; activites.add(activity); &#125; // 从活动管理器中删除活动 public static void removeActivity(Activity activity)&#123; activities.remove(activity); &#125; // 销毁活动管理器中的所有活动 public static void finishAll()&#123; for(Activity activity : activities)&#123; if(!activity.isFinishing())&#123; activity.finish(); &#125; &#125; &#125;&#125; 在BaseActivity的onCreate()方法中调用ActivityCollector的addActivity()方法将正在创建的活动添加到活动管理器中 在BaseActivity的onCreate()方法中调用ActivityCollector的removeActivity()方法将一个马上要销毁的活动从活动管理器中移除 无论在什么地方,要想退出程序,只需要调用ActivityCollector.finishAll()方法就可以 为保证程序完全退出,可以添加杀掉进程的代码 android.os.Process.killProcess(android.os.Process.myPid()); 其中killProcess()方法用于杀掉一个进程,它接收一个进程id参数,可以通过myPid()方法获得当前程序的进程id. killProcess()方法只能用于杀掉当前程序的进程,而不能用这个方法杀掉其他程序 启动活动的最佳写法在需要启动的目标活动中新建一个actionStart()方法,在这个方法中完成Intent的构建,最后调用startActivity()方法启动目标活动.好处在于目标活动所需要的数据在方法中一目了然 // 目标活动public class TargetActivity extends AppCompatActivity&#123; public static void actionStart(Context context,String data1,String data2)&#123; Intent intent = new Intent(context,TargetActivite.class); intent.putExtra("param1",data1); intent.putExtra("param2",data2); context.startActivity(intent); &#125;&#125;// 启动目标活动TargetActivity.actionStart(StartActivity.this,"data1","data2");]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>Android 活动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一行代码之广播机制]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2F%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[广播机制广播机制简介Android中的广播分为两种类型:标准广播和有序广播 标准广播:是一种完全异步执行的广播.在广播发出之后,所有的广播接收器几乎都会在听一时刻接收到这条广播消息,没有先后顺序可言,同事意味着无法被截断. 有序广播:是一种同步执行的广播.在广播发出后,同一时刻只有一个广播接收器能够接收到这条广播消息.当这个广播接收器的逻辑执行完毕后,广播才会继续传递.所以有先后顺序,优先级高的广播接收器可以先接收到广播消息,并且前面的广播接收器可以阶段正在传递的广播. 接收系统广播注册广播监听器动态注册(代码中注册)public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager;// private IntentFilter intentFilter;//// private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);// intentFilter = new IntentFilter();// intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");// networkChangeReceiver = new NetworkChangeReceiver();// registerReceiver(networkChangeReceiver, intentFilter); localBroadcastManager = LocalBroadcastManager.getInstance(this); // 获取实例 Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST"); localBroadcastManager.sendBroadcast(intent); // 发送本地广播 &#125; &#125;); intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST"); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册本地广播监听器 &#125; @Override protected void onDestroy() &#123; super.onDestroy();// unregisterReceiver(networkChangeReceiver); localBroadcastManager.unregisterReceiver(localReceiver); &#125; class LocalReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show(); &#125; &#125;// class NetworkChangeReceiver extends BroadcastReceiver &#123;//// // 当网络状态发生变化时,方法就会得到执行// @Override// public void onReceive(Context context, Intent intent) &#123;// ConnectivityManager connectionManager = (ConnectivityManager)// getSystemService(Context.CONNECTIVITY_SERVICE);// NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();// if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123;// Toast.makeText(context, "network is available",// Toast.LENGTH_SHORT).show();// &#125; else &#123;// Toast.makeText(context, "network is unavailable",// Toast.LENGTH_SHORT).show();// &#125;//// &#125;//// &#125;&#125; 在MainActivity中定义了一个内部类NetworkChangeReceiver,这个类是继承自BroadcastReceiver,并重写了父类的onReceive()方法. 在onReceiver()方法中,通过getSystemService()方法得到了ConnectivityManager的实例,这是一个系统服务类.专门用于管理网络连接的.调用其getActiveNetworkInfo()方法可以判断出当前是否有网络. 注意:访问系统的网络状态需要声明权限.在AndroidManifest.xml中&lt;manifest&gt;标签下添加如下权限: &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; onCreate()方法中,创建了一个IntentFilter实例,并给它添加了一个android.net.conn.CONNECTIVITY_CHANGE的action.网络状态发生变化时就会发出该值的广播.所以想让广播接收器监听什么广播,就要添加响应的action 创建了一个NetworkChangeReceiver的实例,调用registerReceiver()方法进行注册.将NetworkChangeReceiver的实例和IntentFilter的实例都传进去.表明NetworkChangeReceiver会收到值为android.net.conn.CONNECTIVITY_CHANGE的广播,也就实现了监听网络变化的功能 注意:动态注册的广播接收器一定要取消注册,可以在onDestroy()方法中通过调用unregisterReceiver()方法来实现的 静态注册(AndroidManifest.xml)在AndroidStudio中快捷创建广播接收器:New-&gt;Other-&gt;Broadcast Receiver 详细设置 Exported属性表示允许广播接收器接收本程序以外的广播,Enabled属性表示是否启用这个广播接收器 修改onReceive()功能 public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "Boot Complete", Toast.LENGTH_LONG).show(); &#125;&#125; 静态的广播接收器一定要在AndroidManifest.xml中注册才可以使用.如果使用快捷方式创建的广播接收器,会自动完成这一步. &lt;receiver android:name=".BootCompleteReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="com.example.broadcasttest.MY_BROADCAST"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; 通过android:name指定具体注册哪一个广播接收器,enabled和exported属性则根据快捷创建时的勾选自动生成. 通过添加监听开机广播权限和相应的action,完成程序开机自动启动功能. &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;... &lt;application&gt; &lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt; 注意:不要在onReceive()方法中添加过多的逻辑或者进行任何的耗时操作,因为在广播接收器中是不允许开启线程的.当onReceive()方法运行了较长时间而没有结束时,程序就会报错. 发送自定义广播发送标准广播 新建一个MyBroadcastReceiver类继承自BroadcastReceiver,重写onReceiver()方法. 在AndroidManifest.xml中对这个广播接收器进行修改. &lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.broadcasttest.MY_BROADCAST" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 这里在&lt;intent-filter&gt;中添加了一条值为com.example.broadcasttest.MY_BROADCAST的广播. 构建Intent对象,把要发送的广播的值传入,然后调用了Context的sendBroadcast()方法将广播发送出去.此时所有监听对应广播的广播接收器就会收到消息,此时发出的就是一条标准广播. Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST");localBroadcastManager.sendBroadcast(intent); // 发送标准广播 发送有序广播 操作同发送标准广播的1,2步骤,创建一个BroadcastReceiver子类并在AndroidManifest.xml对其进行修改它能够监听的广播. 使用sendOrderedBroadcast()方法发送广播.该方法接收两个参数,第一个参数是Intent,第二个参数是与权限相关的字符串,一般传入null即可 Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST");localBroadcastManager.sendOrderedBroadcast(intent); // 发送有序广播 通过修改&lt;intent-filter android:priority=&quot;100&quot;&gt;中的priority的值来设置广播接收器的先后顺序 在onReceive()方法中调用abortBroadcast()方法,就可以将这条广播截断 使用本地广播为了能够简单地解决广播的安全性问题,Android引入了一套本地广播机制,使用这个机制发出的广播只能够在应用程序的内部进行传递. private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); // 获取实例 Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST"); localBroadcastManager.sendBroadcast(intent); // 发送本地广播 &#125; &#125;); intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST"); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册本地广播监听器 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); localBroadcastManager.unregisterReceiver(localReceiver); &#125; class LocalReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show(); &#125; &#125; 使用了一个LocalBroadcastManager来对广播进行管理,并提供了发送广播和注册广播接收器的方法. 首先是通过LocalBroadcastManager的getInstasnce()方法得到了一个他的实例,然后在注册广播接收器的时候调用的是LocalBroadManager的registerRecevier()方法,在发送广播的时候调用的是LocalBroadcastManager的sendBroadcast()方法. 注意:本地广播无法通过静态注册的方式来接收的.]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>Android 广播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一行代码之Android项目结构]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%2F%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%2F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[项目结构 .gradle和.idea 这两个目录下放置的都是Android Studio自动生成的一些文件 app build 主要包含一些编译时自动生成的文件 libs 存放第三方jar包,放在该目录下的jar包都会自动添加到构建路径里去 androidTest 用来编写AndroidTest测试用例,可以对项目进行一些自动化测试 java 项目中使用到的所有图片,字符,布局,字符串等资源都要存放在这个目录下. AndroidManifest.xml 整个Android项目的配置文件,在程序中定义的四大组件都需要在这个文件里注册,另外还可以在这个文件中给应用程序添加权限声明 test 用来编写Unit test测试用例 .gitignore 用于将app模块内的指定的目录或文件排除在版本控制之外 app.iml IDEA项目自动生成文件,无须关心 build.gradle app模块的gradle构建脚本,该文件会指定很多项目相关的配置 // 表明这是一个应用程序模块,可直接运行// 'com.android.library'表明库模块,作为代码库依附于别的应用程序模块apply plugin: 'com.android.application'android&#123; // 指定项目的编译版本 compileSdkVersion 24 // 指定项目构建工具的版本 buildToolsVersion "24.0.2" // 对项目更多细节进行配置 defaultConfig&#123; // 指定项目的包名 applicationId "com.example.helloworld" // 指定项目最低兼容的Android版本 minSdkVersion 25 // 指定推荐版本,表明在目标版本上已经做过充分测试,系统将会为你的应用程序启用一些新的功能 targetSdkVersion 24 // 指定项目的版本号 versionCode 1 // 指定项目的版本名 versionName "1.0" &#125; // 指定生成安装文件的相关配置 // 通常只有两个子闭包 // `release` 指定生成正式版安装文件的配置 // `debug` 指定生成测试版安装文件的配置 buildTypes&#123; release&#123; // 指定是否对项目进行混淆 minifyEnabled false // 指定混淆时使用的规则文件 proguardFiles getDefaultProguardFile ('proguard-android.txt'),// 所有项目通用的混淆规则 'proguard-rules.pro'// 当前项目特有的混淆规则 &#125; &#125;&#125;// 指定当前项目所有的依赖关系// 三种依赖方式：本地依赖,库依赖和远程依赖// 本地依赖 - 对本地Jar包或目录添加依赖关系// 库依赖 - 对项目中的库模块添加依赖关系// 远程依赖 - 对jcenter库上的开源项目添加依赖关系dependencies&#123; // 本地依赖声明 compile fileTree(dir: 'libs',include:['*.jar']) // 远程依赖声明 compile 'com.android.support:appcompat-v7:24.2.1' testCompile 'junit:junit:4.12' // 库依赖格式 // compile project + 依赖的库名称&#125; proguard-rules.pro 用于指定项目代码的混淆规则 build 包含了一些在编译时自动生成的文件 gradle 该目录下包含了gradle wrapper的配置文件,自动根据本地缓存的情况决定是否需要联网下载gradle.Android Studio默认没有启用gradle wrapper的方式,如果需要打开,可以通过点击Android Studio导航栏-&gt;File-&gt;Settings-&gt;Build,Excution,Deployment-&gt;Gradle,进行配置更改 .gitignore 将指定的目录或文件排除在版本控制之外 build.gradle项目全局的gradle构建脚本 buildscript&#123; repositories&#123; // 代码仓库,可以在项目中轻松引用jcenter上的开源项目 jcenter() &#125; dependencies&#123; // 使用classpath声明一个Gradle插件 // 用该插件来构建Android项目 classpath 'com.android.tools.build:gradle:2.2.0' &#125;&#125;allprojects&#123; repositories&#123; // 代码仓库,可以在项目中轻松引用jcenter上的开源项目 jcenter() &#125;&#125; gradle.properties 全局的gradle配置文件 gradlew 和gradlew.bat 用来在命令行中执行gradle命令,gradlew用于Linux或Mac系统,gradlew.bat用在Windows系统 local.properties 用于指定本机中的AndroidSDK路径,通常内容都是自动生成的,除非本机的SDK位置发生了变化,则需要修改为新的位置 settings.gradle 用于指定项目中所有引入的模块,通常情况下模块的引入都是自动完成的]]></content>
      <categories>
        <category>Android</category>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>Android 项目结构</tag>
      </tags>
  </entry>
</search>
