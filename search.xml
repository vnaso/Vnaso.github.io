<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 多线程]]></title>
    <url>%2F2019%2F03%2F17%2FJavaLearning%2FJavaNote%2FJava%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[重要概念异步和同步同步和异步通常用来形容一次方法的调用, 同步方法调用一旦开始, 调用者必须在调用返回后才能继续后续的行为. 异步方法调用更像一个消息传递, 一旦开始, 方法调用就会立即返回, 调用者可以继续后续的工作. 并发和并行它们都可以表示两个或以上任务一起执行, 但并发偏重多个任务交替执行, 而并行是真正意义上的”同时执行”. 多线程在单核 CPU 中是交替执行(并发), 在多核 CPU 中, 因为每个 CPU 有自己的运算器, 所以在多个 CPU 中可以同时运行(并行). 高并发高并发互联网分布式系统架构设计中必须考虑的因素之一, 通常指设计保证系统能够同时并行处理大量请求. 高并发常用的一些指标有: 响应时间(Response Time), 吞吐量(Throughput), 每秒查询率(QPS), 并发用户数等. 临界区临界区用来表示一种公共资源或者说是共享数据, 可以被多个线程使用. 但是每一次, 只能有一个线程使用它, 一旦临界区资源被占用, 其他线程想要使用这个资源, 就必须等待. 在并行程序中, 临界区资源是保护的对象. 阻塞和非阻塞非阻塞指在不能立刻得到结果之前, 该函数不会阻塞当前进程, 而会立刻返回, 而阻塞与之相反. 多线程使用的常见三种方式 继承 Thread 类, 重写父类 run() 方法 12345678910111213public class thread1 extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println("我是线程"+this.getId()); &#125; &#125; public static void main(String[] args) &#123; thread1 th1 = new thread1(); thread1 th2 = new thread1(); th1.start(); th2.start(); &#125;&#125; 实现 Runnable 接口 12345678910111213141516171819202122public class thread2 implements Runnable &#123; public String ThreadName; public thread2(String tName)&#123; ThreadName = tName; &#125; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(ThreadName); &#125; &#125; public static void main(String[] args) &#123; // 创建一个Runnable接口实现类的对象 thread2 th1 = new thread2("线程A:"); thread2 th2 = new thread2("线程B:"); // 将此对象作为形参传递给Thread类的构造器中，创建Thread类的对象，此对象即为一个线程 Thread myth1 = new Thread(th1); Thread myth2 = new Thread(th2); // 调用start()方法，启动线程并执行run()方法 myth1.start(); myth2.start(); &#125;&#125; 通过 Callable 和 Future 创建线程 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask; public class CallableThreadTest implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception&#123; int i = 0; for(;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; return i; &#125; public static void main(String[] args)&#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++)&#123; System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i); if(i==20)&#123; new Thread(ft,"有返回值的线程").start(); &#125; &#125; try&#123; System.out.println("子线程的返回值："+ft.get()); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (ExecutionException e)&#123; e.printStackTrace(); &#125; &#125;&#125; Runnable 和 Callable 的对比 Callable 规定重写 call(), Runnable 规定重写 run(). Callable 的任务执行后可返回值, Runnable 的任务没有返回值. call() 方法可以抛出异常, run() 方法不可以 运行 Callable 任务可以得到一个 Future 对象, 表示异步计算的结果, 提供了检查计算是否完成的方法, 以等待计算的完成, 并检查计算的结果. 通过 Future 对象还可以了解任务的执行情况, 可以取消任务的执行, 还可以获取执行结果. 线程生命周期 线程状态 新建状态: 新建线程对象, 没有调用 start() 之前. 就绪状态: 调用 start() 方法之后线程就进入就绪状态, 但是并不是说只要调用 start() 方法, 线程就马上变为当前线程, 在变为当前线程之前都是为就绪状态. 运行状态: 线程被设置为当前线程, 获得 CPU 后, 开始执行 run() 方法, 即线程进入运行状态. 阻塞状态: 处于运行状态的线程, 会因为系统对资源的调度而被中断进入阻塞状态. 死亡状态: 处于运行状态的线程, 当它主动或者被动结束后, 线程就处于死亡状态. 线程控制 join(): 等待. 阻塞调用此方法时所在的线程并释放锁, 让调用该方法的线程完成才继续执行. sleep(): 睡眠. 让当前的正在执行的线程暂停指定的时间, 并进入阻塞状态. yield(): 线程让步. 将线程从运行状态转换为就绪状态. 当某个线程调用 yield() 方法从运行状态转换到就绪状态后, CPU 会从就绪状态线程队列中只选择与该线程优先级相同, 或优先级更高的线程执行. setPriority(): 改变线程的优先级. 参数 priorityLevel 范围在 1-10 之间. 常用的静态常量值有: MAX_PRIORITY = 10, MIN_PRIORITY = 1, NORM_PRIORITY = 5. 具有较高优先级仅表示此线程具有更多的执行机会, 而并非会优先执行. 优先级还有继承性. setDaemon(true): 设置为守护线程. 守护进程主要为其他线程提供服务. JVM 中的垃圾回收线程, 但所有的前台线程都进入死亡状态时, 守护线程会自动死亡. 必须在 start() 之前执行, 否则会抛出 IllegalThreadStateEcxeption. 在守护线程中产生的新线程也是守护线程. 不是所有的任务都可以分配给守护线程来执行, 如: 读写操作或计算逻辑. 实例变量和线程安全 线程类中实例变量针对其他线程可以有共享和不共享之分 123456MyThread a = new MyThread("A");MyThread b = new MyThread("B");MyThread c = new MyThread("C");a.start();b.start();c.start(); 以上这种情况, 线程的变量不会共享 12345678SharedVariableThread mythread = new SharedVariableThread();// 下列线程都是通过mythread对象创建的Thread a = new Thread(mythread, "A");Thread b = new Thread(mythread, "B");Thread c = new Thread(mythread, "C");a.start();b.start();c.start(); 而这种情况下, a, b, c 线程共享 mythread 线程的变量 多线程分类 用户进程: 运行在前台, 执行具体的任务. 如: 程序的主线程, 连接网络的子线程. 守护线程: 运行在后台, 为其他前台线程服务. 如: 垃圾回收线程 特点: 一旦所有用户线程都结束运行, 守护形成会随 JVM 一起结束工作. 应用: 数据库连接池中的检测线程, JVM 虚拟机启动后的检测线程 synchronized 关键字 Java 并发编程领域中, synchronized 关键字一直都是元老级别的角色. 在 JDK1.6 之前, synchronized 的性能比 ReenTrantLock 差很多. 而在 JDK1.6 之后, JVM 团队对 synchronized 关键字做了很多优化, 主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁. synchronized 和 ReenTrantLock 的性能基本是持平了. synchronized 可以保证方法或者代码块在运行时, 同一时刻只有一个方法可以进入到临界区, 同时它还可以保证共享变量的内存可见性. synchronized 主要有一下三个作用: 保证互斥性, 保证可见性, 保证顺序性. 线程安全非线程安全 问题存在于 实例变量中, 如果是方法内部私有成员变量, 则不存在 非线程安全 问题. 如果连个线程同时操作对象中的实例变量, 则会出现 非线程安全, 解决办法就是在方法前加上 synchronized 关键字即可. 使用场景 synchronized 锁重入可重入锁 含义是: 自己可以再次获取自己内部的锁. 比如一个线程获得了某个对象的锁, 此时这个对象还没有释放, 当其再次想要获取这个对象的锁时, 还是可以获取的, 如果不可重入的话, 就会造成死锁. 可重入锁也支持在父子类继承的环境当中. 对象头synchronized 用的锁是存在 Java 对象头中的. 如果对象是数组类型, 则虚拟机用 3 个字宽(Word)存储对象头, 如果对象是非数组类型, 则用 2 个字宽存储对象头. 长度 内容 说明 32/64bit Mark Word 存储对象的 hashcode 或 锁信息 32/64bit Class Metadata Address 存储到对象类型数据的指针 32/32bit Array length 数组的长度(如果当前对象是数组) 32位虚拟机对象头的存储结构 64位虚拟机对象头的存储结构 对象监视器(monitor) 每个对象都有自己的监视器, 当这个对象由同步块或者这个对象的同步方法调用时, 执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法. 没有获取到监视器的进程将被阻塞在同步块和同步方法的入口处, 进入 BLOCKED 状态. 任意线程对 Object 的访问, 首先要获得 Object 的监视器, 如果获取失败, 该线程就要进入同步队列, 线程变为 BLOCKED, 当 Object 的监视器占有者释放后, 在同步队列中的线程就有机会重新获取该监视器. Monitor 是线程私有的数据结构, 每个线程有一个可用的 monitor record 列表, 同时还有一个全局的可用列表. 每一个被锁住的对象都会和一个 monitor 关联(对象头的 Mark Word 中的 Lock Word 指向 Monitor 的起始地址), 同时 Monitor 中有一个 owner 字段存放拥有该锁的线程的唯一标识, 标识该锁被这个线程占用, 结构如下: Owner: 初始时为 Null, 表示当前没有任何现场拥有该 Monitor Record, 当线程成功拥有该锁后, 保存线程唯一表示, 当锁被释放时, 又设置为 Null. EntryQ: 关联一个系统互斥锁, 阻塞所有视图锁住 Monitor Record 失败的线程. RcThis: 表示 BLOCKED 或 waiting 在该 Monitor Record 上的所有线程的个数. Nest: 用来实现重入锁的计数. HashCode: 保存从对象头拷贝过来的 HashCode 值 Cadidate: 用来避免不必要的阻塞或等待线程唤醒, 因为每一次只有一个线程能够成功拥有锁, 如果每次前一个释放锁的线程唤醒所有阻塞或等待的线程, 会引起不必要的上下文切换(从阻塞到就绪然后因为竞争锁失败又被阻塞)从而导致的性能下降. Candidate 只有两种可能的值: 0 表示没有需要唤醒的线程, 1 表示要唤醒的一个继任线程来竞争锁. volatile 关键字在 JDK1.2 之前, Java 的内存模型实现总是从主存(共享内存)中读取变量, 是不需要进行特别注意的. 而现在的 Java 内存模型下, 线程可以把变量保存到 本地内存(机器的寄存器)中, 而不是直接在主存中进行读写. 这可能导致一个线程在主存中修改了一个变量的值, 而另外一个线程继续使用它在寄存器中的变量值的拷贝, 造成数据不一致. JVM 在空闲时会尽力保证变量值的更新, 把主存中的数据读取到工作内存中. 所以没有加同步关键字的变量被修改后, 在工作内存中的值是不确定的. 相对于 synchronized 块的代码锁, volatile 提供了一个轻量级的针对共享变量的锁.当在多个线程间使用共享变量进行通信的时候, 需要考虑将共享变量用 volatile 修饰, 告知 JVM 这个变量是不稳定的, 每次都要到主存中进行读取, 避免数据不一致的问题出现. 可见性volatile 修饰的成员变量在每次被线程访问时, 都强迫从主存中重读改成员变量的值, 而且当成员变量发生变化时, 强迫线程将变化值回写到主存. 这样在任何时刻, 不同线程看到的成员变量都是同一个值, 保证了同步数据的可见性. 原子性?volatile 无法同时保证内存可见性和原子性, 加锁机制(同步机制)既可以确保可见性, 又可以确保原子性. volatile 只能确保可见性. 原因是: 声明为 volatile 的简单变量如果当前值与该变量以前的值相关, 那么 volatile 关键字不起作用, 比如: count++, count = count + 1, 都不是原子操作. 适合使用 volatile 的情况: 对变量的写入操作不依赖变量的当前值, 或者能确保只有单个线程更新变量的值. 该变量没有包含在具有其他变量的不变式中. 如: 12345678&gt; public volatile boolean flag;&gt; while(!flag)&#123;&gt; // do something...&gt; &#125;&gt; public setFlag()&#123;&gt; flag = false;&gt; &#125;&gt; 不适用示例: 123456&gt; public volatile int count;&gt; // ...&gt; run() &#123;&gt; count++; // 不能保证原子性&gt; &#125;&gt; 只是需要解决变量在多个线程之间的可见性. 资源的同步性应交由 synchronized 关键字. 等待/通知(wait/notify)机制等待通知机制: 指一个线程 A 调用了对象 O 的 wait() 方法进入该对象的等待池中, 而另一个线程 B 调用了对象 O 的 notify()/notifyAll() 方法, 线程 A 收到通知后退出等待池而进入该对象的锁池中, 等待锁竞争. 相关方法 方法名 描述 notify() 随机唤醒等待池中的 一个线程, 并让该线程进入该对象的锁池, 等待锁竞争. notifyAll() 使该对象等待池中所有线程进入锁池. wait() 使调用该方法的对象所在的线程释放共享资源锁, 然后进入等待池. wait(long) 超时等待一段时间, 单位是毫秒. 等待时间结束后, 自动唤醒. wait(long,int) 更精确的等待时间控制, 精确到纳秒. 注意: notify() 不会释放锁, 在方法执行完 synchronize 代码块后才会释放. wait() 会立即释放锁. 只能在 同步方法或同步块 中调用 wait()/notify()/notifyAll() 方法. 方法调用之前必须先获得该对象的对象级别锁, 如果调用时没有持有适当的锁, 则抛出 IllegalMonitorStateException 异常 当线程处于 wait 状态时, 对线程对象调用 interrupt 方法会出现 InterruptedException 异常. sleep() 和 wait() 区别sleep() 方法是线程类(Thread)的静态方法, 让此线程暂停执行指定时间, 将执行机会让给其他线程, 但是监控状态依然保持, 到时后会自动恢复到就绪状态. 调用 sleep 不会释放对象锁. wait() 方法是 Object 类的方法, 对此对象调用 wait() 方法导致本线程放弃对象锁, 进入该对象的等待池, 只有针对此对象发出的 notify/notifAll 方法后, 线程才会进入对象锁池准备获得对象锁进入就绪状态. ThreadLocalJDK 中提供 ThreadLocal 类来解决多个线程使用同一个 public static 变量的问题. ThreadLocal 让每个线程绑定自己的值. 也就是说它让每个线程可以存储自己的数据, 存放在堆中. 堆内存中的对象可以被所有线程访问, 但是 ThreadLocal 通过一些技巧将可见性修改成了线程可见. 方法名 描述 get() 返回此线程局部变量的当前线程副本中的值 initialValue() 返回此线程局部变量的当前线程的初始值, 便于子类重写. 不重写为 Null. remove() 删除此线程局部变量的当前线程的值 set(T value) 将此线程局部变量的当前线程副本的值设置为指定的值 123456789101112131415161718192021222324252627282930313233343536373839404142public class Test3 &#123; public static void main(String[] args) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(" 在Main线程中取值=" + Tools.tl.get()); Thread.sleep(100); &#125; Thread.sleep(5000); ThreadA a = new ThreadA(); a.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static public class Tools &#123; public static ThreadLocalExt tl = new ThreadLocalExt(); &#125; static public class ThreadLocalExt extends ThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125; &#125; static public class ThreadA extends Thread &#123; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("在ThreadA线程中取值=" + Tools.tl.get()); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 结果如图 可以看出: 不同线程从 ThreadLocal 中获取的值不相同. InheritableThreadLocalThreadLocal 类固然好, 但是子线程无法取到父线程 ThreadLocal 类的变量, 从而有了 InheritableThreadLocal 来解决这个问题. 修改上面代码中的 Tools 类和 ThreadLocalExt 类: 123456789static public class Tools &#123; public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt(); &#125; static public class InheritableThreadLocalExt extends InheritableThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125; &#125; 结果如上图所示. 同时还可以重写 childValue(Object parentValue) 来获取父类的变量值, 定制子类的变量值. 只是需要注意: 如果子线程在取得值的同时, 主线程将 InheritableThreadLocal 中的值进行更改, 那么子线程取到的还是旧值. Lock 接口Lock 接口简介锁是用于多个线程控制对共享资源的访问的工具, 通常, 锁提供对共享资源的独占访问: 一次只能有一个线程可以获取锁, 并且对共享资源的所有访问要求首先获取锁. 但是一些锁可能允许并发访问共享资源, 如 ReadWriteLock 的读写锁. JDK1.5 之后, 并发包中新增了 Lock 接口以及相关实现类来实现锁功能. Lock 接口的实现类: ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock 简单使用123456789Lock lock=new ReentrantLock()；lock.lock();try&#123; // do something // 如果有return要写在try块中&#125;finally&#123; // 保证锁最终能被释放 lock.unlock();&#125; 特性和方法 synchronized Lock 存在层次 Java 关键字 接口 锁的释放 获取到锁的线程执行完同步代码, 释放锁线程执行发生异常, JVM 使线程释放锁 在 finally 中必须释放锁, 不然容易造成线程死锁 锁的获取 假设A线程获得锁, B线程等待. 如果A线程阻塞, B线程会一直等待 尝试非阻塞地获取锁[^1]能被中断地获取锁[^2]超时获取锁[^3] 锁状态 无法判断 可以判断有没有成功获取锁 锁类型 可重入 不可中断 非公平 可重入 可中断 公平/非公平 [^1]:当前线程尝试获取锁, 如果这一时刻没有被其他线程获取到, 则成功获取并持有锁.[^2]:获取到锁的线程能够响应中断, 当获取到锁的线程被中断时, 中断异常将会被抛出, 同时锁会被释放.[^3]:在指定的截止时间之前获取锁, 超过截止时间仍旧无法获取则返回. 基本方法 方法名 描述 void lock() 获得锁. 如果锁不可用, 则当前线程将被禁用以进行线程调度, 并处于休眠状态, 直到获取锁. void lockInterruptibly() 获取锁. 如果可用并立即返回. 如果锁不可用, 那么当前线程将被禁用以进行线程调度, 并且处于休眠状态. 在锁的获取中可以中断当前线程. Condition newCondition() 获取等待通知组件, 该组件和当前的锁绑定, 当前线程只有获得了锁, 才能调用该组件的 wait() 方法. 而调用后, 当前线程将释放锁. boolean tryLock() 只有在调用时才可以获得锁, 如果可用, 则获取锁, 并返回值 true. 如果不可用, 返回值 false. boolean tryLock(long time, TimeUnit unit) 超时获取锁, 当前线程在以下三种情况下会返回:1. 当前线程在超时时间内获得了锁.2. 当前线程在超时时间内被中断.3. 超时时间结束, 返回 false. void unlock() 释放锁. ReentrantLock构造方法: 方法名称 描述 ReentrantLock() 创建一个 ReentrantLock 的实例. ReentrantLock(boolean fair) 创建一个特定锁类型(公平锁/非公平锁)的 ReentrantLock 的实例. 默认是非公平锁. 成员方法: 方法名 描述 int getHoldCount() 查询当前线程保持此锁定的个数, 也就是调用lock() 方法的次数. protected Thread getOwner() 返回当前拥有此锁的线程, 如果不拥有, 则返回 null protected Collection getQueuedThreads() 返回包含可能正在等待获取此锁的线程的集合 int getQueueLength() 返回等待获取此锁的线程数的估计. protected Collection getWaitingThreads(Condition condition) 返回包含可能在与此锁相关联的给定条件下等待的线程的集合. int getWaitQueueLength(Condition condition) 返回与此锁相关联的给定条件等待的线程数的估计. boolean hasQueuedThread(Thread thread) 查询给定线程是否等待获取此锁. boolean hasQueuedThreads() 查询是否有线程正在等待获取此锁. boolean hasWaiters(Condition condition) 查询任何线程是否等待与此锁相关联的给定条件 boolean isFair() 如果此锁的公平设置为 true, 则返回 true. boolean isHeldByCurrentThread() 查询此锁是否由当前线程持有. boolean isLocked() 查询此锁是否由任何线程持有. ConditionCondition 是 Java 提供来实现等待/通知的类, Condition 类还提供比 wait/notify 更丰富的功能. Condition 对象是由 lock 对象所创建的, 但是同一个锁可以创建多个 Condition 的对象, 即创建多个对象监视器, 这样的好处是: 可以指定唤醒的线程. Condition 将 Object 监视器方法(wait, notify, notifyAll)分解成截然不同的对象, 以便通过将这些对象与任意 Lock 实现组合使用, 为每个对象提供多个 等待 set(wait-set). 其中, Lock 替代了 synchronized 方法和语句的使用, Condition 替代了 Object 监视器方法的使用. 要创建一个 Lock 的 Condition, 必须使用 newCondition() 方法. 成员方法: 方法名称 描述 void await() 相当于 Object 类的 wait 方法 boolean await(long time, TimeUnit unit) 相当于 Object 类的 wait(long timeout) 方法 signal() 相当于 Object 类的 notify 方法 signalAll() 相当于 Object 类的 notifyAll 方法 调用 signal() 和 signalAll() 方法, 会在执行完方法当前所在的 try 语句块后才释放锁. 注意: 必须在 condition.await() 方法调用之前调用 lock.lock() 代码获得同步监视器, 否则会报错. 公平锁与非公平锁Lock 锁分为: 公平锁和非公平锁. 公平锁: 表示线程获取锁的顺序是按照线程加锁的顺序来分配的. 即先来先得的FIFO. 非公平锁: 一种获取锁的强占机制, 是随机获取锁,. ReentrantReadWriteLock之前的 ReentrantLock(排他锁)具有完全互斥排他的效果, 即同一时刻只允许一个线程访问, 虽然保证了实例变量的线程安全性, 但是效率较低. ReentranReadWriteLock 读写锁能够解决这个问题. 读写锁维护了两个锁, 一个是读操作相关的锁, 叶成文共享锁; 一个是写操作相关的锁, 也称为排他锁. 通过分离读锁和写锁, 其并发性比一般排他锁性能高. 多个读锁之间不互斥, 读锁与写锁互斥, 写锁与写锁互斥.(只要出现写操作的过程就是互斥的) 特性与方法 特性 说明 公平性选择 支持非公平(默认)和公平的锁获取方式, 吞吐量上来看还是非公平优于公平 重进入 该锁支持重进入, 以读写线程为例: 读线程在获取了读锁之后, 能够再次获取读锁. 而写线程在获取了写锁之后能够再次获取写锁也能够同时获取读锁 锁降级 遵循获取写锁, 获取读锁再释放写锁的次序, 写锁能够降级成为读锁 方法名 描述 ReentrantReadWriteLock() 创建一个 ReentrantReadWriteLock() 的实例 ReentrantReadWriteLock(boolean fair) 创建一个特定锁类型(公平锁/非公平锁)的ReentrantReadWriteLock 的实例 分别使用 lock.readLock().lock() 和 lock.writeLock().lock() 获取锁. 锁的状态JDK1.6 为了减少获得锁和释放锁所带来的性能消耗, 引入了”偏向锁”和”轻量级锁”. 所以锁一共有 4 种状态: 无锁状态, 偏向锁状态, 轻量级锁状态和重量级锁状态, 它会随着竞争情况逐渐升级. 锁可以升级但不能降级, 意味着偏向锁升级成轻量级锁后不能降级成偏向锁. 这种只升不降的策略, 目的是为了提高获得锁和释放锁的效率. 偏向锁在没有实际竞争的情况下, 还能针对部分场景继续优化. 如果不仅仅没有实际竞争, 自始至终, 使用锁的线程都只有一个, 那么, 维护轻量级锁都是浪费的. 偏向锁的目标是: 减少无竞争且只有一个线程使用锁的情况下, 使用轻量级锁产生的性能消耗. 轻量级锁每次申请, 释放锁都至少需要一次 CAS, 但偏向锁只有初始化时需要一次 CAS. “偏向”的意思是, 偏向锁假定将来只有第一个申请锁的线程会使用锁(不会有任何线程再来申请锁), 因此, 只需要在 Mark Word 中 CAS 记录 owner(本质上也是更新, 但初始值为空). 如果记录成功, 则偏向锁获取成功, 记录锁状态为偏向锁, 以后当前线程等于 owner 就可以零成本直接获得锁; 否则, 说明有其他线程竞争, 膨胀为轻量级锁. 偏向锁无法使用自旋锁优化, 因为一旦有其他线程申请锁, 就破坏了偏向锁的假定. 轻量级锁轻量级锁时有偏向锁升级来的, 偏向锁运行在一个线程进入同步块的情况下, 当第二个线程加入锁争用的时候, 偏向锁就会升级为轻量级锁. 轻量级锁是在没有多线程竞争的前提下, 减少传统的重量级锁使用产生的性能消耗. 轻量级锁所适应的场景是线程交替执行同步块的情况, 如果存在同一时间访问同一锁的情况, 就会导致轻量级锁升级为重量级锁. 使用轻量级锁时, 不需要申请互斥量, 仅仅将 Mark Word 中的部分直接 CAS 更新子项线程栈中的 Lock Record, 如果更新成功, 则轻量级锁获取成功, 记录锁的状态为轻量级锁; 否则, 说明已经有线程获得了轻量级锁, 目前发生了锁竞争, 接下来就膨胀为重量级锁. 重量级锁重量级锁在 JVM 中又叫对象监视器(Monitor), 至少包含一个竞争锁队列, 和一个信号阻塞队列(wait 队列), 前者负责做互斥, 后者用于做线程同步. 自旋锁自旋锁原理十分简单, 如果持有锁的线程能在很短时间释放锁资源, 那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态, 它们只需要等一等(自旋), 等待有锁的线程释放锁后即可立即获取锁. 这样就避免用户线程和内核的切换的消耗. 但是线程自旋需要消耗 CPU, 如果一直获取不到锁, 那线程也不能一直占用 CPU 自旋做无用功, 所以需要设定一个自旋等待的最大时间. 如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁, 就会导致其他争用锁的线程在最大等待时间内获取不到锁, 这时争用线程会停止自旋进入阻塞状态. 自适应自旋锁自适应意味着自旋的时间不在固定, 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定: 如果在同一个锁对象上, 自旋等待刚刚陈宫获得过锁, 并且持有锁的线程正在运行中, 那么 JVM 就会任务这次自旋很可能再次成功. 进而允许自旋等待时间持续相对更长的时间, 比如 100个循环. 相反, 如果对于某个锁, 自旋很少成功获得过, 那么在以后要获取这个锁时将可能减少自旋时间甚至直接略过自旋过程, 以避免浪费处理器资源. 偏向锁 轻量级锁 重量级锁适用于不同的并发场景 偏向锁: 无实际竞争, 且将来只有第一个申请锁的线程会使用锁. 轻量级锁: 无实际竞争, 多个线程交替使用锁, 允许短时间的锁竞争. 重量级锁: 有实际竞争, 且锁竞争时间长. 如果锁竞争时间段, 可以使用自旋锁进一步优化轻量级锁, 重量级锁的性能力, 减少线程切换. 如果锁竞争程度逐渐提高, 那么偏向锁逐步膨胀到重量级锁, 能够提高系统整体性能. 锁膨胀的过程: 只有一个线程进入临界区(偏向锁), 多个线程交替进入临界区(轻量级锁), 多线程同时进入临界区(重量级锁). 优缺点对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外消耗, 和执行非同步方法相比较仅存在纳秒级的差距 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗 适用于只有一个线程访问同步块的场景 轻量级锁 竞争的线程不会阻塞, 提高了程序的响应速度 如果始终得不到锁竞争的线程, 使用自旋会消耗 CPU 追求响应时间同步块执行速度非常快 重量级锁 线程竞争不使用自旋, 不会消耗 CPU 线程阻塞, 响应时间缓慢 追求吞吐量同步块执行速度较慢 CASCAS(Compare and swap) 简介使用锁时, 线程获取锁是一种悲观锁策略, 即假设每一次执行临界区代码都会产生冲突, 所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁. synchronized 关键字的实现就是悲观锁. 而 CAS 操作(又称为无锁操作), 是一种乐观锁策略. 它假设所有线程访问共享资源的时候不会出现冲突, 既然不会出现冲突, 自然而然就不会阻塞其他线程的操作. 因此, 线程就不会出现阻塞停顿的状态. 如果出现冲突怎么办? 无锁操作是使用 CAS 又叫做比较交换来鉴别线程是否出现冲突, 在更新的时候去判断此期间有没有人更新数据, 如果因为冲突失败, 就重试. 适用于写比较少的情况下, 即冲突较少发生, 这样可以省去了锁的开销, 加大系统的吞吐量. 乐观锁的实现方式 CAS乐观锁的实现主要两个步骤: 冲突检测和数据更新. CAS 是乐观锁技术, 当多个线程尝试使用 CAS 同时更新同一个变量时, 只有其中一个线程能更新变量的值, 而其他线程都失败. 失败的线程并不会被挂起, 而是被告知这次竞争中失败, 可以再次尝试. CAS 操作中包含三个操作数: 需要读写的内存位置(V) 进行比较的预期原值(A) 拟写入的新值(B) 如果内存位置V的值与预期原值A相匹配, 那么处理器会自动将该位置值更新为新值B. 否则处理器不做任何操作. 无论哪种情况, 它都不会在 CAS 指令之前返回该位置的值.(在 CAS 的一些特殊情况下将仅返回 CAS 是否成功, 而不提取当前值)CAS 有效地说明了: 我认为位置V应包含值A, 如果包含, 则将B放到这个位置, 否则, 不要更改该位置, 只告诉我这个位置的值即可. CAS 的缺点 ABA 问题 如果内存地址V初次读取的值是A, 并且在准备赋值的检查到它的值仍然为A, 那我们就能说它的值没有被其他线程改过了吗? 如果这段期间它的值曾经被改成了B, 后来又被改回为A, 那CAS操作就会误认为从来没有被改变过. ava 并发包为了解决这个问题, 提供了一个带有标记的原子引用类 AtomicStampedReference, 它可以通过控制变量值的版本来保证 CAS 的正确性. 因此, 在使用 CAS 前要考虑清楚 ABA 问题是否影响程序并发的正确性, 如果需要解决 ABA 问题, 改用传统的互斥同步可能比原子类更高效. 循环时间长开销大 自旋 CAS (不成功, 就一直循环执行, 直到成功)如果长时间不成功, 会给 CPU 带来非常大的执行开销. 只能保证一个共享变量的原子操作 当对一个共享变量执行操作时, 我们可以使用循环 CAS 的方式保证原子操作, 但是对多个共享变量操作室, 循环 CAS 就无法保证操作的原子性, 这个时候可以用锁来保证原子性. 或者将多个共享变量存储在一个对象中. 上下文切换当前任务在执行完 CPU 时间片切换到另一个任务之前会保存自己的状态, 以便下次在切换回这个任务时, 可以再加载这个任务的状态. 任务从保存到再加载的过程就是一次上下文切换. 上下文切换通常是计算密集型的. 也就是说, 它需要相当可观的处理器时间, 在每秒几十上百次的切换中, 每次切换都需要纳秒量级的时间, 所以, 上下文切换对系统来说意味着消耗大量的 CPU 时间. 事实上, 可能是操作系统中时间消耗量最大的操作. Linux 相比于其他操作系统有很多优点, 其中一项就是: 其上下文切换和模式切换的时间消耗非常少 减少上下文切换上下文切换又分为 2 种: 让步式上下文切换 和 抢占式上下文切换. 前者是指: 执行线程主动释放 CPU, 与锁竞争严重程度成正比, 可通过减少锁竞争和使用CAS算法来避免 后者是指: 线程因分配的时间片用尽而被迫放弃 CPU, 或者被其他优先级更高的线程所强占, 一般由于线程数大于 CPU 可用核心数引起, 可通过适当减少线程数和使用协程来避免 总结: 减少锁的使用. 多个线程竞争锁时会引起上下文切换 使用 CAS 算法. 这种算法也是为了减少锁的使用. 减少线程的使用. 使用协程 线程池如果并发的线程数量很多, 并且每个线程都是执行一个时间很短的任务就结束了, 这样频繁创建线程就会大大降低系统的效率, 因为频繁创建线程和销毁线程需要时间. 线程池的产生和数据库的链接类似, 系统启动了一个线程的代价是比较高昂的, 如果在程序启动的时候就初始化一定数量的线程, 放入线程池中, 在需要使用时从线程池中取, 用完再放回池中, 这样能大大地提高程序性能. 再者, 线程池的一些初始化配置, 也可以有效的控制系统的并发数量, 防止因为消耗过多的内存. 线程池提供了一种限制和管理资源(包括执行一个任务). 每个线程池还维护一些基本信息, 例如已完成任务的数量. 使用线程池的好处 降低资源消耗. 通过重复利用已创建的线程降低线程创建和销毁造成的消耗. 提高响应速度. 当任务到达时, 任务可以不需要等到线程创建就能立即执行. 提高线程的可管理性. 线程时稀缺资源, 如果无线地创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 使用线程池可以进行统一的分配, 调优和监控. Executor 框架Executor 框架主要有三大部分组成: 任务 执行任务需要实现 Runnable 或 Callable 接口. 这两个接口的实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行.= 任务的执行 包括任务执行机制的核心接口 Executor 以及继承自 Executor 接口的 ExecutorService 接口. ScheduledThreadPoolExecutor 和 ThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口. 异步计算的结果 Future 接口以及 Future 接口的实现类 FutureTask 类. 当我们把 Runnable 接口或 Callable 接口的实现类提交(调用 submit 方法)给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 时, 会返回一个 FutureTask 对象. Executor 框架流程图 主线程首先创建实现 Runnable 或 Callable 接口的任务对象 工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换 Executor.callable(Runnable task) 或 Executors.callable(Runnable task, Object result). 把创建完成的 Runnable 对象直接交给 ExecutorService 执行 ExecutorService.execute(Runnable command), ExecutorService.submit(Runnable task), ExecutorService.submit(Callable task). 执行 execute() 和 submit() 方法的区别: execute() 方法用于提交不需要返回值的任务, 所以无法判断任务是否被线程池执行成功. submit() 方法用于提交需要返回值的任务, 线程池会返回一个 Future 类型的对象, 通过这个 Future 对象可以判断任务是否执行成功. 并且可以通过 Future 的 get() 方法来获取返回值. get() 方法会阻塞当前线程直到任务完成, 而使用 get(long timeout, TimeUnit unit) 方法则会阻塞当前线程一段时候后立即返回, 无论任务是否执行完. 如果执行 ExecutorService.submit(), ExecutorService 将返回一个实现 Future 接口的对象 目前 JDK 中返回的是 FutureTask 对象. 由于 FutureTask 实现了 Runnable, 开发者也可以创建 FutureTask, 然后交给 ExecutorService 执行. 主线程可以执行 FutureTask.get() 方法来等待任务执行完成, 主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning) 来取消此任务的执行. ThreadPoolExecutorThreadPoolExecutor 是 Executor 框架的核心类. 重要属性: RejectedExecutionHandler: 当 ThreadPoolExecutor 已经关闭或饱和时(达到最大线程池大小且工作队列已满), execute() 方法将要调用 Handler. MaximumPoolSize: 最大线程池大小. Queue: 用来暂时保存任务的工作队列. corePoolSize: 核心线程池大小. 创建 ThreadPoolExecutor在《阿里巴巴Java开发手册》并发处理这一章节, 明确指出线程资源必须通过线程池提供, 不允许在应用中自行显示创建线程. 使用线程池的好处是在创建和销毁线程上所消耗的时间以及系统资源开销, 解决资源不足的问题. 如果不使用线程池, 有可能会造成系统创建大量同类线程而导致消耗完内存或者”过度切换”的问题. 同时强制线程池不允许使用 Executors 去创建, 而是通过 ThreadPoolExecutor 的方式, 这样的处理方式能让开发者更加明确线程池的运行规则, 规避资源耗尽的风险 Executors 返回线程池对象的弊端如下: FixedThreadPool 和 SingleThreadExector: 允许请求的队列长度为 Integer.MAX_VALUE, 可能堆积大量请求, 从而导致 OOM CachedThreadPool 和 ScheduledThreadPool: 允许创建的线程数量为 Integer.MAX_VALUE, 可能会创建大量线程, 从而导致 OOM 方式一: 通过构造方法实现 方式二: 通过 Executors 工具类创建, 常见的有 4 种: newCachedThreadPool: 大小不受限, 当线程释放时, 可重用该线程. 适用于执行很多的短期异步任务的小程序, 或者是负载较轻的服务器. newFixedThreadPool: 大小固定, 无可用线程时, 任务需等待, 直到有可用线程. 适用于为了满足资源管理需求, 而需要限制当前线程数量的应用场景. 适用于负载较重的服务器. newSingleThreadExecutor: 创建一个但线程, 任务会按顺序依次执行. 适用于需要单个后台线程执行周期任务, 同时保证顺序地执行各个任务的应用场景. newScheduledThreadPool: 创建一个定长线程池, 支持定时及周期性任务执行. 适用于需要多个后台执行周期任务, 同时为了满足资源管理需求而需要限制后台线程的数量的应用场景 参考资料 互联网校招面试必备——Java多线程: https://juejin.im/post/5ba133126fb9a05ce02a6f12 Java多线程学习: https://blog.csdn.net/qq_34337272/article/details/79640870 彻底理解synchronized: https://juejin.im/post/5ae6dc04f265da0ba351d3ff https://juejin.im/post/5ba133126fb9a05ce02a6f12#heading-11]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架]]></title>
    <url>%2F2019%2F03%2F16%2FJavaLearning%2FJavaNote%2FJava%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合框架Java 中的集合框架分为两大类: Collection 和 Map, 两者区别在于: Collection 是单列集合, Map 是双列集合 Collection 中只有 Set 要求元素唯一, Map 中键(key)需要唯一 Collection 的数据结构是针对元素的, Map 的数据结构是针对键的 CollectionCollection 主要分为 List 和 Set List: 存取有序, 有索引, 可以根据索引取值, 元素可以重复 Set: 存取无序, 元素不可以重复 List ArrayList: 底层数据结构是数组, 所以查询速度快, 增删速度慢. 非线程安全. LinkedList: 底层数据结构是链表, 所以查询慢, 增删快. 非线程安全. Vector(已过时): 底层数据结构是数组, 所以查询速度快, 增删速度慢. 线程安全. ArrayList 和 LinkedList 的异同 是否线程安全: ArrayList 和 LinkedList 都是不同步的, 非线程安全 底层数据结构: ArrayList 底层使用的是 Object 数组. LinkedList 底层使用的是双向链表数据结构. 插入和删除是否受元素位置的影响: ArrayList 采用数组存储, 所以插入和删除元素的时间复杂度受元素位置的影响. LinkedList 采用链表存储, 所以插入, 删除元素时间复杂度不受元素位置影响. 是否支持快速随机访问: LinkedList 不支持高效的随机元素访问 ArrayList 支持, 通过元素的索引快速获取元素对象 内存空间占用: ArrayList 的空间浪费主要体现在在 List 列表的结尾会预留一定的容量空间. LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间(因为要存放前前驱, 后继节点以及数据) RandomAccess接口: 123&gt; public interface RandomAccess&#123;&gt; &#125;&gt; RandomAccess 接口中什么都没有定义. 也就是说, 这个接口充当一个标识的作用, 标识实现这个接口的类具有随机访问功能. 在 binarySearch() 方法中, 它要判断传入的 List 是否是 RandomAccess 的实例. 如果是, 调用 indexedBinarySearch() 方法. 如果不是, 调用 iteratorBinarySearch() 方法. 12345678&gt; public static &lt;T&gt;&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;&gt; if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)&gt; return Collections.indexedBinarySearch(list, key);&gt; else&gt; return Collections.iteratorBinarySearch(list, key);&gt; &#125;&gt; ArrayList 实现了 RandomAccess 接口, 而 LinkedList 没有实现. 因为 ArrayList 底层数据结构是数组, 而 LinkedList 底层数据结构是双向链表. 它们实现随机访问的时间复杂度分别为 O(1) 和 O(n). List 遍历方式的选择 实现了 RandomAccess 接口的 List: 优先选择普通 for 循环, 其次 foreach. 未实现 RandomAccess 接口的 List: 优先选择 Iterator 遍历(foreach 遍历底层实现也是通过 Iterator), size 大的数据, 不要使用普通 for 循环. Set HashSet: 底层实际上是一个 HashMap 实例, 不保证迭代顺序, 非线程安全, 允许元素为 Null, 初始容量非常影响迭代性能. HashMap 中 key 的值就是 HashSet 的值, 而 value 是 final Object PRESENT = new Object() , 操作 HashSet 元素实际上就是操作 HashMap. LinkedHashSet: 迭代有序, 允许元素为 Null, 底层实际上是一个 HashMap + 双向链表实例(即 LinkedHashMap), 非线程安全, 初始容量不影响迭代性能. TreeSet: 可以实现排序功能(添加时排序), 底层实际上是 TreeMap 实例, 非线程安全. 保证 TreeSet 元素唯一性方法: 自定义对象实现 Comparable 接口, 重写 compareTo() 方法. 创建 TreeSet 时, 向构造器中传入比较器 Comparator 接口实现类对象, 实现 Comparator 接口重写 compare() 方法(用匿名类方式). 向 TreeSet 存入自定义对象, 如果自定义类没有实现 Comparable 接口, 或者没有传入 Comparator 比较器时, 会报 ClassCastException 异常. Map特点: 保存的是键值对, 键唯一, 值可以重复. HashMap: 底层数据结构为散列表, 无序, 允许为 Null, 非线程安全, 初始容量和装载因子对 HashMap 影响较大. 具体了解: HashMap LinkedHashMap:存取有序, 底层数据结构为散列表和双向链表, 允许为 Null, 非线程安全, 初始容量和装载因子对 HashMap 影响较大. TreeMap: 有序, 底层数据结构是红黑树, 非线程安全, 使用 Comparator 或 Comparable 来比较是否相等以及排序. 如果 Comparator 为 Null, 则使用 Key 作为比较器进行比较, 并且 key 必须实现 Comparable 接口. HashMap 和 HashTable 的区别 HashMap 是非线程安全的, HashTable 是线程安全的. HashTable 内部的方法基本都经过 synchronized 修饰. 因为线程安全的问题, HashMap 比 HashTable 效率高. HashMap 允许有 Null 存在, 而在 HashTable 中不允许 Null. 如果想要线程安全, 可以使用 ConcurrentHashMap. ConcurrentHashMap 对整个桶数组进行了分割分段(Segment), 然后在每一个分段上都用 lock 锁进行保护, 相对于 HashTable 的 synchronized 锁的粒度更精细, 并发性能更好. (JDK1.8 之后 ConcurrentHashMap 启用了一种全新的方式实现, 利用 CAS 算法). ConcurrentHashMap 不允许 Null. Queue PriorityQueue: 不允许 Null, 按元素大小进行重新排序, 底层数据结构是最小堆, 非线程安全. 在遍历时, 如果不需要删除元素, 以 peek 的方式遍历每个元素. Iterator() 中提供的迭代器并不保证以有序的方式遍历其中的元素. Deque: 是一个双端队列, 还可以当做栈使用. ArrayQueue: 底层数据结构是数组, 是循环队列, 通过 head 和 tail 两个游标来实现. 非线程安全, 集合的选用 需要根据键值来获取元素值: Map 需要排序: TreeMap 不需要排序: HashMap 保证线程安全: ConcurrentHashMap 只需要存放元素值: Collection 需要保证元素唯一: TreeSet 或 HashSet 不要要元素唯一: ArrayList 或 LinkedList 参考资料 Java集合总结: https://juejin.im/post/5ad40593f265da23750759ad Java集合入门和深入学习: https://juejin.im/post/5ad82dbef265da503825b240 Java集合（七） Queue详解: https://juejin.im/post/5a3763ed51882506a463b740]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2019%2F03%2F16%2FJavaLearning%2FJavaNote%2FFramework%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring IOCIOC 和 DI 简介 IOC(Inversion of Control)控制翻转, 包含了两个方面: 控制 和 反转 简单理解: 控制: 当前对象对内部成员的控制权 反转:控制权不由当前对象管理, 由其他类 / 第三方容器来管理 IOC 不够开门见山, 于是 Martin Fowler 提出了 DI(Dependency Injection)来替代 IOC. 即让调用类对某一个接口实现类的依赖关系由第三方(容器或协作类)注入, 以移除调用类对某一个接口实现类的依赖. 通过 DI, 对象的依赖关系将有系统中负责协调各对象的第三方组件在创建对象的时候进行设定, 对象无须自行创建或管理他们的依赖关系. 依赖关系将被自动注入到需要它们的对象当中去. 使用 IOC 的好处: 不用自己组装, 拿来就用 单例, 效率高, 不浪费空间 便于单元测试, 方便切换 mock 组件 便于进行 AOP 操作, 对于使用者是透明的 统一配置, 便于修改 原理IOC 容器其实就是一个大工厂, 用来管理我们所有的对象以及依赖关系 通过反射获取类的所有信息 通过配置文件或注解来描述类与类之间的关系 结合配置信息和反射来构建出对应的对象和依赖关系 Spring IoC 容器实现对象的创建和依赖: 根据 bean 配置信息在容器内创建 bean定义注册表. 根据注册表加载、实例化 bean, 建立 bean 与 bean 之间的依赖系. 将这些准备就绪的 bean 放到 Map 缓存池中, 等待应用程序调用. AOP AOP(Aspect Oriented Programming)面向切面编程: 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术. 利用 AOP 可以对业务逻辑的各个部分进行隔离, 从而使业务逻辑各部分之间的耦合度降低, 提高程序的可用性, 同时提高了开发的效率. 术语 连接点(Join point) 连接点是程序执行过程中能够应用通知的所有点. 目前 Spring AOP 仅支持方法级. 通知(Advice) 通知是指拦截到切点之后要做的事情就是通知, 包含了需要用于多个应用对象的横切行为. 通知的 5 种类型: Before: 在方法被调用之前调用 After: 在方法完成后调用通知, 无论方法是否执行成功 After-returning: 在方法成功执行之后调用通知 After-throwing: 在方法抛出异常后调用通知 Aroud: 通知包含了被通知的方法, 在被通知的方法调用之前和调用之后执行定义的行为 切点(Pointcut) 切点定义了通知被应用的具体位置. 切点定义了那些连接点会得到通知. 切面(Aspect) 切面是通知和切点的结合. 通知和切点共同定义了切面的全部内容–它是什么, 在何时和在何处完成其功能. 引入(Introduction) 引入允许我们向现有的类添加新方法或属性. 织入(Weaving) 织入是把切面应用到目标对象并创建新的代理对象的过程. 切面在指定的连接点被织入到目标对象中. 在目标对象的生命周期里有多个点可以进行织入. 顾问(Advisor) 顾问是切面的一种, 能够将通知以更为复杂的方式织入到目标对象中, 是将通知包装为更复杂的切面的装配器. BeanSpring 容器(Bean 工厂)可简单分成两种: BeanFactory: 这是 Spring 中较原始的 Factory, 无法支持 Spring 的许多插件, 如: AOP, Web 应用等. ApplicationContext: 这是 BeanFactory 派生而来, 还继承了其他许多接口, 提供了更多的功能. 因此, 大多数场合都是使用 ApplicationContext. BeanFactory 类继承体系 ApplicationContext 类继承体系 其中在 ApplicationContext 子类中还有一个比较重要的: WebApplicationContext: 专门为 Web 应用服务 Spring 与 Web 应用的上下文融合: Bean 的生命周期BeanFactory 的生命周期: ApplicationContext 的生命周期 上图中 设置属性值 的下一步应是: 调用 BeanNameAware 的 setBeanName() 方法 分类对方法进行解析: Bean 自身的方法: 如调用 Bean 的构造方法实例化 Bean, 调用 setter 设置 Bean 的属性值以及通过 init-method 和 destroy-method 所指定的方法 Bean 级生命周期接口方法: 如 BeanNameAware, BeanFactory, InitializingBean 和 DisposableBean, 这些接口方法由 Bean 类直接实现. 容器级生命周期接口方法: 图中带 “★” 的步骤是由 InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现, 一般称它们的实现类为 后处理器. 后处理器接口一般不由 Bean 本身实现, 它们独立于 Bean, 实现类以容器附加装置的形式注册到 Spring 容器中并通过接口反射为 Spring 容器预先识别. 当 Spring 容器创建任何 Bean 的时候, 这些后处理器都会发生作用, 所以这些后处理器的影响是全局性的. 用户可以通过合理地编写后处理器, 让其仅对特定的 Bean 进行加工处理. ApplicationContext 与 BeanFactory 不同之处: ApplicationContext 会利用 Java 反射机制自动识别出配置文件中定义的 BeanPostProcessor, InstantiationAwareBeanPostProcessor 和 BeanFactoryPostProcessor 后置器, 并自动将它们注册到应用上下文中. 而 BeanFactory 需要在代码中通过手动调用 addBeanPostProcessor() 方法进行注册. ApplicationContext 在初始化应用上下文的时候就实例化所有单实例的 Bean, 而 BeanFactory 在初始化容器的时候并未实例化 Bean, 直到第一次访问某个 Bean 时才实例化目标 Bean. 整个步骤详细描述: Spring 找到配置文件中 Spring Bean 的定义, 再利用 Java Reflection API 对 Bean 进行实例化. Spring 将值和 Bean 的引用注入到 Bean 对应的属性中. 如果 Bean 实现了 BeanNameAware 接口, Spring 将 Bean 的 ID 传递给 setBeanName() 方法, 设置 Bean 的名字. 如果 Bean 实现了 BeanFactoryAware 接口, Spring 将调用 setBeanFactory() 方法, 将 BeanFactory 容器实例传入. 如果 Bean 实现了 ApplicationContextAware 接口, Spring 将调用 setApplicationContext() 方法, 将 Bean 所在的应用上下文的引用传入进来. 与上面的类似, 如果实现了其他 *Aware 接口, 就调用相应的方法. ApplicationContextAware: 获得 ApplicationContext 对象, 可以用来获取所有 Bean definition 的名字. BeanFactoryAware: 获得 BeanFactory 对象，可以用来检测 Bean 的作用域。 BeanNameAware: 获得 Bean 在配置文件中定义的名字. ResourceLoaderAware: 获得 ResourceLoader 对象, 可以获得 classpath 中某个文件. ServletContextAware: 在一个 MVC 应用中可以获取 ServletContext 对象, 可以读取 context 中的参数. ServletConfigAware: 在一个MVC应用中可以获取 ServletConfig 对象, 可以读取config中的参数. 如果 Bean 实现了 BeanPostProcessor 接口, Spring 将调用它们的 postProcessBeforeInitialization() 方法. 如果 Bean 实现了 InitializingBean 接口, Spring 将调用它们的 afterPropertiesSet() 方法. 类似地, 如果 Bean 使用 init-method 声明了初始化方法, 该方法也会被调用. 如果 Bean 实现了 BeanPostProcessor 接口, Spring 将调用它们的 postProcessAfterInitialization() 方法. 此时 Bean 已经准备就绪, 可以被应用程序使用了. 它们将一直驻留在应用上下文, 直到该应用上下文被销毁. 如果 Bean 实现了 DisposableBean 接口, Spring 将调用它的 destroy() 接口方法. 同样, 如果 Bean 使用 destroy-method 声明了销毁方法, 该方法也会被调用. Bean 的作用域Spring Framework 支持五种作用域, 分别阐述如下表: 作用域 描述 singleton 整个 Spring IoC容器内只有一个这样的 bean, 生成后一直保持到容器销毁 prototype 每次从容器获取该 bean都会得到一个新的实例, 会被如何保持, 会被保持多长时间, 都由使用者决定, 容器不再管理 application 整个 ServletContext 视为一个应用, 在这个应用内只有一个这样的 bean, 创建之后一直保持到该 ServletContext 销毁 session 整个 HTTP Session 对应只有一个这样的 bean, 创建之后一直保持到该 HTTP session 被销毁 request 整个 HTTP request请求处理过程对应只有一个这样的 bean, 创建之后一直保持到该 HTTP request 处理完被销毁 五种作用域中, 通过 scope = &quot;singleton&quot;(xml), @Scope(&quot;singleton&quot;)(annotation). 其中 request, session 和 global session 三种作用域仅在基于 web 的应用中使用. 只能用在基于 web 的 Spring ApplicationContext 环境. singleton - 唯一 bean 实例当一个 bean 的作用域为 singleton, 那么 Spring IoC 容器中只会存在一个共享的 bean 实例, 并且所有对 bean 的请求. 只要 id 与该 bean 定义相匹配, 则只会返回 bean 的同一实例. 可以指定 bean 节点的 lazy-init = &quot;true&quot; 来延迟初始化 bean. 这时候, 只有在第一次获取 bean 时才会初始化 bean, 即第一次请求该 bean 时才初始化. prototype - 每次请求都会创建一个新的实例当一个 bean 的作用域为 prototype, 表示一个 bean 定义对应多个对象实例. prototype 作用域的 bean 会导致每次对该 bean 请求时都会创建一个新的 bean 实例. **prototype 是原型类型, 它在创容器时并没有实例化, 而是当我们获取 bean 时才会去创建一个对象. request - 每一次 HTTP 请求都会产生一个新的 bean, 仅在当前 HTTP request 内有效每一次 HTTP 请求都会产生一个新的 bean, 同时该 bean 仅在当前 HTTP request 内有效, 当请求结束后, 该对象的生命周期即宣告结束. session - 一次 HTTP 请求都会产生一个新的 bean, 仅在当前 HTTP session 内有效每一次 HTTP 请求都会产生一个新的 bean, 同时该 bean 仅在当前 HTTP session 内有效. 当 HTTP session 最终被废弃的时候, 在该 HTTP session 作用域内的 bean 也会被废弃掉. globalSession作用域类似于标准的 HTTP session 作用域. 不过仅仅在基于 portlet 的 web 应用中才有意义. Portlet 规范定义了全局 Session 的概念, 它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享. 在global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内. 参考资料 Spring IOC知识点一网打尽: https://segmentfault.com/a/1190000014979704 JavaGuide: https://github.com/Snailclimb/JavaGuide Spring 实战 第4版]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC]]></title>
    <url>%2F2019%2F03%2F16%2FJavaLearning%2FJavaNote%2FFramework%2FSpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC 简介SpringMVC 框架是以请求为驱动, 围绕 Servlet 设计, 将请求发给控制器, 然后通过模型对象, 分析器来展示请求结果视图. 其中核心类是 DispatcherServlet, 它是一个 Servlet, 顶层是实现 Servlet 的接口. SpringMVC 使用XML 方式需要在 web.xml 中配置 DispatcherServlet, 并且需要配置 Spring 监听器 ContextLoaderListener. 12345678910111213141516171819&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 如果不设置init-param标签，则必须在/WEB-INF/下创建xxx-servlet.xml文件，其中xxx是servlet-name中配置的名称。 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; SpringMVC 工作原理基本流程: 客户端发送请求 -&gt; 前端控制器 DispatcherServlet 接收客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler -&gt; HandlerAdapter 根据 Handler 来调用具体的处理器来处理请求, 并处理响应的业务逻辑. -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象 -&gt; 前端控制器 DispatcherServlet 渲染数据 -&gt; 将得到的视图对象返回给用户 如图所示: 流程说明: 客户端发送请求, 请求交由 DispatcherServlet 处理. DispatcherServlet 根据请求信息调用 HandlerMapping, 解析请求对应的 Handler. 解析到对应的 Handler (也就是平常所说的 Controller 控制器)后, 开始有 HandlerAdapter 适配器处理. HandlerAdapter 会根据 Handler 来调用具体的处理器来处理请求, 并处理相应的处理逻辑. 处理器处理完业务后, 会返回一个 ModelAndView 对象, Model 是返回的数据对象, View 是个逻辑上的 View. ViewResolver 会根据逻辑 View 查找实际的 View. DispatcherServlet 把返回的 Model 传给 View(视图渲染). 把 View 返回给客户端 SpringMVC 重要组件说明前端控制器 DispatcherServlet作用: SpringMVC 的入口, 接收请求, 响应结果, 相当于转发器, 中央处理器. 有了 DispatcherServlet, 减少了其他组件之间的耦合度. 用户请求到达前端控制器, 它就相当于 MVC 模式中的 C, DispatcherServlet 是整个流程控制的中心. 由它来调用其他组件处理用户的请求, DispatcherServlet 的存在降低了组件之间的耦合度. 处理映射器 HandlerMapping作用: 根据请求的 URL 查找 Handler. HandlerMapping 负责根据用户请求寻找能够处理请求的 Handler(处理器 Controller). SrpingMVC 提供了不同的映射器实现不同的映射方式, 例如: 配置文件方式 - web.xml , 实现接口方式 - implements Controller, 注解方式 - @RequestMapping (常用). 处理适配器 HandlerAdapter作用: 按照特定的规则去执行 Handler. 通过 HandlerAdapter 对处理器进行执行, 这是适配器模式的应用, 通过扩展适配器, 可以对更多类型的处理器进行执行. 处理器 Handler (Controller)编写 Handler 时需要遵循 HandlerAdapter 的要求, 这样适配器才能正确执行 Handler Handler 是继 DispatcherServlet 前端控制器的后端控制器, 在 DispatcherServlet 的控制下, Handler对具体的用户请求进行处理. 由于 Handler 涉及到具体的业务请求, 所以一般情况下需要工程师根据业务需求开发 Handler 视图解析器 View Resolver作用: 进行视图解析, 根据逻辑视图名解析成真正的视图(View) View Resolver 负责将处理结果生成 View 视图, View Resolver 首先根据逻辑视图名解析成物理视图名, 即具体的页面地址, 再生成 View 视图对象, 最后对 View 进行渲染并将处理结果通过页面展示给用户. 视图 ViewView 是一个接口, 实现类支持不同的 View 类型. 如: JSP, Freemaker, pdf, excel… 注意: 处理器 Handler 以及视图层 View 都是需要我们自己手动开发的, 其他的一些组件比如: DispatcherServlet, HandlerMapping, HandlerAdapter 等等都是 DispatcherServlet 详细解析源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package org.springframework.web.servlet; @SuppressWarnings("serial")public class DispatcherServlet extends FrameworkServlet &#123; public static final String MULTIPART_RESOLVER_BEAN_NAME = "multipartResolver"; public static final String LOCALE_RESOLVER_BEAN_NAME = "localeResolver"; public static final String THEME_RESOLVER_BEAN_NAME = "themeResolver"; public static final String HANDLER_MAPPING_BEAN_NAME = "handlerMapping"; public static final String HANDLER_ADAPTER_BEAN_NAME = "handlerAdapter"; public static final String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = "handlerExceptionResolver"; public static final String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = "viewNameTranslator"; public static final String VIEW_RESOLVER_BEAN_NAME = "viewResolver"; public static final String FLASH_MAP_MANAGER_BEAN_NAME = "flashMapManager"; public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + ".CONTEXT"; public static final String LOCALE_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + ".LOCALE_RESOLVER"; public static final String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + ".THEME_RESOLVER"; public static final String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + ".THEME_SOURCE"; public static final String INPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + ".INPUT_FLASH_MAP"; public static final String OUTPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + ".OUTPUT_FLASH_MAP"; public static final String FLASH_MAP_MANAGER_ATTRIBUTE = DispatcherServlet.class.getName() + ".FLASH_MAP_MANAGER"; public static final String EXCEPTION_ATTRIBUTE = DispatcherServlet.class.getName() + ".EXCEPTION"; public static final String PAGE_NOT_FOUND_LOG_CATEGORY = "org.springframework.web.servlet.PageNotFound"; private static final String DEFAULT_STRATEGIES_PATH = "DispatcherServlet.properties"; protected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY); private static final Properties defaultStrategies; static &#123; try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException("Could not load 'DispatcherServlet.properties': " + ex.getMessage()); &#125; &#125; /** Detect all HandlerMappings or just expect "handlerMapping" bean? */ private boolean detectAllHandlerMappings = true; /** Detect all HandlerAdapters or just expect "handlerAdapter" bean? */ private boolean detectAllHandlerAdapters = true; /** Detect all HandlerExceptionResolvers or just expect "handlerExceptionResolver" bean? */ private boolean detectAllHandlerExceptionResolvers = true; /** Detect all ViewResolvers or just expect "viewResolver" bean? */ private boolean detectAllViewResolvers = true; /** Throw a NoHandlerFoundException if no Handler was found to process this request? **/ private boolean throwExceptionIfNoHandlerFound = false; /** Perform cleanup of request attributes after include request? */ private boolean cleanupAfterInclude = true; /** MultipartResolver used by this servlet */ private MultipartResolver multipartResolver; /** LocaleResolver used by this servlet */ private LocaleResolver localeResolver; /** ThemeResolver used by this servlet */ private ThemeResolver themeResolver; /** List of HandlerMappings used by this servlet */ private List&lt;HandlerMapping&gt; handlerMappings; /** List of HandlerAdapters used by this servlet */ private List&lt;HandlerAdapter&gt; handlerAdapters; /** List of HandlerExceptionResolvers used by this servlet */ private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers; /** RequestToViewNameTranslator used by this servlet */ private RequestToViewNameTranslator viewNameTranslator; private FlashMapManager flashMapManager; /** List of ViewResolvers used by this servlet */ private List&lt;ViewResolver&gt; viewResolvers; public DispatcherServlet() &#123; super(); &#125; public DispatcherServlet(WebApplicationContext webApplicationContext) &#123; super(webApplicationContext); &#125; @Override protected void onRefresh(ApplicationContext context) &#123; initStrategies(context); &#125; protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); &#125;&#125; DispatcherServlet 类中的属性 beans: HandlerMapping: 定义请求和处理程序对象之间的映射. 用于 Handlers 映射请求和一系列的对于拦截器的前处理和后处理, 大部分用 @Controlelr 注解. SimpleUrlHandlerMapping: 通过配置文件把 URL 映射到 Controller 类. DefaultAnnotationHandlerMapping: 通过注解把 URL 映射到 Controller 类. HandlerAdapter: 帮助 DispatcherServlet 处理映射请求的处理程序的适配器. AnnotationMethodHandlerAdapter: 通过注解把 URL 映射到 Controller 类的方法上. ViewResolver: 根据配置解析实际的 View 类型. UrlBaseViewResolver: 通过配置文件, 提供一种拼接 URL 的方式来解析视图. ThemeResolver: 解决 Web 应用程序可以使用的主题, 例如提供个性化布局. MultipartResolver: 解析多部分请求, 以支持从 HTML 表单上传文件. FlashMapManager: 存储并检索可用于将一个请求属性传递到另一个请求的 input 和 output 的 .FlashMap, 通常应用于重定向. 通过方法将会话中的数据发送为 flash attribute, flash 属性会一直携带这些数据直到下一次请求, 然后才会消失. 解决了重定向时会话数据丢失的问题. HandlerExceptionResolver: 异常处理的接口. SimpleMappingExceptionResolver: 通过配置文件进行异常处理. AnnotationMethodHandlerExceptionResolver: 通过注解进行异常处理. 在 Web MVC 框架中, 每个 DispatcherServlet 都拥有自己的 WebApplicationcontext, 它继承了 ApplicationContext. WebApplicationContext 包含了其上下文和 Servlet 实例之间共享的所有的基础框架 beans. 时序图 参考资料 JavaGuide: https://github.com/Snailclimb/JavaGuide]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2F2019%2F03%2F16%2FJavaLearning%2FJavaNote%2FJava%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap 简介HashMap 主要用来存放键值对. 基于哈希表的 Map 接口实现. JDK8 之前 HashMap 由 数据+链表 组成, 数组是 HashMap 的主体, 链表则是主要为了解决哈希冲突而存在的. JDK8 之后, 当链表长度大于阀值(默认为8)时, 将链表转化为红黑树, 以减少搜索时间. 底层数据结构分析JDK1.8 之前JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用, 也就是 链表散列. HashMap 通过 key 的 hashCode 经过 扰动函数 处理过后得到 hash 值, 然后通过 (n - 1) &amp; hash 判断当前元素存放的位置(n 为数组的长度). 如果当前位置存在元素, 就判断该元素与要存入的元素的 hash 值以及 key 是否相同, 如果相同, 就直接覆盖, 不相同, 就通过 拉链法 解决冲突. 扰动函数所谓扰动函数指的就是 HashMap 的 hash 方法. 使用 hash 方法也就是扰动函数, 是为了防止一些实现比较差的 hashCode() 方法造成的 哈希冲突, 也就是减少碰撞. JDK 1.7的 HashMap 的 hash 方法源码: 12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; JDK 1.8 HashMap 的 hash 方法源码: 1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 相比于 JDK1.8 的 hash 方法, 虽然原理不变, JDK 1.7 的 hash 方法的性能稍差一点, 因为扰动了 4 次. 拉链法“拉链法“: 将链表和数组相结合, 也就是说创建一个链表数组, 数组中每一格都是一个链表. 若遇到哈希冲突, 则将冲突的值加到链表中即可. JDK1.8 之后JDK1.8 在解决哈希冲突时有了较大的变化: 当链表长度大于阀值(默认为 8 )时, 将链表转化为红黑树, 以减少搜索时间. HashMap类: 12345678910111213141516171819202122232425262728public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 加载因子 final float loadFactor;&#125; loadFactor 加载因子 loadFactor 加载因子用来控制数组存放数据的疏密程度, loadFactor 越趋近于 1, 那么数组中存放的数据(entry)也就越多, 也就越密, 链表的长度增加的可能性(碰撞的几率)就越高. 反之, loadFactor 越小(趋近于 0), 数组中存放的数据(entry)也就越少, 链表的长度增加的可能性(碰撞的几率)就越低. loadFactory 太大导致查找元素的效率低, 太小导致数组的利用效率低, 存放的数据会很分散. loadFactory 的默认值为 0.75f 是官方给出的一个比较好的临界值. threshold 该属性是衡量数组是否需要扩增的一个标准. threshold = capacity * loadFactor, 当 size &gt;= threshold 时, 就要考虑对数组的扩展. 给定的默认容量为 16, 加载因子为 0.75. Map 在使用过程中不断往里面存放数据, 当数量达到了 16 * 0.75 = 12 时, 就要将当前的数组扩容, 而扩容涉及到 rehash, 复制数据等操作, 十分消耗性能. Node 节点类: 123456789101112131415161718192021222324252627282930313233343536373839// 继承自 Map.Entry&lt;K,V&gt;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较 final K key;//键 V value;//值 // 指向下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; // 重写hashCode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 重写 equals() 方法 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 源码分析构造方法 HashMap() HashMap(int) HashMap(int,float) HashMap(Map&lt;? extends K,? extends V&gt;) 123456789101112131415161718192021222324252627// 默认构造函数。public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; // 包含另一个“Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法 &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; putMapEntries 方法:123456789101112131415161718192021222324final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 判断table是否已经初始化 if (table == null) &#123; // pre-size // 未初始化，s为m的实际元素个数 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s &gt; threshold) resize(); // 将m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; put 方法HashMap 只提供了 put 用于添加元素，putVal 方法供 put 方法调用, 并没有提供给用户使用. putVal 方法添加元素: 如果定位到的数组位置没有元素, 直接插入. 如果定位到的数组位置有元素, 就和要插入的 key 比较. 相同: 直接覆盖. 不同: 判断 p 是否是一个新的树节点. 是, 就调用 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value) 将元素添加进入. 不是, 就遍历链表插入. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125; get 方法12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; resize 方法对 table 进行扩容, 会伴随着一次重新 hash 分配, 并且会遍历 hash 表中所有的元素, 十分耗时, 尽量避免. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 参考资料 JavaGuide: https://github.com/Snailclimb/JavaGuide]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE]]></title>
    <url>%2F2019%2F03%2F13%2FJavaLearning%2FJavaNote%2FJava%2FJavaEE%2F</url>
    <content type="text"><![CDATA[1. Servlet 在 Java Web 程序中, Servlet 主要负责接收用户请求 HttpServletRequest , 在 doGet() , doPost() 中做相应的处理, 并将回应 HttpServletResponse 返回给用户. Servlet 可以设置初始化参数, 供 Servlet 内部使用. 一个 Servlet 类中只会有有一个实例, 在它初始化时调用 init() 方法, 销毁时掉哦用 destroy() 方法. Servlet 需要在 web.xml 中配置. 一个 Servlet 可以设置多个 URL 访问. Servlet 非线程安全, 多线程并发的读写会导致数据不同步的问题. 解决的办法是尽量不要定义 name 属性, 而是把 name 变量分别定义在 doGet() 和 doPost() 方法中. 注意: 多线程的并发读写 Servlet 类属性会导致数据不同步. 但是如果只是并发地读取属性而不写入, 则不存在数据不同步的问题. 因此 Servlet 里的只读属性最好定义为 final 类型 1. Servlet 和 CGI 区别CGI 的不足: 需要为每个请求启动一个 CGI 程序的系统进程. 如果请求频繁, 会带来很大开销. 需要为每个请求加载和运行一个 CGI 程序, 带来很大开销. 需要重复编写处理网络协议的代码以及编码, 这些工作都是非常耗时的. Servlet 的优点: 只需要启动一个操作系统进程以及加载一个 JVM , 大大降低了系统的开销. 如果多个请求需要做同样处理的时候, 这时只需要加载一个类, 大大降低了开销. 所有动态加载的类可以实现对网络协议以及请求解码的共享, 大大降低了工作量 Servlet 能直接和 Web 服务器交互, 而普通的 CGI 程序不能. Servlet 还能在各个程序之间共享数据, 使数据库连接池之类的功能很容易实现 一个基于 Java Web 的应用通常包含一个或多个 Servlet 类. Servlet 不能够自行创建并执行, 它是在 Servlet 容器中运行的, 容器将用户的请求传递给 Servlet 程序并将 Servlet 的响应回传给用户. 2. Servlet 接口中的方法及生命周期Servlet 接口中定义了 5 个方法, 其中前三个方法与 Servlet 生命周期相关: void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destroy() java.lang.String getServletInfo() ServletConfig getServletConfig() 生命周期Web 容器加载 Servlet 并将其实例化后, Servlet 生命周期开始. 容器运行其 init() 方法进行 Servlet 的初始化. 请求到达时调用 Servlet 的 service() 方法, service() 方法根据需要调用与请求对应的 doGet() 或 doPost() 方法. 当服务器关闭或项目被卸载时, 服务器会将 Servlet 实例销毁. 此时会调用 Servlet 的 destroy() 方法. init 和 destroy 方法只会执行一次, service 方法会在客户端每次请求 Servlet 时执行. Servlet 中有时会用到一些需要初始化与销毁的资源. 因此可以把初始化资源的代码放入 inti 方法中, 销毁资源的代码放入 destroy 中. 3. 转发(Forward)和重定向的区别(Redirect)的区别转发是服务器行为, 重定向是客户端行为 转发(Forward) 通过 RequestDispatcher 对象的 forward (HttpServletRequest request, HttpServletResponse response) 方法实现的. RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher() 方法获得. 如: request.getRequestDispatcher(&quot;login_sucess.jsp&quot;).forward(request, response); 重定向(Redirect) 利用服务器返回的状态码实现的. 客户端浏览器请求服务器时, 服务器返回一个状态码. 服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码. 如果服务器返回 301 或者 302 , 则浏览器会到新的网址重新请求该资源 从地址栏显示说 forward 是服务器请求资源, 服务器直接访问目标地址的 URL , 把那个 URL 的响应内容读取过来, 然后把这些内容再发给浏览器. 浏览器端不知道服务器发送的内容来自哪里, 所以地址栏还是原来的地址 redirect 是服务端根据逻辑, 发送一个状态码, 告诉浏览器重新去请求哪个地址. 所以地址栏显示的是新的 URL 从数据共享说 forward: 转发的页面和转发到的页面可以共享 request 中的数据 redirect: 不能共享数据 从运用方面说 forward: 一般用于用户登录的时候, 根据角色转发到相应的模块 redirect: 一般用于用户注销登录返回主页面和跳转到其他页面等 从效率说 forward: 高 redirect: 低 4. 实现会话跟踪使用Cookie向客户端发送 Cookie 123Cookie c = new Cookie("name","value"); // 创建Cookiec.setMaxAge(60*60*24); // 设置最大时效，此处设置的最大时效为一天response.addCookie(c); // 把Cookie放入到HTTP响应中 从客户端读取 Cookie 123456789101112String name ="name"; Cookie[]cookies =request.getCookies(); if(cookies !=null)&#123; for(int i= 0;i&lt;cookies.length;i++)&#123; Cookie cookie =cookies[i]; if(name.equals(cookis.getName())) //something is here. //you can get the value cookie.getValue(); &#125; &#125; 优点: 数据可以持久保存, 不需要服务器资源. 基于文本的 key-value 缺点: 大小受限制, 用户可以禁用 Cookie 功能. 保存在本地, 有安全风险 URL 重写在 URL 中添加用户会话的信息作为请求的参数, 或者将唯一的会话 ID 添加到 URL 结尾以标识一个会话. 优点: 在 Cookie 被禁用时依然可以使用 缺点: 必须对网站的 URL 进行编码, 所有页面必须动态生成. 不能用预先记录下来的 URL 进行访问. 隐藏的表单1&lt;input type = "hidden" name = "session" value = "..." /&gt; 优点: Cookie 被禁用时可以使用 缺点: 所有页面必须是表单提交之后的结果 HttpSession最强大功能最多的会话跟踪技术. 当一个用户访问某个网站时会自动创建 HttpSession 分配一个 JSESSIONID. 每个用户可以访问他自己的 HttpSession . 可以通过 HttpServletRequest 对象的 getSession() 方法获得 HttpSession , 通过 HttpSession 对象的 getAttribute() 方法, 同时传入 key 就可以获取保存在 HttpSession 中的对象. HttpSession 保存在服务器的内存中, 因此不要将过大的对象存放在里面. 虽然目前的 Servlet 容器可以在内存即将满时将 HttpSession 中的对象移动到其他存储设备中, 但也会影响性能. 添加到 HttpSession 中的值可以是任意 Java 对象. 这个对象最好实现了 Serializable 接口, 这样 Servlet 容器在必要的时候可以将其序列化到文件中, 否则在序列化时就会出现异常. 使用 和Cookie搭配使用 第一次创建 Session 的时候, 服务端会在 HTTP 协议中告诉客户端需要在 Cookie 里记录一个 Session ID . 以后在每次 HTTP 请求时, 客户端都会发送 Cookie 信息到服务端, Cookie 中就携带着 Session ID 来帮助服务端辨识当前请求的用户身份. 如果客户端禁用了 Cookie 功能, 就会使用下面的方式. 和URL重写技术搭配使用 在每次 HTTP 交互, URL 后面附带加上一个如 sid=xxxx 这样的参数, 服务端根据此来识别用户 Cookie 和 Session 的主要区别在于: Cookie 保存在客户端, Session 保存在服务端 5. Get 和 Post 请求区别 Get Post 用来请求从服务器上获得的资源. 用于幂等的场景 操作服务器资源. 用户不幂等的场景 将表单中数据按照 name = value 的形式, 加上 ? 拼接到 URL 后, 各个变量之间用 &amp; 连接. 将表单中的数据放在 HTTP 协议的请求头或消息体中 传输的数据收到浏览器对 URL 长度的限制(最大长度为 2048 字符) 可以通过 request body 技术传输大量数据, 上传文件通常使用 post 方式 参数会显示在地址栏上 数据不会显示在地址栏 使用 MIME类型 application/x-www-form-urlencode 的 URL 编码文本的格式传递参数 支持更多的编码类型且不对数据类型做限制 参考资料 JavaGuide: https://github.com/Snailclimb/JavaGuide]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toNote]]></title>
    <url>%2F2019%2F03%2F11%2FJavaLearning%2FJavaNote%2FtoNote%2F</url>
    <content type="text"><![CDATA[记录需要了解的知识点 Copy on Write LocalDate等日期处理类 redis, SpringSession]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础笔记]]></title>
    <url>%2F2019%2F03%2F11%2FJavaLearning%2FJavaNote%2FJava%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. JVM JDK 和 JRE javac :包含于JDK中的将.java文件编译为字节码(.class)文件的编译器. JVM可以理解的代码就叫做字节码. 即扩展名为.class的文件. JSP 会被转换为 Java servlet. 并被 JDK 用 javac 编译器编译. 2. 字符型常量和字符串常量 形式上:字符型常量是单引号引起的一个字符.如&#39;a&#39;. 字符串常量是双引号引起的若干个字符如&quot;Hello world&quot;. 含义上:字符型常量可以当做一个整形值(16位 Unicode 字符 0~65535)参与表达式运算. 字符串常量代表一个地址值(引用字符串常量池中的对象. 不会被垃圾回收) 3. 重载(Overload)和重写(Override) 重载 重写 发生在同一个类中 发生在父子类中 方法名必须相同参数类型、个数、顺序、方法返回值和权限修饰符可以不同 方法名和参数列表必须相同. 权限修饰符范围大于等于父类抛出异常的范围小于等于父类. 返回值返回小于等于父类 4. 封装 继承 多态封装封装把一个对象的属性私有化. 同时提供一些想让外界访问的属性的方法. 继承继承是使用已存在的类的定义作为基础建立新类的技术. 新类的定义中可以增加新的成员变量和成员方法. 且同时拥有父类声明的可以被继承的变量和方法. 多态多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定. 只有在程序运行期间才能确定. 实现多态的方法:继承和接口 5. String StringBuffer 和 StringBuilder可变性StringString类中使用private final char value[]来保存字符串. 所以String对象是不可变的 StringBuilder 与 StringBuffer两者都继承自AbstractStringBuilder类. 该类同样使用char[] value来保存字符串. 但没有用final修饰. 所以这两种对象是可变的 线程安全性StringString中的对象是不可变的. 在字符串常量池中只有一个. 线程安全. StringBuffer 和 StringBuilderAbstractStringBuilder是StringBuilder与StringBuffer的父类. 定义了一系列字符串的基本操作.如expandCapacity, append, insert, indexOf等公共方法. StringBufferStringBuffer对方法加了同步锁或者对调用的方法加了同步锁. 所以是线程安全的 StringBuilderStringBuilder没有加锁. 所以是非线程安全的 性能 String类型每次被改变的时候. 都会在字符串常量池中生成一个新的String对象. 然后将指针指向新的String对象 StringBuffer每次都会对对象本身进行操作. 不会生成新的对象并改变引用. StringBuilder相比StringBuilder性能仅提升10%~15%左右. 但非线程安全. 使用 操作少量数据 =&gt; String 拼接字符串时 =&gt; StringBuilder StringBuffer 单线程操作字符串缓冲区下大量数据 =&gt; StringBuilder 多线程操作字符串缓冲区下大量数据 =&gt; StringBuffer 6. 自动装箱与拆箱装箱将基本类型用他们对应的引用类型包装起来.如:int-&gt;Integer 自动装箱时编译器调用valueOf将原始类型值转换成对象 拆箱将包装类型转换为基本数据类型.如:Integer-&gt;int 同时自动拆箱时，编译器通过调用类似intValue(). doubleValue()这类的方法将对象转换成原始类型值. 发生场景 进行 = 赋值操作（装箱或拆箱） 进行+，-，*，/混合运算 （拆箱） 进行&gt;. &lt;. ==比较运算（拆箱） 调用equals进行比较（装箱） ArrayList. HashMap等集合类 添加基础类型数据时（装箱） 注意事项生成无用对象增加GC压力因为自动装箱会隐式地创建对象.如果在一个循环体中. 会创建无用的中间对象. 这样会增加GC压力. 拉低程序的性能.所以在写循环时一定要注意代码. 避免引入不必要的自动装箱操作. 对象相等比较==可以用于基本类型进行比较. 也可以用于对象进行比较. 当用于对象与对象之间比较时. 比较的不是对象代表的值. 而是检查两个对象是否是同一对象.这个比较过程中没有自动装箱发生.进行对象值比较不应该使用==，而应该使用对象对应的equals方法. 1234567891011121314151617181920212223242526272829303132333435public class AutoboxingTest &#123; public static void main(String args[]) &#123; // Example 1: == comparison pure primitive – no autoboxing int i1 = 1; int i2 = 1; System.out.println("i1==i2 : " + (i1 == i2)); // true // Example 2: equality operator mixing object and primitive Integer num1 = 1; // autoboxing int num2 = 1; System.out.println("num1 == num2 : " + (num1 == num2)); // true // Example 3: special case - arises due to autoboxing in Java Integer obj1 = 1; // autoboxing will call Integer.valueOf() Integer obj2 = 1; // same call to Integer.valueOf() will return same // cached Object cache range(-128~127) System.out.println("obj1 == obj2 : " + (obj1 == obj2)); // true // Example 4: equality operator - pure object comparison Integer one = new Integer(1); // no autoboxing Integer anotherOne = new Integer(1); System.out.println("one == anotherOne : " + (one == anotherOne)); // false &#125;&#125;Output:i1==i2 : truenum1 == num2 : trueobj1 == obj2 : trueone == anotherOne : false 缓存的对象在Java中. 会对-128到127的Integer对象进行缓存. 当创建新的Integer对象时. 如果符合这个这个范围. 并且已有存在的相同值的对象. 则返回这个对象 否则创建新的Integer对象. 静态方法内不能调用非静态成员静态方法可以不通过对象进行调用. 因此在静态方法里. 不能调用其他非静态变量. 也不可以访问费静态变量成员. 7. 在 Java 中定义一个空的无参构造方法的作用Java程序在执行子类的构造方法之前. 如果没有用super()来调用父类特定的构造方法. 就会调用父类的无参构造方法.因此. 如果父类中只定义了有参构造方法. 而子类的构造方法中没有用super()来调用父类中特定的构造方法. 则编译时将发生错误. 8. 接口和抽象类的区别 接口 抽象类 方法默认是public. 所有方法都不能有实现且子类必须重写全部方法Java 8开始. 接口提供默认方法default. 子类不需重写 可以有非抽象方法 实例变量必须是public static final类型 可以不是final类型 多继承 单继承 不能用new实例化. 但可以声明. 但是必须引用一个实现该接口的对象接口是行为的抽象. 是一种行为的规范.适合对类的行为抽象 同样不能用new实例化. 但可以声明. 但是必须引用一个继承该类的对象抽象是对类的抽象. 是一种模板设计.适合对事物抽象 为什么接口属性必须是 public static final 接口是一种高度抽象的模板. 而接口中的属性也就是模板成员.就应当是所有实现模板的类的共有特性. 其次. 接口中如果可以定义非final变量的话. 而方法又都是abstract的. 这就会造成有可变成员变量. 但对应的方法却无法操作这些变量.接口是一种更高层面的抽象. 是一种规范. 功能定义的声明. 所有可变的东西都应归属到实现类中. 这样的接口才能起到标准化. 规范化的作用.所以接口中的属性必然是final的 最后, 接口只是对事物的属性和行为更高层次的抽象.对修改关闭. 对扩展开放.接口是对开闭原则的一种体现 接口的静态方法在Java 8中. 接口也可以定义静态方法. 可以直接用接口名调用. 实现类和实现四不可以调用的. 如果同时实现多个接口. 接口中定义了一样的默认方法. 必须重写. 否则会报错. 9. 成员变量和局部变量的区别 成员变量 局部变量 成员变量属于类. 可以用public private static等修饰符修饰 局部变量在方法中定义或是方法的参数. 不能被权限修饰符修饰. 除了 final 非静态时. 随对象存储于堆内存中 随方法存储于栈内存中 没有被赋初值. 则会自动以类型的默认值而赋值 不会被自动赋值 10. == 与 equals==: 判断两个对象的地址是不是相等. 即是不是同一个对象. 都是基本类型时比较的是值是否相等. 都是引用类型时比较的是内存地址是否相等.基本类型和它的封装类型时. 封装类型拆箱为基本类型然后比较值是否相等. equals: 通过方法中定义的方式进行比较.所有类都继承了Object类的equals()方法. 其默认是用==来进行比较两个对象. 如果调用方法的对象重写了此方法. 按重写的方法中的方式进行比较. 11. equals 与 hashCode重写equals时必须重写hashCode方法 hashCode()hashCode()的作用是获取哈希码. 也称为散列码. 返回的是一个 int 整数. 这个哈希码的作用是确定该对象在哈希表中的索引位置. hashCode()定义在 JDK 的 Object.java中. 意味着任何内都包含有hashCode()函数. 散列表存储的是键值对(key-value). 特点是:能根据”键”快速检索出对应的”值”. 这里就会用到散列码. 用来快速定位要查找的对象存储位置. 为什么要有 hashCode当把对象加入 HashSet 时. HashSet会先计算对象的 hashCode 值来判断对象加入的位置, 同时会与其他加入的对象的 hashCode 值作比较, 如果没有相符的 hashCode , HashSet 会假设对象没有重复出现, 如果发现有相同的 hashCode 值的对象, 这时就会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同. 如果两者相同, HashSet 就不会让其加入操作成功. 如果不同, 就会重新散列到其他位置. 这样就大大减少了 equals 的次数, 相应地就大大提高了执行速度. hashCode() 与 equals() 相关规定 如果两个对象相等, 则 hashCode 一定也是相同的 两个对象相等, 调用 equals() 方法是返回一定是 true 两个对象有相同的 hashCode 值, 它们不一定是相等的 因此, equals 方法被重写时, hashCode 也一定要重写覆盖 hashCode 的默认行为是对堆上的对象产生独特值, 如果没有重写 hashCode , 则该 class 的两个对象无论如何都不会相等(即使这两个对象指向相同的数据) 12. 线程 进程 程序 线程 线程与进程类似, 但线程是一个比进程更小的执行单位. 一个进程在其执行过程中可以产生多个线程. 同类的多个线程共享同一块内存和一组系统资源, 所以系统在产生一个线程, 或者在各个线程之间切换工作时, 负担要比进程小得多, 因此, 线程也被称为轻量级进程 进程 进程是程序的一次执行过程,是系统运行程序的基本单位,因此进程是动态的. 系统运行一个程序即使一个进程从创建, 运行到消亡的过程. 一个正在执行的程序就是一个进程, 它在计算机中一个一个指令地执行者, 同时每个进程占有某些系统资源, 如CPU时间, 内存空间, 文件, 输入输出设备的使用权等. 当程序被执行时, 会被操作系统载入到内存中. 线程和进程的最大的不同在于基本上各进程是独立的, 而同一进程中的各线程极有可能会相互影响. 程序 程序是含有指令和数据文件, 被存储在硬盘或其他的数据存储设备中的静态代码 13. 线程的基本状态 Java 线程状态变化如下图 线程在创建之后处于 NEW(新建) 状态, 调用 start() 方法后开始运行后, 线程处于 READY(可运行) 状.可运行状态状态的线程获得了 CPU 时间片(timeslice)后就处于 RUNNING(运行) 状态. 操作系统隐藏 Java 虚拟机(JVM)中的 RUNNABLE 和 RUNNING 状态, 它只能看到 RUNNABLE 状态. 所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态. 当线程执行 wait() 方法之后, 线程进入 WAITING(等待) 状态. 进入等待状态的进程需要依靠其他线程的通知才能返回到运行状态. 而 TIME_WATING(超时等待) 状态相当于在等待状态的基础上增加了超时限制. 比如通过 sleep(long millis) 方法或 wait(long millis) 方法可以将 Java 线程置于 TIME_WATING(超时等待) 状态. 当超时时间到达后, Java 线程会返回到 RUNNABLE 状态. 当线程调用同步(synchronized)方法时, 在没有获取到锁的情况下, 线程将会进入到 BLOCKED(阻塞) 状态. 线程在执行 Runnable 的 run() 方法之后将会进入到 TERMINATED(终止) 状态 14. final static this super 关键字finalfinal 关键字主要作用在三个地方: 变量 方法 类 对于一个 final 变量, 如果是基本类型的变量, 则其一旦在初始化之后便不能修改. 如果是引用类型的变量, 则在对其进行初始化之后便不能在让其指向另一个对象. 当用 final 修饰一个类时, 表明这个类不能被继承. final 类中的所有成员方法都会被隐式地指定为 final 方法. 使用 final 方法的原因是: 把方法锁定, 以防任何继承类修改它的含义. staticstatic 关键字主要有以下四种使用场景: 修饰成员变量和成员方法: 被 static 修饰的成员属于类, 不属于单个这个类的某个对象, 被该类的所有对象共享, 建议通过类名调用. 被 static 声明的成员变量属于静态变量. 静态变量存放在 Java 内存区域的方法区. 调用格式: 类名.静态变量名 类名.静态方法名() 方法区与 java 堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据. 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分, 但是它却有一个别名叫做 Non-Heap(非堆), 目的应该是与 Java 堆区分开来 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法). 该类不管创建多少对象, 静态代码只执行一次. 1234&gt; static&#123;&gt; 静态代码块;&gt; &#125;&gt; 一个类的静态代码块可以有多个, 位置任意. 它不处于任何方法体内, JVM 加载类时会执行这些静态的代码块, 如果静态代码块有多个, JVM 将按照他们在类中出现的先后顺序依次执行它们. 静态代码块对于定义在它之后的静态变量, 可以赋值, 但是不能访问. 静态内部类(static 修饰类的话只能修饰内部类): 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后隐含地保存着一个引用, 该引用是指向创建它的外围类(外围类名.this), 但是静态内部类却没有. 静态内部类的创建是不需要依赖外围类的创建. 它不能够使用外围类的非 static 成员变量和方法. 静态内部类实现单例模式 123456789101112131415public class Singleton &#123; // 声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时, 静态内部类 SingletonHolder 没有被加载进内存. 只有当调用 getUniqueInstance() 方法而触发 Singleton.INSTANCE 时 SingletonHolder 才会被加载, 此时初始化 INSTANCE 实例, 并且 JVM 能确保该实例只被实例化一次. 静态导包(用来导入类中的静态资源): 格式为: import static 这两个关键字连用可以导入某个类中的指定静态资源, 并且不需要使用类名调用类中的静态成员, 可以直接使用类中静态变量和成员方法. 123456789101112// Math. --- 将Math中的所有静态资源导入, 这时候可以直接使用里面的静态方法, 而不用通过类名进行调用// 如果只想导入单一某个静态方法，只需要将换成对应的方法名即可import static java.lang.Math.;// 换成import static java.lang.Math.max;具有一样的效果 public class Demo &#123; public static void main(String[] args) &#123; int max = max(1,2); System.out.println(max); &#125;&#125; static{} 静态代码块与 {} 非静态代码块(构造代码块)相同点: 都是在 JVM 加载类时且在构造方法执行之前执行, 在类中都可以定义多个, 定义多个时按定义的顺序执行, 一般在代码块中对一些 static 变量进行赋值. 不同点: 静态代码块在非静态代码块之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法). 静态代码块只在第一次 new 执行一次, 之后不再执行. 而非静态代码块在每 new 一次就执行一次. 非静态代码块可以在普通方法中定义, 而静态代码块不行. 非静态代码块与构造函数的区别是: 非静态代码块是给所有对象进行统一初始化, 而构造函数是给对应的对象初始化, 因为构造函数可以是多个的, 运行哪个构造函数就会建立什么样的对象 而无论建立哪个对象, 都会先执行相同的构造代码块. 也就是说, 构造代码块中定义的是不同对象共性的初始化内容. thisthis 关键字用于引用类的当前实例, 如: 1234567891011class Manager &#123; Employees[] employees; void manageEmployees() &#123; int totalEmp = this.employees.length; System.out.println("Total employees: " + totalEmp); this.report(); &#125; void report() &#123; &#125;&#125; 在以上示例中, this 关键字用于两个地方: this.employees.length: 访问 Manager 类的当前实例的变量 this.report(): 调用 Manager 类的当前实例的方法 supersuper 关键字用于从子类访问父类的变量和方法. super.方法名(): 调用父类的非 private 方法 super(): 调用父类的构造方法 super.变量名: 操作父类的非 private 变量 使用 this 和 super 要注意的问题: super 调用父类中的其他构造方法时, 要放在构造方法的首行. this 调用本类中的其他构造方法时, 也要放在首行 this, super 不能用在 static 方法中 被 static 修饰的成员属于类, 不属于单个这个类的某个对象, 被类中所有对象共享. 而 this 代表对父类的引用, 指向父类对象. 所以, this 和 super 是属于对象范畴的东西, 而静态方法是属于类范畴的东西 15. Java 中的异常处理Java 异常类层次结构图 在 Java 中, 所有的异常都有一个共同的祖先 java.lang.Throwable类. Throwable有两个重要的子类:Exception(异常)和Error(错误). 二者都是 Java 异常处理的重要子类, 各自都包含大量的子类. Error: 是程序无法处理的错误, 表示运行程序中较严重的问题. 大多数错误是 JVM 出现的问题. 如: Java虚拟机运行错误(VritualMachineError), 当 JVM 没有足够的内存资源执行操作时, 将出现 OutOfMemoryError . 这些异常发生时, JVM 一般会选择线程终止. 这些错误表示故障发生于虚拟机自身, 或者发生在虚拟机试图执行应用时. 这些错误是不可查的, 错误通过 Error 的子类描述. Exception: 是程序本身可以处理的异常. Exception 类有一个重要的子类: RuntimeException. 该类异常由虚拟机抛出, 线程不会被终止. NullPointerException: 访问的变量没有任何引用对象时, 抛出该异常. ArithmeticException: 算数运算异常, 整数除以 0 时, 抛出该异常. ArrayIndexOutOfBoundsException: 数组下标越界时, 抛出该异常. Throwable 类常用方法 public String getMessage(): 返回异常发生时的详细信息. public String toString(): 返回异常发生时的简要描述. public String getLocalizedMessage(): 返回异常对象的本地化信息. 使用 Throwable 的子类覆盖这个方法, 可以生成本地化信息. 如果子类没有覆盖该方法, 则该方法返回的信息与 getMessage() 返回的结果相同. public void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息. 异常处理try catch try: 用于捕获异常. 其后可接任意个 catch 块. 如果没有 catch 块, 则必须跟一个 finally 块 catch: 用于处理 try 捕获到的异常. 越具体的类必须越先捕获处理. finally: 无论是否捕获或处理异常, 块中的语句都会被执行. 当在 try 块或 catch 块中遇到 return 或 throw 语句时, finally 语句块将在方法返回之前执行. 以下 4 种特殊情况下, finally块不会被执行: 在 finally 语句块中第一行发生了异常. 如果在其他行发生异常, 之前行的代码仍会执行. 在前面的代码中使用了 System.exit(int) 退出虚拟机. 程序所在的线程死亡 当所有的非守护线程中止时, 不论存不存在守护线程, 虚拟机都会kill掉守护线程从而中止程序. 所以, 如果守护线程中存在 finally 代码块, 那么当所有的非守护线程中止时, 守护线程被 kill 掉, 其 finally 代码块是不会执行的. 关闭 CPU 关于返回值: 如果 try 于中中有 return , 返回的是 try 语句块中的变量值. 详细过程如下: 如果有返回值, 就把返回值保存到局部变量中 执行 jsr 指令跳转到 finally 语句中执行 执行完 finally 语句后, 返回之前保存在局部变量中的值 如果 try , finally 块中均有 return , 则忽略 try 中的 return , 而使用 finally 中的 return throw使用 throw 语句抛出异常, 在方法上声明 , 交由调用方法的对象来处理. 16. 序列化 Java 序列化技术是将对象编码成字节流. 反之, 将字节流重新构建成对象, 称之为反序列化. 实现对象的持久化. 实现借助 common-lang 工具类 12345678910111213import org.apache.commons.lang3.SerializationUtils;public class Test &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Java"); user.setAddress("China"); byte[] bytes = SerializationUtils.serialize(user); User u = SerializationUtils.deserialize(bytes); System.out.println(u); &#125;&#125; 注意事项: 序列化对象必须实现序列化接口. 序列化对象里面的属性是对象的话也要实现序列化接口. 类的对象序列化后, 类的序列化 ID 不能轻易修改, 不然反序列化会失败. 类的对象序列化后, 类的属性有增加或者删除不会影响序列化, 只是值会丢失. 如果父类序列化了, 子类会继承父类的序列化, 子类无需添加序列化接口. 如果父类没有序列化, 子类序列化了, 子类中的属性能正常序列化, 但父类的属性会丢失, 不能序列化. 用 Java 序列化的二进制字节数据只能由 Java 反序列化, 不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成 Json/Xml 通用格式的数据, 再恢复原来的对象. 如果某个字段不想序列化, 在该字段前加上 transient 关键字即可 17. 反射 Java 反射机制在程序运行时, 对于任意一个类, 都能够知道这个类的所有属性和方法. 对于任意一个对象, 都鞥能够调用它的任意一个方法和属性. 这种动态调用对象的方法的功能, 称为 Java 的反射机制 反射机制很重要的一点就是”运行时”. 其使得我们可以在程序运行时加载, 探索以及使用编译期间完全未知的 .class文件. 也就是说, Java 程序可以在一个运行时才得知名称的 .class 文件, 然后获悉其完整构造, 并生成对象实体, 或对其变量 field 进行操作, 或调用其方法 method. 获取Class类的三种方法: 类名.class 对象名.getClass() Class.forName(“要加载的类名”) 主要方法 Class.getName(): 获取类的名称 Class.getFields(): 获取当前类及其所继承的父类的 public 变量 Class.getDeclaredFields(): 获取当前类的所有成员变量, 不论访问权限 Class.getMethods(): 获取当前类及其所继承的父类的 public 方法 Class.getDeclaredMethods(): 获取当前类的所有成员方法, 不论访问权限 Method.setAccessible(true): 获取当前方法的访问权限, 操作私有方法时必须设置, 否则会报异常 IllegalAccessException Field.setAccessible(true): 获取当前变量的访问权限, 操作私有方法时必须设置, 否则会报异常 IllegalAccessException Method.invoke(): 调用当前方法 Field.set(): 修改当前变量的值 修改常量的特殊情况使用 static final 修饰的常量值, 在 JVM 编译时, 会在常量被使用的地方将常量名直接替换为常量值来优化代码. 而有些数据类型不会被优化. 要想避免上面出现的特殊情况, 有两种方法来修改常量的值 方法一: 1234567891011public class TestClass &#123; //...... private final String FINAL_VALUE; //构造函数内为常量赋值 public TestClass()&#123; this.FINAL_VALUE = "FINAL"; &#125; //......&#125; 输出: 123Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = Modified 解释: 将赋值放在构造函数中, 构造函数只有在 new 对象时才会调用, 所以不会在编译阶段被直接优化为常量值, 而是指向常量名. 这样就可以在运行阶段来通过反射修改常量 方法二: 将声明常量的语句改为使用三目表达式赋值: 12private final String FINAL_VALUE = null == null ? "FINAL" : null; 因为 null == null ? &quot;FINAL&quot; : null 是在运行时刻计算的, 在编译时刻不会计算, 也就不会被优化. 判断是否能修改 18. 大数值BigInteger 类实现了任意精度的整数运算, BigDecimal 类实现了任意精度的浮点数运算. 应用在需要精确运算结果的场合, 如: 涉及金钱汇率以及不同表达式计算出的结果的比较 参考资料 JavaGuide: &lt;https://github.com/Snailclimb/JavaGuide Java 核心技术 第十版]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS跨域资源共享]]></title>
    <url>%2F2019%2F03%2F09%2FJavaLearning%2FWeb%2FCORS%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[简介 跨域资源共享(CORS)标准新增了一组 HTTP 首部字段,允许服务器声明哪些源站有权限访问哪些资源.另外,规范要求,对那些可能对服务器数据产生副作用的HTTP 请求方法(特别是 GET 以外的 HTTP 请求,或者搭配某些 MIME 类型的 POST 请求),浏览器必须首先使用 OPTIONS 方法发起一个预检请求(preflight request),从而获知服务端是否允许该跨域请求.服务器确认允许之后,才发起实际的 HTTP 请求.在预检请求的返回中,服务器端也可以通知客户端,是否需要携带身份凭证(包括 Cookies 和 HTTP 认证相关数据). 两种请求浏览器将CORS请求分成两类:简单请求和非简单请求 只要满足一下两个条件,就属于简单请求: 请求方法是以下三种方法之一: HEAD GET POST HTTP的header信息不超出以下几种字段 Accept Accept-Language Content-Language Last-Event-ID Content-Type只限于:application/x-www-form-urlencoded,multipart/form-data,text/plain 不满足以上条件的就属于非简单请求 简单请求对于简单请求,浏览器直接发出CORS请求.在RequestHeader中添加Origin字段 Origin字段用来说明本次请求的请求源(协议+域名+端口).服务器根据这个值决定是否同意这次请求 如果Origin指定的请求源不在许可范围内,服务器会返回一个正常的HTTP回应.这个响应的header信息中没有包含Access-Control-Allow-Origin字段,浏览器发现后就知道出错.从而抛出一个,然后被XMLHttpRequest的onerror`回调函数捕获. 这种错误无法通过状态码识别,因为是一个正常的HTTP回应 如果Origin指定的域名在许可范围内,服务器返回的响应会多出几个字段. 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 以Access-Control-的字段与CORS请求相关 Access-Control-Allow-Origin 该字段是必须的.它的值是请求时Origin字段的值,或者为*表示接受任意域名的请求. Access-Control-Allow-Credentials 该字段可选,它的值是一个布尔值,表示是否允许发送Cookies.默认情况下,Cookies不包括在CORS请求之中.设置为true则Cookie可以包含在请求中,一起发送给服务器.如果服务器不要浏览器发送 Cookie,删除该字段即可. Cookie中携带有Session Id相关信息,所以在请求一些需要得到Session进行身份验证的服务时,需要加上这个字段设置为true.比如:登录操作. 而客户端也需要在Ajax请求中打开withCredentials属性. 12345&gt; xhrFields: &#123;&gt; withCredentials: true&gt; &#125;,&gt; crossDomain: true&gt; 注意:如果要发送Cookie,Access-Control-Allow-Origin就不能为*.必须明确指定与网页一致的域名.Cookie也遵循同源策略,只有用服务器域名设置的Cookie才会上传,其他域名的Cookie不会上传.(防止了伪造Cookie的攻击手段) Access-Control-Expose-Headers 该字段可选.CORS请求时,XMLHTTPRequest对象的getResponseHeader()方法只能拿到6个基本字段:Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma.如果想要拿到其他的字段,就需要在此字段中指定.上面的例子中指定,getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值 非简单请求预检请求非简单请求是对服务器有特殊要求的请求,如请求方法为PUT或DELETE,或者Content-Type字段的类型是application/json 非简单请求的CORS请求,会在正式通信之前,增加一次HTTP查询请求,即预检请求. 浏览器查询服务器,当前网页所在的域名是否在服务器的许可名单之中,以及可以使用哪些HTTP动词和头信息字段.只有在得到肯定答复后,浏览器才会发出正式的XMLHttpRequest请求,否则就报错 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面构造了一个非简单请求.请求方法是PUT,并且发送一个自定义字段X-Custom-Header 浏览器就会自动发出一个预检请求.确认服务器是否接受这样的请求.预检请求的HTTP头信息如下 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 预检请求的请求方法是OPTIONS,表示这个请求是用来查询的.头信息里,关键字段是Origin,表示请求源 Access-Control-Request-Method 该字段是必须的,用来列出浏览器的CORS请求会用到哪些HTTP方法,这里是PUT Access-Control-Request-Headers 该字段可以有多个值,用,分隔.指定浏览器CORS请求会额外发送的头信息字段,这里是X-Custom-Header 预检请求的回应服务器收到预检请求后,检查Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后,确认是否允许跨域请求,并作出回应 123456789101112131415HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中,关键的是Access-Control-Allow-Origin字段,表示http://api.bob.com可以请求数据.如果为*表示接受任意域名的跨域请求. 如果服务器否定了预检请求,会返回一个正常的HTTP回应,但是没有任何CORS相关的头信息字段.这是浏览器会认为服务器不同意预检请求,便会出发一个错误,被XMLHttpRequest对象的onerror回调函数捕获.控制台会打印出如下的报错信息:XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. Access-Control-Allow-Methods 该字段必须,可以有多个值,用,分隔.表明服务器支持的所有跨域请求的方法.返回所有是为了避免多次预检请求. Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段,则Access-Control-Allow-Headers字段是必须的.也可以由多个值,用,分隔.表明服务器至支持的所有头信息字段,不限于浏览器在预检请求中请求的字段. Access-Control-Allow-Credentials 同简单请求. Access-Control-Max-Age 该字段可选.用来指定本次预检请求的有效期,单位为秒.在有效期内,不用发出另一条预检请求. 服务器正常请求和回应一旦服务器通过了预检请求,以后每次浏览器正常的CORS请求就会和简单请求一样,会有一个Origin头信息字段,服务器的回应也会有一个Access-Control-Allow-Origin头信息字段.]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CROS</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux线上环境搭建]]></title>
    <url>%2F2019%2F03%2F05%2FJavaLearning%2FTools%2FServerSetting%2F</url>
    <content type="text"><![CDATA[服务器环境搭建 Java安装 到官网下载jdk. 注意要使用带 Auth 的下载链接下载 解压到tar -zxvf jdk_8u_201 -C /usr/java 编辑环境变量vim /etc/profile,使环境变量生效source /etc/profile 123export JAVA_HOME=/usr/java/jdk...export CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$GIT_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$JRE_HOME/bin: 检查是否安装成功:java -version Mysql安装 到官网Yum仓库下载rpm包. rpm -ivh &lt;文件名&gt;或者yum localinstall &lt;文件名&gt;安装刚才下载好的包 此时便可以通过yum安装最新的mysql.使用指令yum install mysql-community-server安装 配置 启动mysql:service mysqld start 关闭mysql:service mysqld stop 查看mysql提供的初始root密码:cat /var/log/mysqld.log | grep password 登录mysql,若出现提示Access denied for user &#39;root&#39;@&#39;localhost&#39;,可能是密码错了.否则百度 修改root密码:ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;vnaso943983&#39;; 如果不想使用强密码,需要先降低密码策略等级: SET GLOBAL validate_password.policy=0; 创建用户CREATE USER &#39;vnaso&#39;@&#39;%&#39; IDENTIFIED BY &#39;vnaso222&#39;;,并授权:GRANT ALL ON *.* TO &#39;vnaso&#39;@&#39;%&#39; WITH GRANT OPTION; 修改默认字符集.打开/etc/my.cnf,添加如下配置 1234567891011121314# 对本地的mysql客户端的配置[client]default-character-set = utf8mb4# 对其他远程连接的mysql客户端的配置[mysql]default-character-set = utf8mb4# 本地mysql服务的配置[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_cidefault-time-zone = UTC 查看字符集:SHOW VARIABLES WHERE Variable_name LIKE &#39;character\_set\_%&#39; OR Variable_name LIKE &#39;collation%&#39;; 查看时区:show variables like &#39;%zone%&#39;; 修改时区为UTC:set time_zone = &#39;utc&#39;;flush privileges;修改时区并刷新. 如果报错Unknown or incorrect time zone: &#39;UTC&#39;,在shell执行:mysql_tzinfo_to_sql /usr/share/zoneinfo |mysql -u root mysql -p,有warning提示Unable to load xxx是正常的. 如果修改了之后,再次查询还是System,修改配置文件/etc/my.cnf,在[mysqld]下添加default-time-zone = UTC Git安装 到官网获取下载链接.wget &lt;url&gt;下载 使用tar -zxvf &lt;文件名&gt;解压缩. 安装git前置依赖:yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker 进入git安装目录下,进行安装:./configure --prefix=/usr/local/git-&gt;make &amp;&amp; make install 如果报错no such file or directory.使用:yum install autoconf然后在目录中键入autoconf,再次进行安装即可. 添加环境变量.vim /etc/profile,使环境变量生效source /etc/profile 检查是否安装成功git --version 配置 生成私钥:ssh-keygen -t rsa -C &quot;XXX@outlook.com&quot;密钥名称可自定义 告知系统来管理生成的密钥:ssh-add ~/.ssh/id_rsa 如果报错could not open a connection to your authentication agent 执行命令:eval ssh-agent(是~,而不是单引号).然后再执行:ssh-add ~/.ssh/id_rsa 在远程服务器中添加公钥:cat ~/.ssh/id_rsa.pub Nginx安装 到官网下载压缩包,解压. 安装nginx编译文件及库文件yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel pcre pcre-devel 进入解压后的目录进行安装:./configure --prefix=/usr/local/nginx-&gt;make &amp;&amp; make install 测试:/usr/local/nginx/sbin/nginx -t 配置参考Nginx配置文件说明 Tomcat安装 到官网下载压缩包,解压.一般选择core就行 防火墙打开8080端口,启动tomcat:$CATALINA_HOME/bin/startup.sh 测试:访问&lt;服务器地址&gt;:8080 配置 修改默认编码.vim /opt/Develop/apache-tomcat-9.0.16/conf/server.xml.搜索8080,在&lt;Connector&gt;节点中添加URIEncoding=&quot;UTF-8&quot; 编辑环境变量.vim /etc/profile,添加export CATALINA_HOME = /opt/apache-tomcat-9.0.1.然后source /etc/profile使配置生效 Maven安装 到官网下载压缩包,解压. 添加环境变量:vim /etc/profile,添加export $MAVEN_HOME=....并将$MAVEN_HOME/bin添加到$PATH中 source /etc/profile使配置生效 测试:mvn -v 配置 将下载镜像更换为阿里云中央仓库,解决依赖从境外网站下载过慢的问题 打开maven安装根目录-&gt;conf-&gt;settings.xml 在&lt;settings&gt;标签下找到&lt;mirrors&gt;标签,添加如下代码 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 保存即可 Vstpd安装 下载安装:yum install vstpd 创建接收上传文件的文件夹:mkdir /ftpfile 创建只有上传权限不能登录的用户:useradd ftpuser -d /ftpfile/ -s /sbin/nologin 给创建的ftpuser此用户赋予/ftpfile的权限:chown -R ftpuser.ftpuser /ftpfile/.此时用户名和用户组都是ftpuser 给ftpuser设置密码:passwd ftpuser 编辑配置文件,让上传目录指向之前创建的目录:vim /etc/vsftpd/vsftpd.conf 搜索banner节点,此处配置ftp的欢迎信息.ftpd_banner=xxxxx 可以选择添加use_localtime=yes表示使用服务器时间 添加anonymous_enable=NO关闭匿名用户访问 配置FTP被动模式的端口 pasv_min_port=30000pasv_max_port=30000 ftp配置 12345678910111213141516# 修改为NO，关闭匿名用户访问anonymous_enable=NO# 将所有本地用户限制在自家目录中。chroot_local_user=YES # 设置系统用户FTP主目录local_root=/data# 开启charoot写权限allow_writeable_chroot=YES#配置可以登录ftp的用户目录userlist_deny=NOuserlist_file=/etc/vsftpd/user_list#配置ftp用户访问目录配置目录user_config_dir=/etc/vsftpd/userconfig# 配置FTP被动模式的端口pasv_min_port=30000pasv_max_port=30000 配置ftp用户登录后访问的目录 在/etc/vsftpd目录下新建userconfig目录 在目录下配置用户的登录目录,文件名即对应的用户名 vim /etc/vsftpd/userconfig/ftpuser 在创建的文件中添加local_root=/ftpfile/ftpuser /ftpfile表示对应用户登录ftp时的根目录 注意:路径前不能有空格,否则不识别!!!!会报错unrecognised variable in config file: local_root 重启vsftpd 启动:systemctl start vsftpd.service(service vsftpd start) 停止:systemctl stop vsftpd.service(service vsftpd stop) 重启:systemctl restart vsftpd.service(service vsftpd restart) 打开防火墙,添加21端口和30000端口. 添加端口:firewall-cmd --add-port=21/tcp --permanent,firewall-cmd --add-port=21/tcp --permanent 重启防火墙:firewall-cmd --reload 测试.浏览器打开ftp://服务器地址登录.如果只能下载不能上传,请查阅开启关闭SELinux相关信息 swap交换缓存创建 创建swap文件:sudo fallocate -l 4G /swapfile(在/下创建一个大小为4G的文件swapfile) 授权swap文件:chmod 600 /swapfile(该文件的读写只能root操作) 告知系统将文件用于swap:mkswap /swapfile 启用swap文件:swapon /swapfile 确认:free 至此已经在系统中启用了swap交换缓存,但是一旦系统重启后,服务器还不能自动启用该文件. 使swap永久生效 打开文件nano /etc/fstab,在文件末尾添加/swapfile swap swap sw 0 0 ^X表示Ctrl + X,按下选择yes保存退出. 环境变量配置在腾讯云服务器中的配置 1234567export CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$GIT_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$JRE_HOME/bin:export GIT_HOME=/usr/local/gitexport MAVEN_HOME=/opt/Develop/apache-maven-3.6.0export JAVA_HOME=/usr/java/jdk1.8.0_201export JRE_HOME=/usr/java/jdk1.8.0_201/jreexport CATALINA_HOME=/opt/Develop/apache-tomcat-9.0.16]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2019%2F03%2F04%2FJavaLearning%2FTools%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux学习笔记系统命令tar解压解压到指定目录:tar -zxvf 要解压的文件 -C 目的路径 tar 命令参数 -x或–extract或–get:从备份文件中还原文件 -Z或–compress或–uncompress:通过compress指令处理备份文件 -f&lt;备份文件&gt;或–file=&lt;备份文件&gt;:指定备份文件 -v:显示操作过程 -C &lt;目录&gt;:这个选项用在解压缩,若要在特定目录解压缩,可以使用这个选项 防火墙(使用firewalld)开启关闭重启:service firewalld start/stop/restart 查看运行状态:service firewalld status/sudo firewall-cmd --state 查看防火墙开放的端口:sudo firewall-cmd --list-ports 删除端口:firewall-cmd --zone=分区名 --remove-port=端口号/通讯协议 --permanent 为防火墙添加端口:sudo firewall-cmd --zone=分区名 --add-port=端口号/通讯协议 --permanent(永久生效) 防火墙分为多个区域,可用sudo firewall-cmd --get-zones查看,默认是public 软件安装查看软件是否安装rom -qa | grep 软件名&gt; 下载安装软件yum install 软件名1,2,3.../yum -y install 软件名1,2,3... 安装rpm软件包:rpm -ivh 软件包名 卸载软件:rpm -e 软件包名/yum remove 软件包名 rpm 命令参数 -i:安装过程中显示正在安装的文件信息 -h:安装过程中显示安装进度 服务进程查看服务进程:ps -ef| grep &lt;进程名&gt; 修改权限为文件添加可执行权限:chmod +x file.name,可以用通配符*.后缀名 查看文件查看文件最后n行:tail -n &lt;行数&gt; &lt;文件名&gt; 动态查看文件最后n行:tail -n &lt;行数&gt; -f &lt;文件名&gt;,使用ctrl+c来结束 创建文件创建指定大小文件:fallocate -l &lt;文件大小&gt; &lt;文件名&gt; 例:sudo fallocate -l 4G /swapfile(在/下创建一个大小为4G的文件swapfile) 查看系统状态查看内存使用情况:free free 命令参数 -m:以MB为单位显示.默认单位为KB.向下取整 用户操作创建用户:useradd 用户名或adduser 用户名.后者创建的用户会自动创建主目录,系统shell版本和创建时输入密码,而前者没有. 修改用户密码:passwd 用户名 删除用户:userdel 用户名 下载下载: wget 下载地址 下载并指定名称: wget -O 文件名称 下载地址 vim 搜索 在normal模式下按下/即可进入查找模式,输入要查找的字符串并按下回车.Vim会跳转到第一个匹配.按下n查找下一个,按下N查找上一个. 注意查找回车应当用\n,替换回车应当用\r vim默认采用大小写敏感.在查找模式中加入\c表示大小写不敏感,\C敏感.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx学习笔记]]></title>
    <url>%2F2019%2F03%2F04%2FJavaLearning%2FTools%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx使用Nginx配置 在···/nginx/conf目录下的nginx.conf 123456789101112131415161718192021222324252627282930313233# 全局块... # events块events &#123; ...&#125;# http块http &#123; # http全局块 ... # 虚拟主机server块 server &#123; # server全局块 ... # location块 location [PATTERN] &#123; ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; # http全局块 ... &#125; 全局块 配置影响nginx全局的指令.一般有运行nginx服务器的用户组,nginx进程pid存放路径,日志存放路径,配置文件引入,允许生成worker process数等. 12345########### 每个指令必须有分号结束。##################user administrator administrators; #配置用户或者组，默认为nobody nobody。#worker_processes 2; #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg events块 配置影响nginx服务器或与用户的网络连接.有每个进程的最大连接数,选取哪种事件驱动模型处理连接请求,是否允许同时接受多个网路连接,开启多个网络连接序列化等. 123456events &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off #use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport worker_connections 1024; #每个worker process最大连接数&#125; http块 可以嵌套多个server,配置代理,缓存,日志定义等绝大多数功能和第三方模块的配置.如文件引入,mime-type定义,日志自定义,是否使用sendfile传输文件,连接超时时间,单连接请求数等. 1234567891011121314151617http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #access_log off; #取消服务日志 log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式 access_log log/access.log myFormat; #combined为日志格式的默认值 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 # 定义常量 # 负载均衡,按权重或规则将请求转发到某个服务器 upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 &#125; error_page 404 https://www.baidu.com; #请求失败时跳转的错误页 server块 配置虚拟主机的相关参数,一个http中可以有多个server. 并且可以过滤有人恶意将某些域名指向自己的主机服务器. 123456#定义某个负载均衡服务器 server &#123; keepalive_requests 120; #单连接请求上限次数。 listen 4545; #监听端口 server_name 127.0.0.1; #监听地址 &#125; server_name server_name是监听你的HTTP请求头中的host. 默认情况下，Nginx 允许直接以 IP 的方式就能直接访问到网站，或者通过未设置的域名访问(比如有人把他自己的域名指向了你的服务器 IP),可通过如下设置进行防护 例如: 1234567891011121314151617181920&gt; server &#123;&gt; listen 80 default_server;&gt; server_name _;&gt; return 444; # 过滤其他域名的请求，返回444状态码&gt; &#125;&gt; server &#123;&gt; listen 80;&gt; server_name www.aaa.com; # www.aaa.com域名&gt; location / &#123;&gt; proxy_pass http://localhost:8080; # 对应端口号8080&gt; &#125;&gt; &#125;&gt; server &#123;&gt; listen 80;&gt; server_name www.bbb.com; # www.bbb.com域名&gt; location / &#123;&gt; proxy_pass http://localhost:8081; # 对应端口号8081&gt; &#125;&gt; &#125;&gt; server_name的值为www.aaa.com.在浏览器中输入www.aaa.com,那么匹配到了对应server_name,请求就会被转发到http://localhost:8080.这里www.aaa.com和www.bbb.com都绑定到了服务器 而对于未绑定的域名指向服务器时,匹配不到配置的虚拟主机域名,就会使用默认的虚拟主机,然会返回444. listen 80 default_server:指定该server配置段为80端口的默认主机，即对于未绑定的域名指向你的服务器时,匹配不到你配置的虚拟主机域名后,会默认使用这个虚拟主机 server_name _:此处的_可以换成任意其他无效字符或无效的域名,表示该server配置不会被正常访问到 access_log:日志 格式:access_log logs/aaa.access.log main-日志类型 日志存放路径 日志格式 location块详细参考-知否 详细参考-本地 nginx跨域代理的一些设置 配置请求的路由,以及各种页面的处理情况 1234567location ~*^.+$ &#123; #请求的url过滤,正则匹配 #root path; #根目录 #index vv.txt; #设置默认页 proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip &#125; 通配符 =表示精确匹配.只有请求的url路径与后面的字符串完全相等时,才会命中 ~表示该规则是使用正则定义的,区分大小写 ~*表示该规则是使用正则定义的,不区分大小写 ^~表示如果该符号后面的字符是最佳匹配,采用该规则,不再进行后续的查找 属性解释 root表示url匹配上了此location定义的正则后,就将这个url映射到定义的根目录. 例如 location /user/img,root /usr/local/resource;. 那么如果请求为http://www.aaa.com/user/img/aaa.jpg,/user/img对应/usr/local/resource.该请求得到的结果就是/usr/local/resource下的aaa.jpg index就是设置默认的欢迎页面.页面需要存在于定义的root目录下. 接上例index index.html;. 那么如果请求为http://www.aaa.com/user/img/,请求的结果就是/usr/local/resource/user/img下的index.html,有点类似于相对路径.而如果要让index.html为/usr/local/resource/路径下的index.html的话,需要把root换为alias,具体参照root和alias的区别. 注意unknown directive所有关键词后都必须加一个空格,否则会报错unknown directive xxx Linux下命令 在···/nginx/sbin/目录下 启动nginx:nginx -s start 停止nginx:nginx -s stop 重启nginx:nginx -s reload 测试配置:nginx -t Nginx日志目录 在···/nginx/logs/目录下 目录下通常存放有access.log,error.log以及nginx.pid. nginx.pid中保存着nginx的进程号,可以通过查看此文件获取进程号来kill nginx. root和alias的区别root 示例11234location / &#123; root /data/www/; index index.html;&#125; 请求http://example.com这个地址,那么在服务器中真实对应的地址为/data/www/index.html 请求 真实地址 http://example.com /data/www/index.html http://example.com/a.png /data/www/a.png root 示例21234location /aaa/ &#123; root /data/www/; index index.html;&#125; 请求 真实地址 http://example.com/aaa/ /data/www/aaa/indexhtml http://example.com/aaa/a.gif /data/www/aaa/a.gif alias 示例11234location /&#123; alias /data/www/; index index.html;&#125; 请求 真实地址 http://example.com /data/www/index.html http://example.com/b.jpg /data/www/a.jpg alias 示例21234location /bbb/&#123; alias /data/www/; index index.html;&#125; 请求 真实地址 http://example.com/bbb/ /data/www/index.html http://example.com/bbb/b.jpg /data/www/b.jpg 对比上面4个示例可以发现,使用root的真实地址是root+location+(文件名),而使用alias的真实地址是alias+(文件名). 注意 alias只能作用在location中,而root可以存在server,http,location. alias后面必须要用/结束. Nginx实现解决前后端分离的跨域问题参考 在前端使用ajax向从后端获取数据发送跨域请求,由于浏览器的同源策略限制,会报403错误. 同源策略 同源是指”协议+域名+端口”三者相同,即便两个不同的域名指向同一个ip地址,也非同源 同源策略限制行为 Cookie,LocalStorage和IndexDB无法读取 DOM和JS对象无法获得 Ajax请求不能发送 常见的跨域场景 URL 说明 是否允许通信 http://www.domain.com/a.jshttp://www.domain.com/b.jshttp://www.domain.com/lab/c.js 同一域名,不同文件或路径 允许 http://www.domain.com:8000/a.js http://www.domain.com/b.js 同一域名,不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名,不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.jshttp://domain.com/c.js 主域相同,子域不同 不允许(cookie这种情况下也不允许访问) http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案Nginx代理跨域 一种比较简单的解决方案,无需动后端代码 Nginx配置123456789101112131415161718192021222324252627server &#123; listen 80; server_name vnaso.live; location / &#123; if ($http_origin ~* (http://vnaso\.live$) ) &#123; add_header Access-Control-Allow-Origin '$http_origin'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; add_header 'Access-Control-Allow-Credentials' 'true'; &#125; if ($http_origin ~* (http://127.0.0.1:8080$) ) &#123; add_header Access-Control-Allow-Origin '$http_origin'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; add_header 'Access-Control-Allow-Credentials' 'true'; &#125; proxy_pass http://127.0.0.1:8080/; #proxy_cookie_path / /; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Cookie $http_cookie; root /opt/Develop/apache-tomcat-9.0.16/webapps/ROOT/; # index index.html; &#125;&#125; if语句来决定匹配跨域请求,并为这些请求添加RequestHeader,上面配置的add_header Access-Control-Allow-Origin:服务器默认是不允许跨域的,这里可以添加接受跨域的请求源(origin). Access-Control-Allow-Methods:设置允许接收哪些方法的跨域请求 Access-Control-Allow-Headers:不添加此属性会报错:Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.原因是当前的Content-Type不被支持.详情看下方的预检请求. proxy_pass:表示将匹配的请求转发到该url下 proxy_set_header:为转发的请求添加RequestHeader 相关知识CORS]]></content>
      <categories>
        <category>Tool</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logback学习笔记]]></title>
    <url>%2F2019%2F02%2F15%2FJavaLearning%2FTools%2Flogback%2F</url>
    <content type="text"><![CDATA[Logback使用标签属性介绍根标签 - configuration属性 scan:布尔值.表示是否自动扫描logback.xml的文本变化. scanPeriod:字符串.表示每间隔多长时间对logback.xml进行扫描.格式:数字 + 时间单位(如:seconds,minutes) debug:布尔值.表示是否打印logback内部的日志信息. 常用配置为:&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;&lt;/configuration&gt; 表示自动每60秒扫描一次logback.xml的配置有无变化,如果有就更新,且不打印logback的内部日志.这样可以热更新logback配置文件 子标签 &lt;property&gt;:定义参数常量 &lt;appender: &lt;root&gt;: configuration - property属性 name:变量名 value:变量值 常用来设置一些配置文件中需要使用的常量值,如默认日志等级,最大保存天数,日志存储位置等. configuration - appender属性 name:变量名 class:具体的实现类的全限定类名 用来定义日志的输出源的配置 class的取值一般有两个:ch.qos.logback.core.ConsoleAppender和ch.qos.logback.core.rolling.RollingFileAppender 前者的功能是在输出到控制台,后者功能可以按时间分卷输出到文件 子标签 &lt;encoder&gt;:把日志转为字符串并将其输出到文件中 &lt;encoding&gt;:编码方式 &lt;filter&gt;:过滤器 &lt;file&gt;:日志文件输出储存位置 &lt;rollingPolicy&gt;:分卷模式 configuration - appender - encoder子标签 &lt;pattern&gt;:日志格式 configuration - appender - rollingPolicy属性 class:分卷模式的全限定类名 &lt;append&gt;:布尔值.日志被追加到文件结尾.如果是false,清空现存文件,默认是true 用来定义日志的分卷模式 class常用的类是ch.qos.logback.core.rolling.TimeBasedRollingPolicy 可以按照时间进行分卷 子标签 &lt;filenamePattern&gt;:分卷日志文件名格式 &lt;MaxHistory&gt;:日志最大保存天数 configuration - appender - filter属性 class:实现过滤规则的类的全限定类名 子标签 &lt;level&gt;:要进行过滤的级别 &lt;onMatch&gt;:等于level属性值时的操作.有NEUTRAL(有序列表里的下个过滤器过接着处理日志),ACCEPT和DENY可选 &lt;onMismatch&gt;:不等于时的操作,类上 用来定义输出源要过滤的日志等级 示例: 123456&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt;&gt; &lt;level&gt;ERROR&lt;/level&gt;&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;&gt; &lt;/filter&gt;&gt; 以上配置表示只保留Error等级的日志信息 configuration - logger属性 name:指定为哪个包或类添加appender level:指定为哪个级别及以上记录日志,如果不指定,则默认继承&lt;root&gt;下的level additivity:是否向上级传递打印信息.默认值为true 子标签 &lt;appender-ref&gt;:为name表示的包或类指定appender.用属性ref来指定 用来定义包或类的日志打印级别及指定appender 示例: 123456&gt; &lt;logger name="com.vnaso" additivity="false" level="INFO"&gt;&gt; &lt;!-- 设置日志输出 --&gt;&gt; &lt;appender-ref ref="vnasoRss"/&gt;&gt; &lt;appender-ref ref="console"/&gt;&gt; &lt;/logger&gt;&gt; 表示为com.vnaso这个包及下面所有类指定name为vnasoRss和console的appender来记录INFO及以上的日志,且不向上继承. Appender是绑定在logger上的,而logger又有继承关系,因此一个logger打印信息时的目的地Appender需要参考它的父亲和祖先.在logback中,默认情况下,如果一个logger打印一条信息,那么这条信息首先会打印至它自己的Appender,然后打印至它的父亲和父亲以上的祖先的Appender,但如果它的父亲设置了 additivity = false,那么这个logger除了打印至它自己的Appender外,只会打印至其父亲的Appender,因为它的父亲的additivity 属性置为了false,开始变得忘祖忘宗了,所以这个logger只认它父亲的Appender;此外,对于这个logger的父亲来说,如果父亲的logger打印一条信息,那么它只会打印至自己的Appender中(如果有的话),因为父亲已经忘记了爷爷及爷爷以上的那些父辈了. configuration - root属性 level(only):指定为哪个级别及以上记录日志 子标签 &lt;appender-ref&gt;:为name表示的包或类指定appender.用属性ref来指定 &lt;root&gt;标签是一种特殊的logger,但是它不能特别指定包或类.也就是说,它只能够接收继承了它且additivity值为true的logger传来的打印信息,具体查看继承关系 继承关系 继承关系是通过logger的name属性来实现的. 示例 &lt;root&gt;&gt;com.vnaso&gt;com.vnaso.controller&gt;com.vnaso.controller.UserController.java 以上对应继承关系:祖&gt;爷&gt;父&gt;子 level继承关系 appender继承关系]]></content>
      <categories>
        <category>Tool</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>Logback</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven学习笔记]]></title>
    <url>%2F2019%2F02%2F04%2FJavaLearning%2FTools%2FMaven%2F</url>
    <content type="text"><![CDATA[Maven使用Maven安装与配置下载与安装Maven官网下载地址 在如下位置点击下载最新版本Maven的压缩包 解压文件得到apache-maven-xxx文件夹.xxx为版本号 新建环境变量MAVEN_HOME,变量值为maven根目录地址 打开环境变量设置的步骤为: 右击此电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 Win+R-&gt;sysdm.cpl-&gt;高级-&gt;环境变量 编辑环境变量path,添加%MAVEN_HOME%\bin\ 至此,maven安装完毕.打开命令提示符窗口(Win+R-&gt;cmd),输入mvn -v查询maven版本,检查maven是否成功安装.成功如图所示 配置创建maven仓库 如果不自行创建,maven将默认使用Default: ${user.home}/.m2/repository作为本地仓库 在想要作为maven仓库的地方创建文件夹maven-repository作为maven的本地仓库 打开maven安装根目录-&gt;conf-&gt;settings.xml 在&lt;settings&gt;标签下,找到&lt;localRepository&gt;标签.如果没有则自行添加. 修改值为本地仓库的地址,如&lt;localRepository&gt;C:\Maven\apache-maven-3.6.0\maven-repository&lt;/localRepository&gt; 修改下载镜像地址 将下载镜像更换为阿里云中央仓库,解决依赖从境外网站下载过慢的问题 打开maven安装根目录-&gt;conf-&gt;settings.xml 在&lt;settings&gt;标签下找到&lt;mirrors&gt;标签,添加如下代码 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 保存即可 针对Maven添加依赖时没有自动提示的解决方案 到Maven仓库官网搜索,点击需要添加的依赖.复制&lt;dependency&gt;标签即可. Maven仓库官网 在IDEA中配置Maven 打开IDEA,settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven 修改Maven home directory为maven安装根目录 勾选User settings file后的Override,然后修改为安装根目录-&gt;conf-&gt;settings.xml 勾选Local repository后的Override,然后修改为本地的repository地址 Maven项目结构 项目根目录/ src/ main/ 项目主体根目录 java 源代码目录 resources 所需资源目录 filters 资源过滤文件目录 assembly 组件的描述配置(如何打包) config 配置文件 wepapp web应用的目录.WEB-INF,css,js等 test/ 项目测试目录根 java 单元测试java源代码文件 resources 测试需要用的资源库 filters c测试资源过滤库 site Site一些文档 target/ 存放项目构建后的文件和目录.jar,war,编译的class文件等 pom.xml MMaven的pom文件 LICENSE.TXT 项目的LISENCE README.TXT 项目的README Maven生命周期 Maven生命周期执行顺序从上至下 每执行当前指令之前,会把之前(上方)的指令都执行一次 每执行当前周期之前会执行之前的生命周期 clean生命周期 清理项目 clean 描述 pre-clean 执行清理前需要完成的工作execute processes needed prior to the actual project cleaning clean 清理上一次构建生成的文件remove all files generated by the previous build post-clean 执行清理后需要完成的工作execute processes needed to finalize the project cleaning default生命周期 构建项目 default 描述 validate 验证工程是否正确,所需要的资源是否可用validate the project is correct and all necessary information is available compile 编译项目的源代码compile the source code of the project test 使用已编译的测试代码,测试已编译的源代码test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed package 采用编译的代码,并以其可分配格式(如JAR)进行打包take the compiled code and package it in its distributable format, such as a JAR. verify 运行所有检查,验证包是否有效且达到质量标准run any checks on results of integration tests to ensure quality criteria are met install 把包安装在本地的repository中,可以被其他工程作为依赖来使用install the package into the local repository, for use as a dependency in other projects locally deploy 在整合或者发布环境下执行,将最终版本的包拷贝到远程的repository,使得其他的开发者或者工程可以共享done in the build environment, copies the final package to the remote repository for sharing with other developers and projects. site生命周期 建立和发布项目站点 site 描述 pre-site 生成项目站点之前需要完成的工作execute processes needed prior to the actual project site generation site 生成项目站点文档generate the project’s site documentation post-site 生成项目站点之后需要完成的工作execute processes needed to finalize the site generation, and to prepare for site deployment site-deploy 将项目站点发布到服务器deploy the generated site documentation to the specified web server Maven默认生命周期 Default Lifecycle 生命周期阶段 描述 validate 验证 确保当前配置和 POM 的内容是有效的。这包含对 pom.xml 文件树的验证。 initialize 初始化 在执行构建生命周期的主任务之前可以进行初始化。 generate-sources 生成源码 代码生成器可以开始生成在以后阶段中处理或编译的源代码。 process-sources 处理源码 提供解析、修改和转换源码。常规源码和生成的源码都可以在这里处理。 generate-resources 生成资源 可以生成非源码资源。通常包括元数据文件和配置文件。 process-resources 处理资源 处理非源码资源。修改、转换和重定位资源都能在这阶段发生。 compile 编译 编译源码。编译过的类被放到目标目录树中。 process-classes 处理类 处理类文件转换和增强步骤。字节码交织器和常用工具常在这一阶段操作。 generate-test-sources 生成测试源码 mojo 可以生成要操作的单元测试代码。 process-test-sources 处理测试源码 在编译前对测试源码执行任何必要的处理。在这一阶段，可以修改、转换或复制源代码。 generate-test-resources 生成测试资源 允许生成与测试相关的（非源码）资源。 process-test-resources 处理测试资源 可以处理、转换和重新定位与测试相关的资源。 test-compile 测试编译 编译单元测试的源码。 process-test-classes 对测试编译生成的文件做后期处理(需Maven2.0.5及以上) test 测试 运行编译过的单元测试并累计结果。 prepare-package 执行打包前的所有操作(需Maven2.1及以上) package 打包 将可执行的二进制文件打包到一个分布式归档文件中，如 JAR 或 WAR。 pre-integration-test 前集成测试 准备集成测试。这种情况下的集成测试是指在一个受到一定控制的模拟的真 实部署环境中测试代码。这一步能将归档文件部署到一个服务器上执行。 integration-test 集成测试 执行真正的集成测试。 post-integration-test 后集成测试 解除集成测试准备。这一步涉及测试环境重置或重新初始化。 verify 检验 检验可部署归档的有效性和完整性。过了这个阶段，将安装该归档。 install 安装 将该归档添加到本地 Maven 目录。这一步让其他可能依赖该归档的模块可以使用它。 deploy 部署 将该归档添加到远程 Maven 目录。这一步让这个工件能为更多的人所用。 Maven环境隔离配置 在pom.xml中的&lt;build&gt;节点下插入&lt;resources&gt;节点,在其中添加&lt;resource&gt;节点来声明要进行环境分离的resource目录.然后在pom.xml中&lt;project&gt;节点下(与&lt;build&gt;同级)增加&lt;profiles&gt;节点,通过添加&lt;profile&gt;节点来配置不同环境. 在&lt;build&gt;节点下插入&lt;resources&gt;节点 1234567891011121314&lt;resources&gt; &lt;!-- 设置resources资源文件夹目录 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources.$&#123;deploy.type&#125;&lt;/directory&gt; &lt;!-- 排除指定文件 --&gt; &lt;excludes&gt; &lt;exclude&gt;*.jsp&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;!-- 设置resources资源文件夹目录 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt;&lt;/resources&gt; 在&lt;project&gt;节点下插入&lt;profiles&gt;节点,并配置各个环境的环境标识及其他属性 123456789101112131415161718192021222324252627282930&lt;profiles&gt; &lt;!-- dev环境 --&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 设置默认使用该环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;!-- 设置环境标识 --&gt; &lt;properties&gt; &lt;deploy.type&gt;dev&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- beta环境 --&gt; &lt;profile&gt; &lt;id&gt;beta&lt;/id&gt; &lt;!-- 设置环境标识 --&gt; &lt;properties&gt; &lt;deploy.type&gt;beta&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- product环境 --&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;!-- 设置环境标识 --&gt; &lt;properties&gt; &lt;deploy.type&gt;prod&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 创建resources.&lt;环境标识&gt;目录,这样便可结合&lt;resource&gt;中定义的${deploy.type}和&lt;profile&gt;中定义的&lt;properties&gt;属性值来选择使用哪个环境 Maven命令使用 -Dmaven.test.skip=true:跳过测试 -P${deploy.type}:使用指定的环境.例如:mvn package -Pdev,使用dev环境 mvn help:effective-settings:查看生效的配置.这里的内容是settings.xml中生效的配置,可以用来查看repository地址和mirror的配置]]></content>
      <categories>
        <category>Tool</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
</search>
